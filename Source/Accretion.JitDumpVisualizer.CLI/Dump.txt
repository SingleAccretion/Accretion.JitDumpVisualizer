****** START compiling Accretion.JitDumpVisualizer.CLI.Program:Tokenize(System.String) (MethodHash=a4553a50)
Generating code for Windows x64
OPTIONS: compCodeOpt = BLENDED_CODE
OPTIONS: compDbgCode = false
OPTIONS: compDbgInfo = true
OPTIONS: compDbgEnC  = false
OPTIONS: compProcedureSplitting   = false
OPTIONS: compProcedureSplittingEH = false
IL to import:
IL_0000  14                ldnull      
IL_0001  73 16 00 00 0a    newobj       0xA000016
IL_0006  02                ldarg.0     
IL_0007  28 1f 00 00 0a    call         0xA00001F
IL_000c  28 20 00 00 0a    call         0xA000020
IL_0011  2a                ret         

lvaSetClass: setting class for V00 to (00000000D1FFAB1E) System.String 
Arg #0    passed in register(s) rcx

lvaGrabTemp returning 1 (V01 tmp0) (a long lifetime temp) called for OutgoingArgSpace.
; Initial local variable assignments
;
;  V00 arg0              ref  class-hnd
;  V01 OutArgs        lclBlk <na>  "OutgoingArgSpace"
*************** In compInitDebuggingInfo() for Accretion.JitDumpVisualizer.CLI.Program:Tokenize(System.String)
getVars() returned cVars = 0, extendOthers = true
info.compVarScopesCount = 1
    	VarNum 	LVNum 	      Name 	Beg 	End
 0: 	00h 	00h 	  V00 arg0 	000h   	012h
info.compStmtOffsetsCount    = 0
info.compStmtOffsetsImplicit = 0005h ( STACK_EMPTY CALL_SITE )
*************** In fgFindBasicBlocks() for Accretion.JitDumpVisualizer.CLI.Program:Tokenize(System.String)
Jump targets:
  none
New Basic Block BB01 [0000] created.
BB01 [000..012)
IL Code Size,Instr   18,   6, Basic Block count   1, Local Variable Num,Ref count   2,  1 for method Accretion.JitDumpVisualizer.CLI.Program:Tokenize(System.String)
OPTIONS: opts.MinOpts() == false
Basic block list for 'Accretion.JitDumpVisualizer.CLI.Program:Tokenize(System.String)'

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)        (return)                     
-----------------------------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Pre-import

*************** Finishing PHASE Pre-import

*************** Starting PHASE Importation
*************** In impImport() for Accretion.JitDumpVisualizer.CLI.Program:Tokenize(System.String)

impImportBlockPending for BB01

Importing BB01 (PC=000) of 'Accretion.JitDumpVisualizer.CLI.Program:Tokenize(System.String)'
    [ 0]   0 (0x000) ldnull
    [ 1]   1 (0x001) newobj
lvaGrabTemp returning 2 (V02 tmp1) called for NewObj constructor temp.


STMT00000 (IL 0x000...  ???)
               [000004] -A----------              *  ASG       ref   
               [000003] D------N----              +--*  LCL_VAR   ref    V02 tmp1         
               [000002] ------------              \--*  ALLOCOBJ  ref   
               [000001] H-----------                 \--*  CNS_INT(h) long   0xd1ffab1e token
Marked V02 as a single def local

lvaSetClass: setting class for V02 to (00000000D1FFAB1E) Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer  [exact]
 0A000016
In Compiler::impImportCall: opcode is newobj, kind=0, callRetType is void, structSize is 0


STMT00001 (IL   ???...  ???)
               [000006] I-C-G-------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer..ctor (exactContextHnd=0x00000000D1FFAB1E)
               [000005] ------------ this in rcx  +--*  LCL_VAR   ref    V02 tmp1         
               [000000] ------------ arg1         \--*  CNS_INT   ref    null

    [ 1]   6 (0x006) ldarg.0
    [ 2]   7 (0x007) call 0A00001F
In Compiler::impImportCall: opcode is call, kind=0, callRetType is struct, structSize is 16


STMT00002 (IL 0x006...  ???)
               [000009] I-C-G-------              *  CALL      struct System.String.op_Implicit (exactContextHnd=0x00000000D1FFAB1E)
               [000008] ------------ arg0         \--*  LCL_VAR   ref    V00 arg0         

    [ 2]  12 (0x00c) call 0A000020 (Implicit Tail call: prefixFlags |= PREFIX_TAILCALL_IMPLICIT)
In Compiler::impImportCall: opcode is call, kind=0, callRetType is void, structSize is 0
Calling impNormStructVal on:
               [000010] --C---------              *  RET_EXPR  struct(inl return from call [000009])

lvaGrabTemp returning 3 (V03 tmp2) called for struct address for call/obj.


STMT00003 (IL   ???...  ???)
               [000010] --C---------              *  RET_EXPR  void  (inl return from call [000009])
resulting tree:
               [000016] n-----------              *  OBJ       struct<System.ReadOnlySpan`1[Char], 16>
               [000015] ------------              \--*  ADDR      byref 
               [000014] -------N----                 \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V03 tmp2         

GTF_CALL_M_IMPLICIT_TAILCALL set for call [000011]


STMT00004 (IL   ???...  ???)
               [000011] I-C-G-------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer.TokenizeLine (exactContextHnd=0x00000000D1FFAB1E)
               [000007] ------------ this in rcx  +--*  LCL_VAR   ref    V02 tmp1         
               [000016] n----------- arg1         \--*  OBJ       struct<System.ReadOnlySpan`1[Char], 16>
               [000015] ------------                 \--*  ADDR      byref 
               [000014] -------N----                    \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V03 tmp2         

    [ 0]  17 (0x011) ret

STMT00005 (IL 0x011...  ???)
               [000017] ------------              *  RETURN    void  

*************** Finishing PHASE Importation
Trees after Importation

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)        (return)                     i newobj 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..012) (return), preds={} succs={}

***** BB01
STMT00000 (IL 0x000...0x011)
               [000004] -A----------              *  ASG       ref   
               [000003] D------N----              +--*  LCL_VAR   ref    V02 tmp1         
               [000002] ------------              \--*  ALLOCOBJ  ref   
               [000001] H-----------                 \--*  CNS_INT(h) long   0xd1ffab1e token

***** BB01
STMT00001 (IL   ???...  ???)
               [000006] I-C-G-------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer..ctor (exactContextHnd=0x00000000D1FFAB1E)
               [000005] ------------ this in rcx  +--*  LCL_VAR   ref    V02 tmp1         
               [000000] ------------ arg1         \--*  CNS_INT   ref    null

***** BB01
STMT00002 (IL 0x006...  ???)
               [000009] I-C-G-------              *  CALL      void   System.String.op_Implicit (exactContextHnd=0x00000000D1FFAB1E)
               [000013] ------------ arg0         +--*  ADDR      byref 
               [000012] -------N----              |  \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V03 tmp2         
               [000008] ------------ arg1         \--*  LCL_VAR   ref    V00 arg0         

***** BB01
STMT00003 (IL   ???...  ???)
               [000010] --C---------              *  RET_EXPR  void  (inl return from call [000009])

***** BB01
STMT00004 (IL   ???...  ???)
               [000011] I-C-G-------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer.TokenizeLine (exactContextHnd=0x00000000D1FFAB1E)
               [000007] ------------ this in rcx  +--*  LCL_VAR   ref    V02 tmp1         
               [000016] n----------- arg1         \--*  OBJ       struct<System.ReadOnlySpan`1[Char], 16>
               [000015] ------------                 \--*  ADDR      byref 
               [000014] -------N----                    \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V03 tmp2         

***** BB01
STMT00005 (IL 0x011...  ???)
               [000017] ------------              *  RETURN    void  

-------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Indirect call transform

 -- no candidates to transform

*************** Finishing PHASE Indirect call transform [no changes]

*************** Starting PHASE Expand patchpoints

 -- no patchpoints to transform

*************** Finishing PHASE Expand patchpoints [no changes]

*************** Starting PHASE Post-import

*************** Finishing PHASE Post-import

*************** Starting PHASE Morph - Init

New BlockSet epoch 1, # of blocks (including unused BB00): 2, bitset array size: 1 (short)

*************** In fgRemoveEmptyBlocks

*************** Finishing PHASE Morph - Init
*************** In fgDebugCheckBBlist

*************** Starting PHASE Morph - Inlining
Expanding INLINE_CANDIDATE in statement STMT00001 in BB01:
STMT00001 (IL   ???...  ???)
               [000006] I-C-G-------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer..ctor (exactContextHnd=0x00000000D1FFAB1E)
               [000005] ------------ this in rcx  +--*  LCL_VAR   ref    V02 tmp1         
               [000000] ------------ arg1         \--*  CNS_INT   ref    null
thisArg: is a local var
               [000005] ------------              *  LCL_VAR   ref    V02 tmp1         


Argument #1: is a constant
               [000000] ------------              *  CNS_INT   ref    null

INLINER: inlineInfo.tokenLookupContextHandle for Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer:.ctor(System.IO.StreamReader):this set to 0x00000000D1FFAB1E:

Invoking compiler for the inlinee method Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer:.ctor(System.IO.StreamReader):this :
IL to import:
IL_0000  02                ldarg.0     
IL_0001  73 16 00 00 0a    newobj       0xA000016
IL_0006  7d 19 00 00 04    stfld        0x4000019
IL_000b  02                ldarg.0     
IL_000c  28 17 00 00 0a    call         0xA000017
IL_0011  02                ldarg.0     
IL_0012  03                ldarg.1     
IL_0013  7d 18 00 00 04    stfld        0x4000018
IL_0018  2a                ret         

INLINER impTokenLookupContextHandle for Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer:.ctor(System.IO.StreamReader):this is 0x00000000D1FFAB1E.
*************** In fgFindBasicBlocks() for Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer:.ctor(System.IO.StreamReader):this
weight= 10 : state   3 [ ldarg.0 ]
weight=227 : state 103 [ newobj ]
weight= 31 : state 111 [ stfld ]
weight= 10 : state   3 [ ldarg.0 ]
weight= 79 : state  40 [ call ]
weight= 69 : state 226 [ ldarg.0 -> ldarg.1 -> stfld ]
weight= 19 : state  42 [ ret ]

multiplier in instance constructors increased to 1.5.
Inline candidate is mostly loads and stores.  Multiplier increased to 4.5.
Inline candidate callsite is boring.  Multiplier increased to 5.8.
calleeNativeSizeEstimate=445
callsiteNativeSizeEstimate=115
benefit multiplier=5.8
threshold=667
Native estimate for function size is within threshold for inlining 44.5 <= 66.7 (multiplier = 5.8)
Jump targets:
  none
Computing inlinee profile scale:
   ... call site not profiled
New Basic Block BB02 [0001] created.
BB02 [000..019)
Basic block list for 'Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer:.ctor(System.IO.StreamReader):this'

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB02 [0001]  1                             1        [000..019)        (return)                     
-----------------------------------------------------------------------------------------------------------------------------------------

*************** Inline @[000006] Starting PHASE Pre-import

*************** Inline @[000006] Finishing PHASE Pre-import

*************** Inline @[000006] Starting PHASE Importation
*************** In impImport() for Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer:.ctor(System.IO.StreamReader):this

impImportBlockPending for BB02

Importing BB02 (PC=000) of 'Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer:.ctor(System.IO.StreamReader):this'
    [ 0]   0 (0x000) ldarg.0
    [ 1]   1 (0x001) newobj
lvaGrabTemp returning 4 (V04 tmp3) called for NewObj constructor temp.


               [000021] -A----------              *  ASG       ref   
               [000020] D------N----              +--*  LCL_VAR   ref    V04 tmp3         
               [000019] ------------              \--*  ALLOCOBJ  ref   
               [000018] H-----------                 \--*  CNS_INT(h) long   0xd1ffab1e token
Marked V04 as a single def local

lvaSetClass: setting class for V04 to (00000000D1FFAB1E) System.Collections.Generic.Queue`1[Token]  [exact]
 0A000016
In Compiler::impImportCall: opcode is newobj, kind=0, callRetType is void, structSize is 0


               [000023] I-C-G-------              *  CALL      void   System.Collections.Generic.Queue`1[Token][Accretion.JitDumpVisualizer.Parsing.Tokens.Token]..ctor (exactContextHnd=0x00000000D1FFAB1E)
               [000022] ------------ this in rcx  \--*  LCL_VAR   ref    V04 tmp3         

    [ 2]   6 (0x006) stfld 04000019

               [000026] -A-XG-------              *  ASG       ref   
               [000025] ---XG--N----              +--*  FIELD     ref    _tokensBuffer
               [000005] ------------              |  \--*  LCL_VAR   ref    V02 tmp1         
               [000024] ------------              \--*  LCL_VAR   ref    V04 tmp3         

    [ 0]  11 (0x00b) ldarg.0
    [ 1]  12 (0x00c) call 0A000017
In Compiler::impImportCall: opcode is call, kind=0, callRetType is void, structSize is 0


               [000028] I-C-G-------              *  CALL      void   System.Object..ctor (exactContextHnd=0x00000000D1FFAB1E)
               [000027] ------------ this in rcx  \--*  LCL_VAR   ref    V02 tmp1         

    [ 0]  17 (0x011) ldarg.0
    [ 1]  18 (0x012) ldarg.1
    [ 2]  19 (0x013) stfld 04000018

               [000032] -A-XG-------              *  ASG       ref   
               [000031] ---XG--N----              +--*  FIELD     ref    _reader
               [000029] ------------              |  \--*  LCL_VAR   ref    V02 tmp1         
               [000030] ------------              \--*  CNS_INT   ref    null

    [ 0]  24 (0x018) ret
*************** Inline @[000006] Finishing PHASE Importation
Trees after Importation

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB02 [0001]  1                             1        [000..019)        (return)                     i newobj 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB02 [000..019) (return), preds={} succs={}

***** BB02
               [000021] -A----------              *  ASG       ref   
               [000020] D------N----              +--*  LCL_VAR   ref    V04 tmp3         
               [000019] ------------              \--*  ALLOCOBJ  ref   
               [000018] H-----------                 \--*  CNS_INT(h) long   0xd1ffab1e token

***** BB02
               [000023] I-C-G-------              *  CALL      void   System.Collections.Generic.Queue`1[Token][Accretion.JitDumpVisualizer.Parsing.Tokens.Token]..ctor (exactContextHnd=0x00000000D1FFAB1E)
               [000022] ------------ this in rcx  \--*  LCL_VAR   ref    V04 tmp3         

***** BB02
               [000026] -A-XG-------              *  ASG       ref   
               [000025] ---XG--N----              +--*  FIELD     ref    _tokensBuffer
               [000005] ------------              |  \--*  LCL_VAR   ref    V02 tmp1         
               [000024] ------------              \--*  LCL_VAR   ref    V04 tmp3         

***** BB02
               [000028] I-C-G-------              *  CALL      void   System.Object..ctor (exactContextHnd=0x00000000D1FFAB1E)
               [000027] ------------ this in rcx  \--*  LCL_VAR   ref    V02 tmp1         

***** BB02
               [000032] -A-XG-------              *  ASG       ref   
               [000031] ---XG--N----              +--*  FIELD     ref    _reader
               [000029] ------------              |  \--*  LCL_VAR   ref    V02 tmp1         
               [000030] ------------              \--*  CNS_INT   ref    null

-------------------------------------------------------------------------------------------------------------------

*************** Inline @[000006] Starting PHASE Indirect call transform

 -- no candidates to transform

*************** Inline @[000006] Finishing PHASE Indirect call transform [no changes]

*************** Inline @[000006] Starting PHASE Expand patchpoints

 -- no patchpoints to transform

*************** Inline @[000006] Finishing PHASE Expand patchpoints [no changes]

*************** Inline @[000006] Starting PHASE Post-import

*************** In fgRemoveEmptyBlocks

*************** Inline @[000006] Finishing PHASE Post-import


----------- Statements (and blocks) added due to the inlining of call [000006] -----------

Arguments setup:

Inlinee method body:
STMT00006 (IL   ???...  ???)
               [000021] -A----------              *  ASG       ref   
               [000020] D------N----              +--*  LCL_VAR   ref    V04 tmp3         
               [000019] ------------              \--*  ALLOCOBJ  ref   
               [000018] H-----------                 \--*  CNS_INT(h) long   0xd1ffab1e token


STMT00007 (IL   ???...  ???)
               [000023] I-C-G-------              *  CALL      void   System.Collections.Generic.Queue`1[Token][Accretion.JitDumpVisualizer.Parsing.Tokens.Token]..ctor (exactContextHnd=0x00000000D1FFAB1E)
               [000022] ------------ this in rcx  \--*  LCL_VAR   ref    V04 tmp3         


STMT00008 (IL   ???...  ???)
               [000026] -A-XG-------              *  ASG       ref   
               [000025] ---XG--N----              +--*  FIELD     ref    _tokensBuffer
               [000005] ------------              |  \--*  LCL_VAR   ref    V02 tmp1         
               [000024] ------------              \--*  LCL_VAR   ref    V04 tmp3         


STMT00009 (IL   ???...  ???)
               [000028] I-C-G-------              *  CALL      void   System.Object..ctor (exactContextHnd=0x00000000D1FFAB1E)
               [000027] ------------ this in rcx  \--*  LCL_VAR   ref    V02 tmp1         


STMT00010 (IL   ???...  ???)
               [000032] -A-XG-------              *  ASG       ref   
               [000031] ---XG--N----              +--*  FIELD     ref    _reader
               [000029] ------------              |  \--*  LCL_VAR   ref    V02 tmp1         
               [000030] ------------              \--*  CNS_INT   ref    null

fgInlineAppendStatements: no gc ref inline locals.
Successfully inlined Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer:.ctor(System.IO.StreamReader):this (25 IL bytes) (depth 1) [profitable inline]
--------------------------------------------------------------------------------------------

INLINER: during 'fgInline' result 'success' reason 'profitable inline' for 'Accretion.JitDumpVisualizer.CLI.Program:Tokenize(System.String)' calling 'Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer:.ctor(System.IO.StreamReader):this'
INLINER: during 'fgInline' result 'success' reason 'profitable inline'
Expanding INLINE_CANDIDATE in statement STMT00007 in BB01:
STMT00007 (IL   ???...  ???)
               [000023] I-C-G-------              *  CALL      void   System.Collections.Generic.Queue`1[Token][Accretion.JitDumpVisualizer.Parsing.Tokens.Token]..ctor (exactContextHnd=0x00000000D1FFAB1E)
               [000022] ------------ this in rcx  \--*  LCL_VAR   ref    V04 tmp3         
thisArg: is a local var
               [000022] ------------              *  LCL_VAR   ref    V04 tmp3         

INLINER: inlineInfo.tokenLookupContextHandle for System.Collections.Generic.Queue`1[Token][Accretion.JitDumpVisualizer.Parsing.Tokens.Token]:.ctor():this set to 0x00000000D1FFAB1E:

Invoking compiler for the inlinee method System.Collections.Generic.Queue`1[Token][Accretion.JitDumpVisualizer.Parsing.Tokens.Token]:.ctor():this :
IL to import:
IL_0000  02                ldarg.0     
IL_0001  28 0c 00 00 0a    call         0xA00000C
IL_0006  02                ldarg.0     
IL_0007  28 0e 00 00 2b    call         0x2B00000E
IL_000c  7d b7 00 00 0a    stfld        0xA0000B7
IL_0011  2a                ret         

INLINER impTokenLookupContextHandle for System.Collections.Generic.Queue`1[Token][Accretion.JitDumpVisualizer.Parsing.Tokens.Token]:.ctor():this is 0x00000000D1FFAB1E.
*************** In fgFindBasicBlocks() for System.Collections.Generic.Queue`1[Token][Accretion.JitDumpVisualizer.Parsing.Tokens.Token]:.ctor():this
weight= 10 : state   3 [ ldarg.0 ]
weight= 79 : state  40 [ call ]
weight= 10 : state   3 [ ldarg.0 ]
weight= 79 : state  40 [ call ]
weight= 31 : state 111 [ stfld ]
weight= 19 : state  42 [ ret ]

multiplier in instance constructors increased to 1.5.
Inline candidate is mostly loads and stores.  Multiplier increased to 4.5.
Inline candidate callsite is boring.  Multiplier increased to 5.8.
calleeNativeSizeEstimate=228
callsiteNativeSizeEstimate=85
benefit multiplier=5.8
threshold=493
Native estimate for function size is within threshold for inlining 22.8 <= 49.3 (multiplier = 5.8)
Jump targets:
  none
Computing inlinee profile scale:
   ... call site not profiled
New Basic Block BB03 [0002] created.
BB03 [000..012)
Basic block list for 'System.Collections.Generic.Queue`1[Token][Accretion.JitDumpVisualizer.Parsing.Tokens.Token]:.ctor():this'

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB03 [0002]  1                             1        [000..012)        (return)                     
-----------------------------------------------------------------------------------------------------------------------------------------

*************** Inline @[000023] Starting PHASE Pre-import

*************** Inline @[000023] Finishing PHASE Pre-import

*************** Inline @[000023] Starting PHASE Importation
*************** In impImport() for System.Collections.Generic.Queue`1[Token][Accretion.JitDumpVisualizer.Parsing.Tokens.Token]:.ctor():this

impImportBlockPending for BB03

Importing BB03 (PC=000) of 'System.Collections.Generic.Queue`1[Token][Accretion.JitDumpVisualizer.Parsing.Tokens.Token]:.ctor():this'
    [ 0]   0 (0x000) ldarg.0
    [ 1]   1 (0x001) call 0A00000C
In Compiler::impImportCall: opcode is call, kind=0, callRetType is void, structSize is 0


               [000034] I-C-G-------              *  CALL      void   System.Object..ctor (exactContextHnd=0x00000000D1FFAB1E)
               [000022] ------------ this in rcx  \--*  LCL_VAR   ref    V04 tmp3         

    [ 0]   6 (0x006) ldarg.0
    [ 1]   7 (0x007) call 2B00000E
In Compiler::impImportCall: opcode is call, kind=0, callRetType is ref, structSize is 0


               [000036] I-C-G-------              *  CALL      ref    System.Array.Empty (exactContextHnd=0x00000000D1FFAB1E)

    [ 2]  12 (0x00c) stfld 0A0000B7

               [000039] -ACXG-------              *  ASG       ref   
               [000038] ---XG--N----              +--*  FIELD     ref    _array
               [000035] ------------              |  \--*  LCL_VAR   ref    V04 tmp3         
               [000037] --C---------              \--*  RET_EXPR  ref   (inl return from call [000036])

    [ 0]  17 (0x011) ret
*************** Inline @[000023] Finishing PHASE Importation
Trees after Importation

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB03 [0002]  1                             1        [000..012)        (return)                     i 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB03 [000..012) (return), preds={} succs={}

***** BB03
               [000034] I-C-G-------              *  CALL      void   System.Object..ctor (exactContextHnd=0x00000000D1FFAB1E)
               [000022] ------------ this in rcx  \--*  LCL_VAR   ref    V04 tmp3         

***** BB03
               [000036] I-C-G-------              *  CALL      ref    System.Array.Empty (exactContextHnd=0x00000000D1FFAB1E)

***** BB03
               [000039] -ACXG-------              *  ASG       ref   
               [000038] ---XG--N----              +--*  FIELD     ref    _array
               [000035] ------------              |  \--*  LCL_VAR   ref    V04 tmp3         
               [000037] --C---------              \--*  RET_EXPR  ref   (inl return from call [000036])

-------------------------------------------------------------------------------------------------------------------

*************** Inline @[000023] Starting PHASE Indirect call transform

 -- no candidates to transform

*************** Inline @[000023] Finishing PHASE Indirect call transform [no changes]

*************** Inline @[000023] Starting PHASE Expand patchpoints

 -- no patchpoints to transform

*************** Inline @[000023] Finishing PHASE Expand patchpoints [no changes]

*************** Inline @[000023] Starting PHASE Post-import

*************** In fgRemoveEmptyBlocks

*************** Inline @[000023] Finishing PHASE Post-import


----------- Statements (and blocks) added due to the inlining of call [000023] -----------

Arguments setup:

Inlinee method body:
STMT00011 (IL   ???...  ???)
               [000034] I-C-G-------              *  CALL      void   System.Object..ctor (exactContextHnd=0x00000000D1FFAB1E)
               [000022] ------------ this in rcx  \--*  LCL_VAR   ref    V04 tmp3         


STMT00012 (IL   ???...  ???)
               [000036] I-C-G-------              *  CALL      ref    System.Array.Empty (exactContextHnd=0x00000000D1FFAB1E)


STMT00013 (IL   ???...  ???)
               [000039] -ACXG-------              *  ASG       ref   
               [000038] ---XG--N----              +--*  FIELD     ref    _array
               [000035] ------------              |  \--*  LCL_VAR   ref    V04 tmp3         
               [000037] --C---------              \--*  RET_EXPR  ref   (inl return from call [000036])

fgInlineAppendStatements: no gc ref inline locals.
Successfully inlined System.Collections.Generic.Queue`1[Token][Accretion.JitDumpVisualizer.Parsing.Tokens.Token]:.ctor():this (18 IL bytes) (depth 2) [profitable inline]
--------------------------------------------------------------------------------------------

INLINER: during 'fgInline' result 'success' reason 'profitable inline' for 'Accretion.JitDumpVisualizer.CLI.Program:Tokenize(System.String)' calling 'System.Collections.Generic.Queue`1[Token][Accretion.JitDumpVisualizer.Parsing.Tokens.Token]:.ctor():this'
INLINER: during 'fgInline' result 'success' reason 'profitable inline'
Expanding INLINE_CANDIDATE in statement STMT00011 in BB01:
STMT00011 (IL   ???...  ???)
               [000034] I-C-G-------              *  CALL      void   System.Object..ctor (exactContextHnd=0x00000000D1FFAB1E)
               [000022] ------------ this in rcx  \--*  LCL_VAR   ref    V04 tmp3         
thisArg: is a local var
               [000022] ------------              *  LCL_VAR   ref    V04 tmp3         

INLINER: inlineInfo.tokenLookupContextHandle for System.Object:.ctor():this set to 0x00000000D1FFAB1E:

Invoking compiler for the inlinee method System.Object:.ctor():this :
IL to import:
IL_0000  2a                ret         

INLINER impTokenLookupContextHandle for System.Object:.ctor():this is 0x00000000D1FFAB1E.
*************** In fgFindBasicBlocks() for System.Object:.ctor():this
Jump targets:
  none
Computing inlinee profile scale:
   ... call site not profiled
New Basic Block BB04 [0003] created.
BB04 [000..001)
Basic block list for 'System.Object:.ctor():this'

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB04 [0003]  1                             1        [000..001)        (return)                     
-----------------------------------------------------------------------------------------------------------------------------------------

*************** Inline @[000034] Starting PHASE Pre-import

*************** Inline @[000034] Finishing PHASE Pre-import

*************** Inline @[000034] Starting PHASE Importation
*************** In impImport() for System.Object:.ctor():this

impImportBlockPending for BB04

Importing BB04 (PC=000) of 'System.Object:.ctor():this'
    [ 0]   0 (0x000) ret
** Note: inlinee IL was partially imported -- imported 0 of 1 bytes of method IL

*************** Inline @[000034] Finishing PHASE Importation
Trees after Importation

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB04 [0003]  1                             1        [000..001)        (return)                     i 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB04 [000..001) (return), preds={} succs={}

-------------------------------------------------------------------------------------------------------------------

*************** Inline @[000034] Starting PHASE Indirect call transform

 -- no candidates to transform

*************** Inline @[000034] Finishing PHASE Indirect call transform [no changes]

*************** Inline @[000034] Starting PHASE Expand patchpoints

 -- no patchpoints to transform

*************** Inline @[000034] Finishing PHASE Expand patchpoints [no changes]

*************** Inline @[000034] Starting PHASE Post-import

*************** In fgRemoveEmptyBlocks

*************** Inline @[000034] Finishing PHASE Post-import


----------- Statements (and blocks) added due to the inlining of call [000034] -----------

Arguments setup:

Inlinee method body:fgInlineAppendStatements: no gc ref inline locals.
Successfully inlined System.Object:.ctor():this (1 IL bytes) (depth 3) [below ALWAYS_INLINE size]
--------------------------------------------------------------------------------------------

INLINER: during 'fgInline' result 'success' reason 'below ALWAYS_INLINE size' for 'Accretion.JitDumpVisualizer.CLI.Program:Tokenize(System.String)' calling 'System.Object:.ctor():this'
INLINER: during 'fgInline' result 'success' reason 'below ALWAYS_INLINE size'
Expanding INLINE_CANDIDATE in statement STMT00012 in BB01:
STMT00012 (IL   ???...  ???)
               [000036] I-C-G-------              *  CALL      ref    System.Array.Empty (exactContextHnd=0x00000000D1FFAB1E)
INLINER: inlineInfo.tokenLookupContextHandle for System.Array:Empty():Accretion.JitDumpVisualizer.Parsing.Tokens.Token[] set to 0x00000000D1FFAB1E:

Invoking compiler for the inlinee method System.Array:Empty():Accretion.JitDumpVisualizer.Parsing.Tokens.Token[] :
IL to import:
IL_0000  7e 0d 00 00 0a    ldsfld       0xA00000D
IL_0005  2a                ret         

INLINER impTokenLookupContextHandle for System.Array:Empty():Accretion.JitDumpVisualizer.Parsing.Tokens.Token[] is 0x00000000D1FFAB1E.
*************** In fgFindBasicBlocks() for System.Array:Empty():Accretion.JitDumpVisualizer.Parsing.Tokens.Token[]
Jump targets:
  none
Computing inlinee profile scale:
   ... call site not profiled
New Basic Block BB05 [0004] created.
BB05 [000..006)
Basic block list for 'System.Array:Empty():Accretion.JitDumpVisualizer.Parsing.Tokens.Token[]'

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB05 [0004]  1                             1        [000..006)        (return)                     
-----------------------------------------------------------------------------------------------------------------------------------------

*************** Inline @[000036] Starting PHASE Pre-import

*************** Inline @[000036] Finishing PHASE Pre-import

*************** Inline @[000036] Starting PHASE Importation
*************** In impImport() for System.Array:Empty():Accretion.JitDumpVisualizer.Parsing.Tokens.Token[]

impImportBlockPending for BB05

Importing BB05 (PC=000) of 'System.Array:Empty():Accretion.JitDumpVisualizer.Parsing.Tokens.Token[]'
    [ 0]   0 (0x000) ldsfld 0A00000D
    [ 1]   5 (0x005) ret

    Inlinee Return expression (before normalization)  =>
               [000047] --CXG-------              *  COMMA     ref   
               [000046] H-CXG-------              +--*  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS
               [000044] ------------ arg0         |  +--*  CNS_INT   long   0x7ffa40fb0028
               [000045] ------------ arg1         |  \--*  CNS_INT   int    6
               [000042] ----G-------              \--*  FIELD     ref    Value


    Inlinee Return expression (after normalization) =>
               [000047] --CXG-------              *  COMMA     ref   
               [000046] H-CXG-------              +--*  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS
               [000044] ------------ arg0         |  +--*  CNS_INT   long   0x7ffa40fb0028
               [000045] ------------ arg1         |  \--*  CNS_INT   int    6
               [000042] ----G-------              \--*  FIELD     ref    Value

** Note: inlinee IL was partially imported -- imported 0 of 6 bytes of method IL

*************** Inline @[000036] Finishing PHASE Importation
Trees after Importation

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB05 [0004]  1                             1        [000..006)        (return)                     i 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB05 [000..006) (return), preds={} succs={}

-------------------------------------------------------------------------------------------------------------------

*************** Inline @[000036] Starting PHASE Indirect call transform

 -- no candidates to transform

*************** Inline @[000036] Finishing PHASE Indirect call transform [no changes]

*************** Inline @[000036] Starting PHASE Expand patchpoints

 -- no patchpoints to transform

*************** Inline @[000036] Finishing PHASE Expand patchpoints [no changes]

*************** Inline @[000036] Starting PHASE Post-import

*************** In fgRemoveEmptyBlocks

*************** Inline @[000036] Finishing PHASE Post-import


----------- Statements (and blocks) added due to the inlining of call [000036] -----------

Inlinee method body:fgInlineAppendStatements: no gc ref inline locals.

Return expression for call at [000036] is
               [000047] --CXG-------              *  COMMA     ref   
               [000046] H-CXG-------              +--*  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS
               [000044] ------------ arg0         |  +--*  CNS_INT   long   0x7ffa40fb0028
               [000045] ------------ arg1         |  \--*  CNS_INT   int    6
               [000042] ----G-------              \--*  FIELD     ref    Value
Successfully inlined System.Array:Empty():Accretion.JitDumpVisualizer.Parsing.Tokens.Token[] (6 IL bytes) (depth 3) [below ALWAYS_INLINE size]
--------------------------------------------------------------------------------------------

INLINER: during 'fgInline' result 'success' reason 'below ALWAYS_INLINE size' for 'Accretion.JitDumpVisualizer.CLI.Program:Tokenize(System.String)' calling 'System.Array:Empty():Accretion.JitDumpVisualizer.Parsing.Tokens.Token[]'
INLINER: during 'fgInline' result 'success' reason 'below ALWAYS_INLINE size'

Replacing the return expression placeholder [000037] with [000047]
               [000037] --C---------              *  RET_EXPR  ref   (inl return from call [000047])

Inserting the inline return expression
               [000047] --CXG-------              *  COMMA     ref   
               [000046] H-CXG-------              +--*  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS
               [000044] ------------ arg0         |  +--*  CNS_INT   long   0x7ffa40fb0028
               [000045] ------------ arg1         |  \--*  CNS_INT   int    6
               [000042] ----G-------              \--*  FIELD     ref    Value

Expanding INLINE_CANDIDATE in statement STMT00009 in BB01:
STMT00009 (IL   ???...  ???)
               [000028] I-C-G-------              *  CALL      void   System.Object..ctor (exactContextHnd=0x00000000D1FFAB1E)
               [000027] ------------ this in rcx  \--*  LCL_VAR   ref    V02 tmp1         
thisArg: is a local var
               [000027] ------------              *  LCL_VAR   ref    V02 tmp1         

INLINER: inlineInfo.tokenLookupContextHandle for System.Object:.ctor():this set to 0x00000000D1FFAB1E:

Invoking compiler for the inlinee method System.Object:.ctor():this :
IL to import:
IL_0000  2a                ret         

INLINER impTokenLookupContextHandle for System.Object:.ctor():this is 0x00000000D1FFAB1E.
*************** In fgFindBasicBlocks() for System.Object:.ctor():this
Jump targets:
  none
Computing inlinee profile scale:
   ... call site not profiled
New Basic Block BB06 [0005] created.
BB06 [000..001)
Basic block list for 'System.Object:.ctor():this'

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB06 [0005]  1                             1        [000..001)        (return)                     
-----------------------------------------------------------------------------------------------------------------------------------------

*************** Inline @[000028] Starting PHASE Pre-import

*************** Inline @[000028] Finishing PHASE Pre-import

*************** Inline @[000028] Starting PHASE Importation
*************** In impImport() for System.Object:.ctor():this

impImportBlockPending for BB06

Importing BB06 (PC=000) of 'System.Object:.ctor():this'
    [ 0]   0 (0x000) ret
** Note: inlinee IL was partially imported -- imported 0 of 1 bytes of method IL

*************** Inline @[000028] Finishing PHASE Importation
Trees after Importation

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB06 [0005]  1                             1        [000..001)        (return)                     i 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB06 [000..001) (return), preds={} succs={}

-------------------------------------------------------------------------------------------------------------------

*************** Inline @[000028] Starting PHASE Indirect call transform

 -- no candidates to transform

*************** Inline @[000028] Finishing PHASE Indirect call transform [no changes]

*************** Inline @[000028] Starting PHASE Expand patchpoints

 -- no patchpoints to transform

*************** Inline @[000028] Finishing PHASE Expand patchpoints [no changes]

*************** Inline @[000028] Starting PHASE Post-import

*************** In fgRemoveEmptyBlocks

*************** Inline @[000028] Finishing PHASE Post-import


----------- Statements (and blocks) added due to the inlining of call [000028] -----------

Arguments setup:

Inlinee method body:fgInlineAppendStatements: no gc ref inline locals.
Successfully inlined System.Object:.ctor():this (1 IL bytes) (depth 2) [below ALWAYS_INLINE size]
--------------------------------------------------------------------------------------------

INLINER: during 'fgInline' result 'success' reason 'below ALWAYS_INLINE size' for 'Accretion.JitDumpVisualizer.CLI.Program:Tokenize(System.String)' calling 'System.Object:.ctor():this'
INLINER: during 'fgInline' result 'success' reason 'below ALWAYS_INLINE size'
Expanding INLINE_CANDIDATE in statement STMT00002 in BB01:
STMT00002 (IL 0x006...  ???)
               [000009] I-C-G-------              *  CALL      void   System.String.op_Implicit (exactContextHnd=0x00000000D1FFAB1E)
               [000013] ------------ arg0         +--*  ADDR      byref 
               [000012] -------N----              |  \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V03 tmp2         
               [000008] ------------ arg1         \--*  LCL_VAR   ref    V00 arg0         

Argument #0: is a local var
               [000008] ------------              *  LCL_VAR   ref    V00 arg0         

INLINER: inlineInfo.tokenLookupContextHandle for System.String:op_Implicit(System.String):System.ReadOnlySpan`1[Char] set to 0x00000000D1FFAB1E:

Invoking compiler for the inlinee method System.String:op_Implicit(System.String):System.ReadOnlySpan`1[Char] :
IL to import:
IL_0000  02                ldarg.0     
IL_0001  2d 0a             brtrue.s     10 (IL_000d)
IL_0003  12 00             ldloca.s     0x0
IL_0005  fe 15 03 00 00 1b initobj      0x1B000003
IL_000b  06                ldloc.0     
IL_000c  2a                ret         
IL_000d  02                ldarg.0     
IL_000e  6f e7 06 00 06    callvirt     0x60006E7
IL_0013  02                ldarg.0     
IL_0014  6f 91 06 00 06    callvirt     0x6000691
IL_0019  73 b7 00 00 0a    newobj       0xA0000B7
IL_001e  2a                ret         

INLINER impTokenLookupContextHandle for System.String:op_Implicit(System.String):System.ReadOnlySpan`1[Char] is 0x00000000D1FFAB1E.
*************** In fgFindBasicBlocks() for System.String:op_Implicit(System.String):System.ReadOnlySpan`1[Char]
Jump targets:
  IL_000d
Computing inlinee profile scale:
   ... call site not profiled
New Basic Block BB07 [0006] created.
BB07 [000..003)
New Basic Block BB08 [0007] created.
BB08 [003..00D)
New Basic Block BB09 [0008] created.
BB09 [00D..01F)

lvaGrabTemp returning 5 (V05 tmp4) (a long lifetime temp) called for Inline return value spill temp.
Basic block list for 'System.String:op_Implicit(System.String):System.ReadOnlySpan`1[Char]'

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB07 [0006]  1                             1        [000..003)-> BB09 ( cond )                     
BB08 [0007]  1                             1        [003..00D)        (return)                     
BB09 [0008]  1                             1        [00D..01F)        (return)                     
-----------------------------------------------------------------------------------------------------------------------------------------

*************** Inline @[000009] Starting PHASE Pre-import

*************** Inline @[000009] Finishing PHASE Pre-import

*************** Inline @[000009] Starting PHASE Importation
*************** In impImport() for System.String:op_Implicit(System.String):System.ReadOnlySpan`1[Char]

impImportBlockPending for BB07

Importing BB07 (PC=000) of 'System.String:op_Implicit(System.String):System.ReadOnlySpan`1[Char]'
    [ 0]   0 (0x000) ldarg.0
    [ 1]   1 (0x001) brtrue.s

               [000052] ------------              *  JTRUE     void  
               [000051] ------------              \--*  NE        int   
               [000008] ------------                 +--*  LCL_VAR   ref    V00 arg0         
               [000050] ------------                 \--*  CNS_INT   ref    null

impImportBlockPending for BB08

impImportBlockPending for BB09

Importing BB09 (PC=013) of 'System.String:op_Implicit(System.String):System.ReadOnlySpan`1[Char]'
    [ 0]  13 (0x00d) ldarg.0
    [ 1]  14 (0x00e) callvirt 060006E7
In Compiler::impImportCall: opcode is callvirt, kind=0, callRetType is byref, structSize is 0


               [000054] I-C-G-------              *  CALL nullcheck byref  System.String.GetRawStringData (exactContextHnd=0x00000000D1FFAB1E)
               [000053] ------------ this in rcx  \--*  LCL_VAR   ref    V00 arg0         

    [ 1]  19 (0x013) ldarg.0
    [ 2]  20 (0x014) callvirt 06000691
In Compiler::impImportCall: opcode is callvirt, kind=0, callRetType is int, structSize is 0

    [ 2]  25 (0x019) newobj
lvaGrabTemp returning 6 (V06 tmp5) called for NewObj constructor temp.


               [000060] IA----------              *  ASG       struct (init)
               [000058] D------N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V06 tmp5         
               [000059] ------------              \--*  CNS_INT   int    0
 0A0000B7
In Compiler::impImportCall: opcode is newobj, kind=0, callRetType is void, structSize is 0


               [000063] I-CXG-------              *  CALL      void   System.ReadOnlySpan`1[Char][System.Char]..ctor (exactContextHnd=0x00000000D1FFAB1E)
               [000062] ------------ this in rcx  +--*  ADDR      byref 
               [000061] -------N----              |  \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V06 tmp5         
               [000055] --C--------- arg1         +--*  RET_EXPR  byref (inl return from call [000054])
               [000057] ---X-------- arg2         \--*  ARR_LENGTH int   
               [000056] ------------                 \--*  LCL_VAR   ref    V00 arg0         

    [ 1]  30 (0x01e) ret

    Inlinee Return expression (before normalization)  =>
               [000064] ------------              *  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V06 tmp5         


               [000067] -A----------              *  ASG       struct (copy)
               [000065] D------N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V05 tmp4         
               [000064] ------------              \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V06 tmp5         

Importing BB08 (PC=003) of 'System.String:op_Implicit(System.String):System.ReadOnlySpan`1[Char]'
    [ 0]   3 (0x003) ldloca.s 0
lvaGrabTemp returning 7 (V07 tmp6) (a long lifetime temp) called for Inline ldloca(s) first use temp.

    [ 1]   5 (0x005) initobj 1B000003

               [000075] IA----------              *  ASG       struct (init)
               [000072] D------N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V07 tmp6         
               [000074] ------------              \--*  CNS_INT   int    0

    [ 0]  11 (0x00b) ldloc.0
    [ 1]  12 (0x00c) ret

    Inlinee Return expression (before normalization)  =>
               [000076] ------------              *  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V07 tmp6         


               [000079] -A----------              *  ASG       struct (copy)
               [000077] D------N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V05 tmp4         
               [000076] ------------              \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V07 tmp6         

*************** Inline @[000009] Finishing PHASE Importation
Trees after Importation

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB07 [0006]  1                             1        [000..003)-> BB09 ( cond )                     i 
BB08 [0007]  1                             1        [003..00D)        (return)                     i 
BB09 [0008]  1                             1        [00D..01F)        (return)                     i idxlen 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB07 [000..003) -> BB09 (cond), preds={} succs={BB08,BB09}

***** BB07
               [000052] ------------              *  JTRUE     void  
               [000051] ------------              \--*  NE        int   
               [000008] ------------                 +--*  LCL_VAR   ref    V00 arg0         
               [000050] ------------                 \--*  CNS_INT   ref    null

------------ BB08 [003..00D) (return), preds={} succs={}

***** BB08
               [000075] IA----------              *  ASG       struct (init)
               [000072] D------N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V07 tmp6         
               [000074] ------------              \--*  CNS_INT   int    0

***** BB08
               [000079] -A----------              *  ASG       struct (copy)
               [000077] D------N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V05 tmp4         
               [000076] ------------              \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V07 tmp6         

------------ BB09 [00D..01F) (return), preds={} succs={}

***** BB09
               [000054] I-C-G-------              *  CALL nullcheck byref  System.String.GetRawStringData (exactContextHnd=0x00000000D1FFAB1E)
               [000053] ------------ this in rcx  \--*  LCL_VAR   ref    V00 arg0         

***** BB09
               [000060] IA----------              *  ASG       struct (init)
               [000058] D------N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V06 tmp5         
               [000059] ------------              \--*  CNS_INT   int    0

***** BB09
               [000063] I-CXG-------              *  CALL      void   System.ReadOnlySpan`1[Char][System.Char]..ctor (exactContextHnd=0x00000000D1FFAB1E)
               [000062] ------------ this in rcx  +--*  ADDR      byref 
               [000061] -------N----              |  \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V06 tmp5         
               [000055] --C--------- arg1         +--*  RET_EXPR  byref (inl return from call [000054])
               [000057] ---X-------- arg2         \--*  ARR_LENGTH int   
               [000056] ------------                 \--*  LCL_VAR   ref    V00 arg0         

***** BB09
               [000067] -A----------              *  ASG       struct (copy)
               [000065] D------N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V05 tmp4         
               [000064] ------------              \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V06 tmp5         

-------------------------------------------------------------------------------------------------------------------

*************** Inline @[000009] Starting PHASE Indirect call transform

 -- no candidates to transform

*************** Inline @[000009] Finishing PHASE Indirect call transform [no changes]

*************** Inline @[000009] Starting PHASE Expand patchpoints

 -- no patchpoints to transform

*************** Inline @[000009] Finishing PHASE Expand patchpoints [no changes]

*************** Inline @[000009] Starting PHASE Post-import

*************** In fgRemoveEmptyBlocks

*************** Inline @[000009] Finishing PHASE Post-import


----------- Statements (and blocks) added due to the inlining of call [000009] -----------

Arguments setup:

Inlinee method body:New Basic Block BB10 [0009] created.

Convert bbJumpKind of BB08 to BBJ_ALWAYS to bottomBlock BB10

Convert bbJumpKind of BB09 to BBJ_NONE
fgInlineAppendStatements: no gc ref inline locals.

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB07 [0006]  1                             1        [006..007)-> BB09 ( cond )                     i 
BB08 [0007]  1                             1        [006..007)-> BB10 (always)                     i 
BB09 [0008]  1                             1        [006..007)                                     i idxlen 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB07 [006..007) -> BB09 (cond), preds={} succs={BB08,BB09}

***** BB07
STMT00014 (IL 0x006...  ???)
               [000052] ------------              *  JTRUE     void  
               [000051] ------------              \--*  NE        int   
               [000008] ------------                 +--*  LCL_VAR   ref    V00 arg0         
               [000050] ------------                 \--*  CNS_INT   ref    null

------------ BB08 [006..007) -> BB10 (always), preds={} succs={BB10}

***** BB08
STMT00019 (IL 0x006...  ???)
               [000075] IA----------              *  ASG       struct (init)
               [000072] D------N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V07 tmp6         
               [000074] ------------              \--*  CNS_INT   int    0

***** BB08
STMT00020 (IL 0x006...  ???)
               [000079] -A----------              *  ASG       struct (copy)
               [000077] D------N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V05 tmp4         
               [000076] ------------              \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V07 tmp6         

------------ BB09 [006..007), preds={} succs={BB10}

***** BB09
STMT00015 (IL 0x006...  ???)
               [000054] I-C-G-------              *  CALL nullcheck byref  System.String.GetRawStringData (exactContextHnd=0x00000000D1FFAB1E)
               [000053] ------------ this in rcx  \--*  LCL_VAR   ref    V00 arg0         

***** BB09
STMT00016 (IL 0x006...  ???)
               [000060] IA----------              *  ASG       struct (init)
               [000058] D------N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V06 tmp5         
               [000059] ------------              \--*  CNS_INT   int    0

***** BB09
STMT00017 (IL 0x006...  ???)
               [000063] I-CXG-------              *  CALL      void   System.ReadOnlySpan`1[Char][System.Char]..ctor (exactContextHnd=0x00000000D1FFAB1E)
               [000062] ------------ this in rcx  +--*  ADDR      byref 
               [000061] -------N----              |  \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V06 tmp5         
               [000055] --C--------- arg1         +--*  RET_EXPR  byref (inl return from call [000054])
               [000057] ---X-------- arg2         \--*  ARR_LENGTH int   
               [000056] ------------                 \--*  LCL_VAR   ref    V00 arg0         

***** BB09
STMT00018 (IL 0x006...  ???)
               [000067] -A----------              *  ASG       struct (copy)
               [000065] D------N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V05 tmp4         
               [000064] ------------              \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V06 tmp5         

-------------------------------------------------------------------------------------------------------------------
INLINER: Updating optMethodFlags --  root:2 callee:4 new:6

Return expression for call at [000009] is
               [000071] -A----------              *  ASG       struct (copy)
               [000069] D------N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V03 tmp2         
               [000070] ------------              \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V05 tmp4         
Successfully inlined System.String:op_Implicit(System.String):System.ReadOnlySpan`1[Char] (31 IL bytes) (depth 1) [aggressive inline attribute]
--------------------------------------------------------------------------------------------

INLINER: during 'fgInline' result 'success' reason 'aggressive inline attribute' for 'Accretion.JitDumpVisualizer.CLI.Program:Tokenize(System.String)' calling 'System.String:op_Implicit(System.String):System.ReadOnlySpan`1[Char]'
INLINER: during 'fgInline' result 'success' reason 'aggressive inline attribute'
Expanding INLINE_CANDIDATE in statement STMT00015 in BB09:
STMT00015 (IL 0x006...  ???)
               [000054] I-C-G-------              *  CALL nullcheck byref  System.String.GetRawStringData (exactContextHnd=0x00000000D1FFAB1E)
               [000053] ------------ this in rcx  \--*  LCL_VAR   ref    V00 arg0         
thisArg: is a local var
               [000053] ------------              *  LCL_VAR   ref    V00 arg0         

INLINER: inlineInfo.tokenLookupContextHandle for System.String:GetRawStringData():byref:this set to 0x00000000D1FFAB1E:

Invoking compiler for the inlinee method System.String:GetRawStringData():byref:this :
IL to import:
IL_0000  02                ldarg.0     
IL_0001  7c 1c 02 00 04    ldflda       0x400021C
IL_0006  2a                ret         

INLINER impTokenLookupContextHandle for System.String:GetRawStringData():byref:this is 0x00000000D1FFAB1E.
*************** In fgFindBasicBlocks() for System.String:GetRawStringData():byref:this
Jump targets:
  none
Computing inlinee profile scale:
   ... call site not profiled
New Basic Block BB11 [0010] created.
BB11 [000..007)
Basic block list for 'System.String:GetRawStringData():byref:this'

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB11 [0010]  1                             1        [000..007)        (return)                     
-----------------------------------------------------------------------------------------------------------------------------------------

*************** Inline @[000054] Starting PHASE Pre-import

*************** Inline @[000054] Finishing PHASE Pre-import

*************** Inline @[000054] Starting PHASE Importation
*************** In impImport() for System.String:GetRawStringData():byref:this

impImportBlockPending for BB11

Importing BB11 (PC=000) of 'System.String:GetRawStringData():byref:this'
    [ 0]   0 (0x000) ldarg.0
    [ 1]   1 (0x001) ldflda 0400021C
    [ 1]   6 (0x006) ret

    Inlinee Return expression (before normalization)  =>
               [000084] ---XG-------              *  ADDR      byref 
               [000083] ---XG--N----              \--*  FIELD     ushort _firstChar
               [000053] ------------                 \--*  LCL_VAR   ref    V00 this         


    Inlinee Return expression (after normalization) =>
               [000084] ---XG-------              *  ADDR      byref 
               [000083] ---XG--N----              \--*  FIELD     ushort _firstChar
               [000053] ------------                 \--*  LCL_VAR   ref    V00 this         

** Note: inlinee IL was partially imported -- imported 0 of 7 bytes of method IL

*************** Inline @[000054] Finishing PHASE Importation
Trees after Importation

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB11 [0010]  1                             1        [000..007)        (return)                     i 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB11 [000..007) (return), preds={} succs={}

-------------------------------------------------------------------------------------------------------------------

*************** Inline @[000054] Starting PHASE Indirect call transform

 -- no candidates to transform

*************** Inline @[000054] Finishing PHASE Indirect call transform [no changes]

*************** Inline @[000054] Starting PHASE Expand patchpoints

 -- no patchpoints to transform

*************** Inline @[000054] Finishing PHASE Expand patchpoints [no changes]

*************** Inline @[000054] Starting PHASE Post-import

*************** In fgRemoveEmptyBlocks

*************** Inline @[000054] Finishing PHASE Post-import


----------- Statements (and blocks) added due to the inlining of call [000054] -----------

Arguments setup:

Inlinee method body:fgInlineAppendStatements: no gc ref inline locals.

Return expression for call at [000054] is
               [000084] ---XG-------              *  ADDR      byref 
               [000083] ---XG--N----              \--*  FIELD     ushort _firstChar
               [000053] ------------                 \--*  LCL_VAR   ref    V00 arg0         
Successfully inlined System.String:GetRawStringData():byref:this (7 IL bytes) (depth 2) [below ALWAYS_INLINE size]
--------------------------------------------------------------------------------------------

INLINER: during 'fgInline' result 'success' reason 'below ALWAYS_INLINE size' for 'Accretion.JitDumpVisualizer.CLI.Program:Tokenize(System.String)' calling 'System.String:GetRawStringData():byref:this'
INLINER: during 'fgInline' result 'success' reason 'below ALWAYS_INLINE size'
Expanding INLINE_CANDIDATE in statement STMT00017 in BB09:
STMT00017 (IL 0x006...  ???)
               [000063] I-CXG-------              *  CALL      void   System.ReadOnlySpan`1[Char][System.Char]..ctor (exactContextHnd=0x00000000D1FFAB1E)
               [000062] ------------ this in rcx  +--*  ADDR      byref 
               [000061] -------N----              |  \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V06 tmp5         
               [000055] --C--------- arg1         +--*  RET_EXPR  byref (inl return from call [000084])
               [000057] ---X-------- arg2         \--*  ARR_LENGTH int   
               [000056] ------------                 \--*  LCL_VAR   ref    V00 arg0         
thisArg: is a constant is byref to a struct local
               [000062] ------------              *  ADDR      byref 
               [000061] -------N----              \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V06 tmp5         


Argument #1: has global refs has side effects
               [000084] ---XG-------              *  ADDR      byref 
               [000083] ---XG--N----              \--*  FIELD     ushort _firstChar
               [000053] ------------                 \--*  LCL_VAR   ref    V00 arg0         


Argument #2: has side effects
               [000057] ---X--------              *  ARR_LENGTH int   
               [000056] ------------              \--*  LCL_VAR   ref    V00 arg0         

INLINER: inlineInfo.tokenLookupContextHandle for System.ReadOnlySpan`1[Char][System.Char]:.ctor(byref,int):this set to 0x00000000D1FFAB1E:

Invoking compiler for the inlinee method System.ReadOnlySpan`1[Char][System.Char]:.ctor(byref,int):this :
IL to import:
IL_0000  04                ldarg.2     
IL_0001  16                ldc.i4.0    
IL_0002  fe 04             clt         
IL_0004  16                ldc.i4.0    
IL_0005  fe 01             ceq         
IL_0007  28 74 59 00 06    call         0x6005974
IL_000c  02                ldarg.0     
IL_000d  03                ldarg.1     
IL_000e  73 a7 01 00 0a    newobj       0xA0001A7
IL_0013  7d a8 01 00 0a    stfld        0xA0001A8
IL_0018  02                ldarg.0     
IL_0019  04                ldarg.2     
IL_001a  7d a9 01 00 0a    stfld        0xA0001A9
IL_001f  2a                ret         

INLINER impTokenLookupContextHandle for System.ReadOnlySpan`1[Char][System.Char]:.ctor(byref,int):this is 0x00000000D1FFAB1E.
*************** In fgFindBasicBlocks() for System.ReadOnlySpan`1[Char][System.Char]:.ctor(byref,int):this
Jump targets:
  none
Computing inlinee profile scale:
   ... call site not profiled
New Basic Block BB12 [0011] created.
BB12 [000..020)
Basic block list for 'System.ReadOnlySpan`1[Char][System.Char]:.ctor(byref,int):this'

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB12 [0011]  1                             1        [000..020)        (return)                     
-----------------------------------------------------------------------------------------------------------------------------------------

*************** Inline @[000063] Starting PHASE Pre-import

*************** Inline @[000063] Finishing PHASE Pre-import

*************** Inline @[000063] Starting PHASE Importation
*************** In impImport() for System.ReadOnlySpan`1[Char][System.Char]:.ctor(byref,int):this

impImportBlockPending for BB12

Importing BB12 (PC=000) of 'System.ReadOnlySpan`1[Char][System.Char]:.ctor(byref,int):this'
    [ 0]   0 (0x000) ldarg.2
lvaGrabTemp returning 8 (V08 tmp7) called for Inlining Arg.

    [ 1]   1 (0x001) ldc.i4.0 0
    [ 2]   2 (0x002) clt
    [ 1]   4 (0x004) ldc.i4.0 0
    [ 2]   5 (0x005) ceq
    [ 1]   7 (0x007) call 06005974
In Compiler::impImportCall: opcode is call, kind=0, callRetType is void, structSize is 0


               [000093] I-C-G-------              *  CALL      void   System.Diagnostics.Debug.Assert (exactContextHnd=0x00000000D1FFAB1E)
               [000092] ------------ arg0         \--*  EQ        int   
               [000090] ------------                 +--*  LT        int   
               [000088] ------------                 |  +--*  LCL_VAR   int    V08 tmp7         
               [000089] ------------                 |  \--*  CNS_INT   int    0
               [000091] ------------                 \--*  CNS_INT   int    0

    [ 0]  12 (0x00c) ldarg.0
    [ 1]  13 (0x00d) ldarg.1
lvaGrabTemp returning 9 (V09 tmp8) called for Inlining Arg.

    [ 2]  14 (0x00e) newobj
lvaGrabTemp returning 10 (V10 tmp9) called for NewObj constructor temp.

Suppressing zero-init for V10 -- expect to zero in prolog
 0A0001A7
In Compiler::impImportCall: opcode is newobj, kind=0, callRetType is void, structSize is 0


               [000100] -A----------              *  ASG       byref 
               [000099] -------N----              +--*  FIELD     byref  _value
               [000098] ------------              |  \--*  ADDR      byref 
               [000097] -------N----              |     \--*  LCL_VAR   struct<System.ByReference`1[Char], 8> V10 tmp9         
               [000096] ------------              \--*  LCL_VAR   byref  V09 tmp8         

    [ 2]  19 (0x013) stfld 0A0001A8

               [000105] -A----------              *  ASG       struct (copy)
               [000104] ------------              +--*  OBJ       struct<System.ByReference`1[Char], 8>
               [000103] ------------              |  \--*  ADDR      byref 
               [000102] -------N----              |     \--*  FIELD     struct _pointer
               [000094] ------------              |        \--*  ADDR      byref 
               [000095] -------N----              |           \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V06 tmp5         
               [000101] -------N----              \--*  LCL_VAR   struct<System.ByReference`1[Char], 8> V10 tmp9         

    [ 0]  24 (0x018) ldarg.0
    [ 1]  25 (0x019) ldarg.2
    [ 2]  26 (0x01a) stfld 0A0001A9

               [000110] -A----------              *  ASG       int   
               [000109] -------N----              +--*  FIELD     int    _length
               [000106] ------------              |  \--*  ADDR      byref 
               [000107] -------N----              |     \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V06 tmp5         
               [000108] ------------              \--*  LCL_VAR   int    V08 tmp7         

    [ 0]  31 (0x01f) ret
*************** Inline @[000063] Finishing PHASE Importation
Trees after Importation

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB12 [0011]  1                             1        [000..020)        (return)                     i 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB12 [000..020) (return), preds={} succs={}

***** BB12
               [000093] I-C-G-------              *  CALL      void   System.Diagnostics.Debug.Assert (exactContextHnd=0x00000000D1FFAB1E)
               [000092] ------------ arg0         \--*  EQ        int   
               [000090] ------------                 +--*  LT        int   
               [000088] ------------                 |  +--*  LCL_VAR   int    V08 tmp7         
               [000089] ------------                 |  \--*  CNS_INT   int    0
               [000091] ------------                 \--*  CNS_INT   int    0

***** BB12
               [000100] -A----------              *  ASG       byref 
               [000099] -------N----              +--*  FIELD     byref  _value
               [000098] ------------              |  \--*  ADDR      byref 
               [000097] -------N----              |     \--*  LCL_VAR   struct<System.ByReference`1[Char], 8> V10 tmp9         
               [000096] ------------              \--*  LCL_VAR   byref  V09 tmp8         

***** BB12
               [000105] -A----------              *  ASG       struct (copy)
               [000104] ------------              +--*  OBJ       struct<System.ByReference`1[Char], 8>
               [000103] ------------              |  \--*  ADDR      byref 
               [000102] -------N----              |     \--*  FIELD     struct _pointer
               [000094] ------------              |        \--*  ADDR      byref 
               [000095] -------N----              |           \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V06 tmp5         
               [000101] -------N----              \--*  LCL_VAR   struct<System.ByReference`1[Char], 8> V10 tmp9         

***** BB12
               [000110] -A----------              *  ASG       int   
               [000109] -------N----              +--*  FIELD     int    _length
               [000106] ------------              |  \--*  ADDR      byref 
               [000107] -------N----              |     \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V06 tmp5         
               [000108] ------------              \--*  LCL_VAR   int    V08 tmp7         

-------------------------------------------------------------------------------------------------------------------

*************** Inline @[000063] Starting PHASE Indirect call transform

 -- no candidates to transform

*************** Inline @[000063] Finishing PHASE Indirect call transform [no changes]

*************** Inline @[000063] Starting PHASE Expand patchpoints

 -- no patchpoints to transform

*************** Inline @[000063] Finishing PHASE Expand patchpoints [no changes]

*************** Inline @[000063] Starting PHASE Post-import

*************** In fgRemoveEmptyBlocks

*************** Inline @[000063] Finishing PHASE Post-import


----------- Statements (and blocks) added due to the inlining of call [000063] -----------

Arguments setup:
STMT00026 (IL 0x006...  ???)
               [000112] -A-XG-------              *  ASG       byref 
               [000111] D------N----              +--*  LCL_VAR   byref  V09 tmp8         
               [000084] ---XG-------              \--*  ADDR      byref 
               [000083] ---XG--N----                 \--*  FIELD     ushort _firstChar
               [000053] ------------                    \--*  LCL_VAR   ref    V00 arg0         
STMT00027 (IL 0x006...  ???)
               [000114] -A-X--------              *  ASG       int   
               [000113] D------N----              +--*  LCL_VAR   int    V08 tmp7         
               [000057] ---X--------              \--*  ARR_LENGTH int   
               [000056] ------------                 \--*  LCL_VAR   ref    V00 arg0         

Inlinee method body:
STMT00022 (IL 0x006...  ???)
               [000093] I-C-G-------              *  CALL      void   System.Diagnostics.Debug.Assert (exactContextHnd=0x00000000D1FFAB1E)
               [000092] ------------ arg0         \--*  EQ        int   
               [000090] ------------                 +--*  LT        int   
               [000088] ------------                 |  +--*  LCL_VAR   int    V08 tmp7         
               [000089] ------------                 |  \--*  CNS_INT   int    0
               [000091] ------------                 \--*  CNS_INT   int    0


STMT00023 (IL 0x006...  ???)
               [000100] -A----------              *  ASG       byref 
               [000099] -------N----              +--*  FIELD     byref  _value
               [000098] ------------              |  \--*  ADDR      byref 
               [000097] -------N----              |     \--*  LCL_VAR   struct<System.ByReference`1[Char], 8> V10 tmp9         
               [000096] ------------              \--*  LCL_VAR   byref  V09 tmp8         


STMT00024 (IL 0x006...  ???)
               [000105] -A----------              *  ASG       struct (copy)
               [000104] ------------              +--*  OBJ       struct<System.ByReference`1[Char], 8>
               [000103] ------------              |  \--*  ADDR      byref 
               [000102] -------N----              |     \--*  FIELD     struct _pointer
               [000094] ------------              |        \--*  ADDR      byref 
               [000095] -------N----              |           \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V06 tmp5         
               [000101] -------N----              \--*  LCL_VAR   struct<System.ByReference`1[Char], 8> V10 tmp9         


STMT00025 (IL 0x006...  ???)
               [000110] -A----------              *  ASG       int   
               [000109] -------N----              +--*  FIELD     int    _length
               [000106] ------------              |  \--*  ADDR      byref 
               [000107] -------N----              |     \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V06 tmp5         
               [000108] ------------              \--*  LCL_VAR   int    V08 tmp7         

fgInlineAppendStatements: no gc ref inline locals.
Successfully inlined System.ReadOnlySpan`1[Char][System.Char]:.ctor(byref,int):this (32 IL bytes) (depth 2) [aggressive inline attribute]
--------------------------------------------------------------------------------------------

INLINER: during 'fgInline' result 'success' reason 'aggressive inline attribute' for 'Accretion.JitDumpVisualizer.CLI.Program:Tokenize(System.String)' calling 'System.ReadOnlySpan`1[Char][System.Char]:.ctor(byref,int):this'
INLINER: during 'fgInline' result 'success' reason 'aggressive inline attribute'
Expanding INLINE_CANDIDATE in statement STMT00022 in BB09:
STMT00022 (IL 0x006...  ???)
               [000093] I-C-G-------              *  CALL      void   System.Diagnostics.Debug.Assert (exactContextHnd=0x00000000D1FFAB1E)
               [000092] ------------ arg0         \--*  EQ        int   
               [000090] ------------                 +--*  LT        int   
               [000088] ------------                 |  +--*  LCL_VAR   int    V08 tmp7         
               [000089] ------------                 |  \--*  CNS_INT   int    0
               [000091] ------------                 \--*  CNS_INT   int    0

Argument #0:
               [000092] ------------              *  EQ        int   
               [000090] ------------              +--*  LT        int   
               [000088] ------------              |  +--*  LCL_VAR   int    V08 tmp7         
               [000089] ------------              |  \--*  CNS_INT   int    0
               [000091] ------------              \--*  CNS_INT   int    0

INLINER: inlineInfo.tokenLookupContextHandle for System.Diagnostics.Debug:Assert(bool) set to 0x00000000D1FFAB1E:

Invoking compiler for the inlinee method System.Diagnostics.Debug:Assert(bool) :
IL to import:
IL_0000  02                ldarg.0     
IL_0001  7e 1a 02 00 04    ldsfld       0x400021A
IL_0006  7e 1a 02 00 04    ldsfld       0x400021A
IL_000b  28 76 59 00 06    call         0x6005976
IL_0010  2a                ret         

INLINER impTokenLookupContextHandle for System.Diagnostics.Debug:Assert(bool) is 0x00000000D1FFAB1E.
*************** In fgFindBasicBlocks() for System.Diagnostics.Debug:Assert(bool)
weight= 10 : state   3 [ ldarg.0 ]
weight=159 : state 112 [ ldsfld ]
weight=159 : state 112 [ ldsfld ]
weight= 79 : state  40 [ call ]
weight= 19 : state  42 [ ret ]

Inline candidate looks like a wrapper method.  Multiplier increased to 1.
Inline candidate is mostly loads and stores.  Multiplier increased to 4.
Inline candidate callsite is boring.  Multiplier increased to 5.3.
calleeNativeSizeEstimate=426
callsiteNativeSizeEstimate=85
benefit multiplier=5.3
threshold=450
Native estimate for function size is within threshold for inlining 42.6 <= 45 (multiplier = 5.3)
Jump targets:
  none
Computing inlinee profile scale:
   ... call site not profiled
New Basic Block BB13 [0012] created.
BB13 [000..011)
Basic block list for 'System.Diagnostics.Debug:Assert(bool)'

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB13 [0012]  1                             1        [000..011)        (return)                     
-----------------------------------------------------------------------------------------------------------------------------------------

*************** Inline @[000093] Starting PHASE Pre-import

*************** Inline @[000093] Finishing PHASE Pre-import

*************** Inline @[000093] Starting PHASE Importation
*************** In impImport() for System.Diagnostics.Debug:Assert(bool)

impImportBlockPending for BB13

Importing BB13 (PC=000) of 'System.Diagnostics.Debug:Assert(bool)'
    [ 0]   0 (0x000) ldarg.0
lvaGrabTemp returning 11 (V11 tmp10) called for Inlining Arg.

    [ 1]   1 (0x001) ldsfld 0400021A
    [ 2]   6 (0x006) ldsfld 0400021A
    [ 3]  11 (0x00b) call 06005976
In Compiler::impImportCall: opcode is call, kind=0, callRetType is void, structSize is 0


               [000122] I-C-G-------              *  CALL      void   System.Diagnostics.Debug.Assert (exactContextHnd=0x00000000D1FFAB1E)
               [000117] ------------ arg0         +--*  LCL_VAR   int    V11 tmp10        
               [000119] #---G------- arg1         +--*  IND       ref   
               [000118] H-----------              |  \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]
               [000121] #---G------- arg2         \--*  IND       ref   
               [000120] H-----------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]

    [ 0]  16 (0x010) ret
*************** Inline @[000093] Finishing PHASE Importation
Trees after Importation

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB13 [0012]  1                             1        [000..011)        (return)                     i 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB13 [000..011) (return), preds={} succs={}

***** BB13
               [000122] I-C-G-------              *  CALL      void   System.Diagnostics.Debug.Assert (exactContextHnd=0x00000000D1FFAB1E)
               [000117] ------------ arg0         +--*  LCL_VAR   int    V11 tmp10        
               [000119] #---G------- arg1         +--*  IND       ref   
               [000118] H-----------              |  \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]
               [000121] #---G------- arg2         \--*  IND       ref   
               [000120] H-----------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]

-------------------------------------------------------------------------------------------------------------------

*************** Inline @[000093] Starting PHASE Indirect call transform

 -- no candidates to transform

*************** Inline @[000093] Finishing PHASE Indirect call transform [no changes]

*************** Inline @[000093] Starting PHASE Expand patchpoints

 -- no patchpoints to transform

*************** Inline @[000093] Finishing PHASE Expand patchpoints [no changes]

*************** Inline @[000093] Starting PHASE Post-import

*************** In fgRemoveEmptyBlocks

*************** Inline @[000093] Finishing PHASE Post-import


----------- Statements (and blocks) added due to the inlining of call [000093] -----------

Arguments setup:

Inlinee method body:
STMT00028 (IL 0x006...  ???)
               [000122] I-C-G-------              *  CALL      void   System.Diagnostics.Debug.Assert (exactContextHnd=0x00000000D1FFAB1E)
               [000116] ------------ arg0         +--*  CAST      int <- bool <- int
               [000092] ------------              |  \--*  EQ        int   
               [000090] ------------              |     +--*  LT        int   
               [000088] ------------              |     |  +--*  LCL_VAR   int    V08 tmp7         
               [000089] ------------              |     |  \--*  CNS_INT   int    0
               [000091] ------------              |     \--*  CNS_INT   int    0
               [000119] #---G------- arg1         +--*  IND       ref   
               [000118] H-----------              |  \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]
               [000121] #---G------- arg2         \--*  IND       ref   
               [000120] H-----------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]

fgInlineAppendStatements: no gc ref inline locals.
Successfully inlined System.Diagnostics.Debug:Assert(bool) (17 IL bytes) (depth 3) [profitable inline]
--------------------------------------------------------------------------------------------

INLINER: during 'fgInline' result 'success' reason 'profitable inline' for 'Accretion.JitDumpVisualizer.CLI.Program:Tokenize(System.String)' calling 'System.Diagnostics.Debug:Assert(bool)'
INLINER: during 'fgInline' result 'success' reason 'profitable inline'
Expanding INLINE_CANDIDATE in statement STMT00028 in BB09:
STMT00028 (IL 0x006...  ???)
               [000122] I-C-G-------              *  CALL      void   System.Diagnostics.Debug.Assert (exactContextHnd=0x00000000D1FFAB1E)
               [000116] ------------ arg0         +--*  CAST      int <- bool <- int
               [000092] ------------              |  \--*  EQ        int   
               [000090] ------------              |     +--*  LT        int   
               [000088] ------------              |     |  +--*  LCL_VAR   int    V08 tmp7         
               [000089] ------------              |     |  \--*  CNS_INT   int    0
               [000091] ------------              |     \--*  CNS_INT   int    0
               [000119] #---G------- arg1         +--*  IND       ref   
               [000118] H-----------              |  \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]
               [000121] #---G------- arg2         \--*  IND       ref   
               [000120] H-----------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]

Argument #0:
               [000116] ------------              *  CAST      int <- bool <- int
               [000092] ------------              \--*  EQ        int   
               [000090] ------------                 +--*  LT        int   
               [000088] ------------                 |  +--*  LCL_VAR   int    V08 tmp7         
               [000089] ------------                 |  \--*  CNS_INT   int    0
               [000091] ------------                 \--*  CNS_INT   int    0


Argument #1: has global refs
               [000119] #---G-------              *  IND       ref   
               [000118] H-----------              \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]


Argument #2: has global refs
               [000121] #---G-------              *  IND       ref   
               [000120] H-----------              \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]

INLINER: inlineInfo.tokenLookupContextHandle for System.Diagnostics.Debug:Assert(bool,System.String,System.String) set to 0x00000000D1FFAB1E:

Invoking compiler for the inlinee method System.Diagnostics.Debug:Assert(bool,System.String,System.String) :
IL to import:
IL_0000  02                ldarg.0     
IL_0001  2d 07             brtrue.s     7 (IL_000a)
IL_0003  03                ldarg.1     
IL_0004  04                ldarg.2     
IL_0005  28 79 59 00 06    call         0x6005979
IL_000a  2a                ret         

INLINER impTokenLookupContextHandle for System.Diagnostics.Debug:Assert(bool,System.String,System.String) is 0x00000000D1FFAB1E.
*************** In fgFindBasicBlocks() for System.Diagnostics.Debug:Assert(bool,System.String,System.String)
Jump targets:
  IL_000a
Computing inlinee profile scale:
   ... call site not profiled
New Basic Block BB14 [0013] created.
BB14 [000..003)
New Basic Block BB15 [0014] created.
BB15 [003..00A)
New Basic Block BB16 [0015] created.
BB16 [00A..00B)
Basic block list for 'System.Diagnostics.Debug:Assert(bool,System.String,System.String)'

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB14 [0013]  1                             1        [000..003)-> BB16 ( cond )                     
BB15 [0014]  1                             1        [003..00A)                                     
BB16 [0015]  2                             1        [00A..00B)        (return)                     
-----------------------------------------------------------------------------------------------------------------------------------------

*************** Inline @[000122] Starting PHASE Pre-import

*************** Inline @[000122] Finishing PHASE Pre-import

*************** Inline @[000122] Starting PHASE Importation
*************** In impImport() for System.Diagnostics.Debug:Assert(bool,System.String,System.String)

impImportBlockPending for BB14

Importing BB14 (PC=000) of 'System.Diagnostics.Debug:Assert(bool,System.String,System.String)'
    [ 0]   0 (0x000) ldarg.0
lvaGrabTemp returning 12 (V12 tmp11) called for Inlining Arg.

    [ 1]   1 (0x001) brtrue.s

               [000128] ------------              *  JTRUE     void  
               [000127] ------------              \--*  NE        int   
               [000125] ------------                 +--*  LCL_VAR   int    V12 tmp11        
               [000126] ------------                 \--*  CNS_INT   int    0

impImportBlockPending for BB15

impImportBlockPending for BB16

Importing BB16 (PC=010) of 'System.Diagnostics.Debug:Assert(bool,System.String,System.String)'
    [ 0]  10 (0x00a) ret
Importing BB15 (PC=003) of 'System.Diagnostics.Debug:Assert(bool,System.String,System.String)'
    [ 0]   3 (0x003) ldarg.1
lvaGrabTemp returning 13 (V13 tmp12) called for Inlining Arg.
Marked V13 as a single def temp

lvaSetClass: setting class for V13 to (00000000D1FFAB1E) System.String 

    [ 1]   4 (0x004) ldarg.2
lvaGrabTemp returning 14 (V14 tmp13) called for Inlining Arg.
Marked V14 as a single def temp

lvaSetClass: setting class for V14 to (00000000D1FFAB1E) System.String 

    [ 2]   5 (0x005) call 06005979
In Compiler::impImportCall: opcode is call, kind=0, callRetType is void, structSize is 0
INLINER: during 'impMarkInlineCandidate' result 'failed this callee' reason 'noinline per IL/cached result' for 'System.Diagnostics.Debug:Assert(bool,System.String,System.String)' calling 'System.Diagnostics.Debug:Fail(System.String,System.String)'
INLINER: during 'impMarkInlineCandidate' result 'failed this callee' reason 'noinline per IL/cached result'


               [000131] --C-G-------              *  CALL      void   System.Diagnostics.Debug.Fail
               [000129] ------------ arg0         +--*  LCL_VAR   ref    V13 tmp12        
               [000130] ------------ arg1         \--*  LCL_VAR   ref    V14 tmp13        

impImportBlockPending for BB16

** Note: inlinee IL was partially imported -- imported 10 of 11 bytes of method IL

*************** Inline @[000122] Finishing PHASE Importation
Trees after Importation

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB14 [0013]  1                             1        [000..003)-> BB16 ( cond )                     i 
BB15 [0014]  1                             1        [003..00A)                                     i 
BB16 [0015]  2                             1        [00A..00B)        (return)                     i 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB14 [000..003) -> BB16 (cond), preds={} succs={BB15,BB16}

***** BB14
               [000128] ------------              *  JTRUE     void  
               [000127] ------------              \--*  NE        int   
               [000125] ------------                 +--*  LCL_VAR   int    V12 tmp11        
               [000126] ------------                 \--*  CNS_INT   int    0

------------ BB15 [003..00A), preds={} succs={BB16}

***** BB15
               [000131] --C-G-------              *  CALL      void   System.Diagnostics.Debug.Fail
               [000129] ------------ arg0         +--*  LCL_VAR   ref    V13 tmp12        
               [000130] ------------ arg1         \--*  LCL_VAR   ref    V14 tmp13        

------------ BB16 [00A..00B) (return), preds={} succs={}

-------------------------------------------------------------------------------------------------------------------

*************** Inline @[000122] Starting PHASE Indirect call transform

 -- no candidates to transform

*************** Inline @[000122] Finishing PHASE Indirect call transform [no changes]

*************** Inline @[000122] Starting PHASE Expand patchpoints

 -- no patchpoints to transform

*************** Inline @[000122] Finishing PHASE Expand patchpoints [no changes]

*************** Inline @[000122] Starting PHASE Post-import

*************** In fgRemoveEmptyBlocks

*************** Inline @[000122] Finishing PHASE Post-import


----------- Statements (and blocks) added due to the inlining of call [000122] -----------

Arguments setup:
STMT00031 (IL 0x006...  ???)
               [000133] -A--G-------              *  ASG       ref   
               [000132] D------N----              +--*  LCL_VAR   ref    V13 tmp12        
               [000119] #---G-------              \--*  IND       ref   
               [000118] H-----------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]
STMT00032 (IL 0x006...  ???)
               [000135] -A--G-------              *  ASG       ref   
               [000134] D------N----              +--*  LCL_VAR   ref    V14 tmp13        
               [000121] #---G-------              \--*  IND       ref   
               [000120] H-----------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]

Inlinee method body:New Basic Block BB17 [0016] created.

Convert bbJumpKind of BB16 to BBJ_NONE
fgInlineAppendStatements: no gc ref inline locals.

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB14 [0013]  1                             1        [006..007)-> BB16 ( cond )                     i 
BB15 [0014]  1                             0.50     [006..007)                                     i 
BB16 [0015]  2                             1        [006..007)                                     i 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB14 [006..007) -> BB16 (cond), preds={} succs={BB15,BB16}

***** BB14
STMT00029 (IL 0x006...  ???)
               [000128] ------------              *  JTRUE     void  
               [000127] ------------              \--*  NE        int   
               [000124] ------------                 +--*  CAST      int <- bool <- int
               [000116] ------------                 |  \--*  CAST      int <- bool <- int
               [000092] ------------                 |     \--*  EQ        int   
               [000090] ------------                 |        +--*  LT        int   
               [000088] ------------                 |        |  +--*  LCL_VAR   int    V08 tmp7         
               [000089] ------------                 |        |  \--*  CNS_INT   int    0
               [000091] ------------                 |        \--*  CNS_INT   int    0
               [000126] ------------                 \--*  CNS_INT   int    0

------------ BB15 [006..007), preds={} succs={BB16}

***** BB15
STMT00030 (IL 0x006...  ???)
               [000131] --C-G-------              *  CALL      void   System.Diagnostics.Debug.Fail
               [000129] ------------ arg0         +--*  LCL_VAR   ref    V13 tmp12        
               [000130] ------------ arg1         \--*  LCL_VAR   ref    V14 tmp13        

------------ BB16 [006..007), preds={} succs={BB17}

-------------------------------------------------------------------------------------------------------------------
Successfully inlined System.Diagnostics.Debug:Assert(bool,System.String,System.String) (11 IL bytes) (depth 4) [below ALWAYS_INLINE size]
--------------------------------------------------------------------------------------------

INLINER: during 'fgInline' result 'success' reason 'below ALWAYS_INLINE size' for 'Accretion.JitDumpVisualizer.CLI.Program:Tokenize(System.String)' calling 'System.Diagnostics.Debug:Assert(bool,System.String,System.String)'
INLINER: during 'fgInline' result 'success' reason 'below ALWAYS_INLINE size'

Replacing the return expression placeholder [000010] with [000071]
               [000010] --C---------              *  RET_EXPR  void  (inl return from call [000071])

Inserting the inline return expression
               [000071] -A----------              *  ASG       struct (copy)
               [000069] D------N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V03 tmp2         
               [000070] ------------              \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V05 tmp4         

Expanding INLINE_CANDIDATE in statement STMT00004 in BB10:
STMT00004 (IL   ???...  ???)
               [000011] I-C-G-------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer.TokenizeLine (exactContextHnd=0x00000000D1FFAB1E)
               [000007] ------------ this in rcx  +--*  LCL_VAR   ref    V02 tmp1         
               [000016] n----------- arg1         \--*  OBJ       struct<System.ReadOnlySpan`1[Char], 16>
               [000015] ------------                 \--*  ADDR      byref 
               [000014] -------N----                    \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V03 tmp2         
Note: candidate is implicit tail call
thisArg: is a local var
               [000007] ------------              *  LCL_VAR   ref    V02 tmp1         


Argument #1:
               [000016] n-----------              *  OBJ       struct<System.ReadOnlySpan`1[Char], 16>
               [000015] ------------              \--*  ADDR      byref 
               [000014] -------N----                 \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V03 tmp2         

INLINER: inlineInfo.tokenLookupContextHandle for Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer:TokenizeLine(System.ReadOnlySpan`1[Char]):this set to 0x00000000D1FFAB1E:

Invoking compiler for the inlinee method Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer:TokenizeLine(System.ReadOnlySpan`1[Char]):this :
IL to import:
IL_0000  03                ldarg.1     
IL_0001  28 17 00 00 06    call         0x6000017
IL_0006  0b                stloc.1     
IL_0007  12 01             ldloca.s     0x1
IL_0009  28 19 00 00 06    call         0x6000019
IL_000e  0a                stloc.0     
IL_000f  2b 30             br.s         48 (IL_0041)
IL_0011  12 00             ldloca.s     0x0
IL_0013  28 1c 00 00 06    call         0x600001C
IL_0018  0c                stloc.2     
IL_0019  2b 1d             br.s         29 (IL_0038)
IL_001b  08                ldloc.2     
IL_001c  28 13 00 00 06    call         0x6000013
IL_0021  0d                stloc.3     
IL_0022  02                ldarg.0     
IL_0023  09                ldloc.3     
IL_0024  28 12 00 00 06    call         0x6000012
IL_0029  12 02             ldloca.s     0x2
IL_002b  12 03             ldloca.s     0x3
IL_002d  28 09 00 00 06    call         0x6000009
IL_0032  28 1e 00 00 0a    call         0xA00001E
IL_0037  0c                stloc.2     
IL_0038  12 02             ldloca.s     0x2
IL_003a  28 1f 00 00 0a    call         0xA00001F
IL_003f  2c da             brfalse.s    -38 (IL_001b)
IL_0041  12 00             ldloca.s     0x0
IL_0043  28 1b 00 00 06    call         0x600001B
IL_0048  2d c7             brtrue.s     -57 (IL_0011)
IL_004a  2a                ret         

INLINER impTokenLookupContextHandle for Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer:TokenizeLine(System.ReadOnlySpan`1[Char]):this is 0x00000000D1FFAB1E.
*************** In fgFindBasicBlocks() for Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer:TokenizeLine(System.ReadOnlySpan`1[Char]):this
weight= 16 : state   4 [ ldarg.1 ]
weight= 79 : state  40 [ call ]
weight= 34 : state  12 [ stloc.1 ]
weight= 61 : state  19 [ ldloca.s ]
weight= 79 : state  40 [ call ]
weight=  6 : state  11 [ stloc.0 ]
weight= 44 : state  43 [ br.s ]
weight= 61 : state  19 [ ldloca.s ]
weight= 79 : state  40 [ call ]
weight=  4 : state  13 [ stloc.2 ]
weight= 44 : state  43 [ br.s ]
weight= 22 : state   9 [ ldloc.2 ]
weight= 79 : state  40 [ call ]
weight= 49 : state  14 [ stloc.3 ]
weight= 10 : state   3 [ ldarg.0 ]
weight= 24 : state  10 [ ldloc.3 ]
weight= 79 : state  40 [ call ]
weight= 61 : state  19 [ ldloca.s ]
weight= 61 : state  19 [ ldloca.s ]
weight= 79 : state  40 [ call ]
weight= 79 : state  40 [ call ]
weight=  4 : state  13 [ stloc.2 ]
weight= 61 : state  19 [ ldloca.s ]
weight= 79 : state  40 [ call ]
weight= 27 : state  44 [ brfalse.s ]
weight= 61 : state  19 [ ldloca.s ]
weight= 79 : state  40 [ call ]
weight= 25 : state  45 [ brtrue.s ]
weight= 19 : state  42 [ ret ]

Inline candidate has an arg that feeds a constant test.  Multiplier increased to 1.
Inline candidate callsite is boring.  Multiplier increased to 2.3.
calleeNativeSizeEstimate=1405
callsiteNativeSizeEstimate=135
benefit multiplier=2.3
threshold=310
Native estimate for function size exceeds threshold for inlining 140.5 > 31 (multiplier = 2.3)


Inline expansion aborted, inline not profitable
INLINER: during 'fgInline' result 'failed this call site' reason 'unprofitable inline' for 'Accretion.JitDumpVisualizer.CLI.Program:Tokenize(System.String)' calling 'Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer:TokenizeLine(System.ReadOnlySpan`1[Char]):this'
INLINER: during 'fgInline' result 'failed this call site' reason 'unprofitable inline'
**************** Inline Tree
Inlines into 06000002 [via DefaultPolicy] Accretion.JitDumpVisualizer.CLI.Program:Tokenize(System.String)
  [1 IL=0001 TR=000006 0600000D] [profitable inline] Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer:.ctor(System.IO.StreamReader):this
    [2 IL=0001 TR=000023 0600009D] [profitable inline] System.Collections.Generic.Queue`1[Token][Accretion.JitDumpVisualizer.Parsing.Tokens.Token]:.ctor():this
      [3 IL=0001 TR=000034 0600049E] [below ALWAYS_INLINE size] System.Object:.ctor():this
      [4 IL=0007 TR=000036 06000146] [below ALWAYS_INLINE size] System.Array:Empty():Accretion.JitDumpVisualizer.Parsing.Tokens.Token[]
    [5 IL=0012 TR=000028 0600049E] [below ALWAYS_INLINE size] System.Object:.ctor():this
  [6 IL=0007 TR=000009 060006DD] [aggressive inline attribute] System.String:op_Implicit(System.String):System.ReadOnlySpan`1[Char]
    [7 IL=0014 TR=000054 060006E7] [below ALWAYS_INLINE size] System.String:GetRawStringData():byref:this
    [8 IL=0025 TR=000063 060012DA] [aggressive inline attribute] System.ReadOnlySpan`1[Char][System.Char]:.ctor(byref,int):this
      [9 IL=0007 TR=000093 06005974] [profitable inline] System.Diagnostics.Debug:Assert(bool)
        [10 IL=0011 TR=000122 06005976] [below ALWAYS_INLINE size] System.Diagnostics.Debug:Assert(bool,System.String,System.String)
          [0 IL=0005 TR=000131 06005979] [FAILED: noinline per IL/cached result] System.Diagnostics.Debug:Fail(System.String,System.String)
  [0 IL=0012 TR=000011 06000011] [FAILED: unprofitable inline] Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer:TokenizeLine(System.ReadOnlySpan`1[Char]):this
Budget: initialTime=114, finalTime=240, initialBudget=1140, currentBudget=1238
Budget: increased by 98 because of force inlines
Budget: initialSize=541, finalSize=1355

*************** Finishing PHASE Morph - Inlining
Trees after Morph - Inlining

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)                                     i newobj 
BB07 [0006]  1                             1        [006..007)-> BB09 ( cond )                     i 
BB08 [0007]  1                             1        [006..007)-> BB10 (always)                     i 
BB09 [0008]  1                             1        [006..007)                                     i idxlen nullcheck 
BB14 [0013]  1                             1        [006..007)-> BB16 ( cond )                     i 
BB15 [0014]  1                             0.50     [006..007)                                     i 
BB16 [0015]  2                             1        [006..007)                                     i 
BB17 [0016]  1                             1        [???..???)                                     internal idxlen nullcheck 
BB10 [0009]  1                             1        [???..???)        (return)                     internal newobj 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..012), preds={} succs={BB07}

***** BB01
STMT00000 (IL 0x000...0x011)
               [000004] -A----------              *  ASG       ref   
               [000003] D------N----              +--*  LCL_VAR   ref    V02 tmp1         
               [000002] ------------              \--*  ALLOCOBJ  ref   
               [000001] H-----------                 \--*  CNS_INT(h) long   0xd1ffab1e token

***** BB01
STMT00006 (IL   ???...  ???)
               [000021] -A----------              *  ASG       ref   
               [000020] D------N----              +--*  LCL_VAR   ref    V04 tmp3         
               [000019] ------------              \--*  ALLOCOBJ  ref   
               [000018] H-----------                 \--*  CNS_INT(h) long   0xd1ffab1e token

***** BB01
STMT00013 (IL   ???...  ???)
               [000039] -ACXG-------              *  ASG       ref   
               [000038] ---XG--N----              +--*  FIELD     ref    _array
               [000035] ------------              |  \--*  LCL_VAR   ref    V04 tmp3         
               [000047] --CXG-------              \--*  COMMA     ref   
               [000046] H-CXG-------                 +--*  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS
               [000044] ------------ arg0            |  +--*  CNS_INT   long   0x7ffa40fb0028
               [000045] ------------ arg1            |  \--*  CNS_INT   int    6
               [000042] ----G-------                 \--*  FIELD     ref    Value

***** BB01
STMT00008 (IL   ???...  ???)
               [000026] -A-XG-------              *  ASG       ref   
               [000025] ---XG--N----              +--*  FIELD     ref    _tokensBuffer
               [000005] ------------              |  \--*  LCL_VAR   ref    V02 tmp1         
               [000024] ------------              \--*  LCL_VAR   ref    V04 tmp3         

***** BB01
STMT00010 (IL   ???...  ???)
               [000032] -A-XG-------              *  ASG       ref   
               [000031] ---XG--N----              +--*  FIELD     ref    _reader
               [000029] ------------              |  \--*  LCL_VAR   ref    V02 tmp1         
               [000030] ------------              \--*  CNS_INT   ref    null

------------ BB07 [006..007) -> BB09 (cond), preds={} succs={BB08,BB09}

***** BB07
STMT00014 (IL 0x006...  ???)
               [000052] ------------              *  JTRUE     void  
               [000051] ------------              \--*  NE        int   
               [000008] ------------                 +--*  LCL_VAR   ref    V00 arg0         
               [000050] ------------                 \--*  CNS_INT   ref    null

------------ BB08 [006..007) -> BB10 (always), preds={} succs={BB10}

***** BB08
STMT00019 (IL 0x006...  ???)
               [000075] IA----------              *  ASG       struct (init)
               [000072] D------N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V07 tmp6         
               [000074] ------------              \--*  CNS_INT   int    0

***** BB08
STMT00020 (IL 0x006...  ???)
               [000079] -A----------              *  ASG       struct (copy)
               [000077] D------N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V05 tmp4         
               [000076] ------------              \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V07 tmp6         

------------ BB09 [006..007), preds={} succs={BB14}

***** BB09
STMT00021 (IL 0x006...  ???)
               [000086] ---X--------              *  NULLCHECK byte  
               [000085] ------------              \--*  LCL_VAR   ref    V00 arg0         

***** BB09
STMT00016 (IL 0x006...  ???)
               [000060] IA----------              *  ASG       struct (init)
               [000058] D------N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V06 tmp5         
               [000059] ------------              \--*  CNS_INT   int    0

***** BB09
STMT00026 (IL 0x006...  ???)
               [000112] -A-XG-------              *  ASG       byref 
               [000111] D------N----              +--*  LCL_VAR   byref  V09 tmp8         
               [000084] ---XG-------              \--*  ADDR      byref 
               [000083] ---XG--N----                 \--*  FIELD     ushort _firstChar
               [000053] ------------                    \--*  LCL_VAR   ref    V00 arg0         

***** BB09
STMT00027 (IL 0x006...  ???)
               [000114] -A-X--------              *  ASG       int   
               [000113] D------N----              +--*  LCL_VAR   int    V08 tmp7         
               [000057] ---X--------              \--*  ARR_LENGTH int   
               [000056] ------------                 \--*  LCL_VAR   ref    V00 arg0         

***** BB09
STMT00031 (IL 0x006...  ???)
               [000133] -A--G-------              *  ASG       ref   
               [000132] D------N----              +--*  LCL_VAR   ref    V13 tmp12        
               [000119] #---G-------              \--*  IND       ref   
               [000118] H-----------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]

***** BB09
STMT00032 (IL 0x006...  ???)
               [000135] -A--G-------              *  ASG       ref   
               [000134] D------N----              +--*  LCL_VAR   ref    V14 tmp13        
               [000121] #---G-------              \--*  IND       ref   
               [000120] H-----------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]

------------ BB14 [006..007) -> BB16 (cond), preds={} succs={BB15,BB16}

***** BB14
STMT00029 (IL 0x006...  ???)
               [000128] ------------              *  JTRUE     void  
               [000127] ------------              \--*  NE        int   
               [000124] ------------                 +--*  CAST      int <- bool <- int
               [000116] ------------                 |  \--*  CAST      int <- bool <- int
               [000092] ------------                 |     \--*  EQ        int   
               [000090] ------------                 |        +--*  LT        int   
               [000088] ------------                 |        |  +--*  LCL_VAR   int    V08 tmp7         
               [000089] ------------                 |        |  \--*  CNS_INT   int    0
               [000091] ------------                 |        \--*  CNS_INT   int    0
               [000126] ------------                 \--*  CNS_INT   int    0

------------ BB15 [006..007), preds={} succs={BB16}

***** BB15
STMT00030 (IL 0x006...  ???)
               [000131] --C-G-------              *  CALL      void   System.Diagnostics.Debug.Fail
               [000129] ------------ arg0         +--*  LCL_VAR   ref    V13 tmp12        
               [000130] ------------ arg1         \--*  LCL_VAR   ref    V14 tmp13        

------------ BB16 [006..007), preds={} succs={BB17}

------------ BB17 [???..???), preds={} succs={BB10}

***** BB17
STMT00023 (IL 0x006...  ???)
               [000100] -A----------              *  ASG       byref 
               [000099] -------N----              +--*  FIELD     byref  _value
               [000098] ------------              |  \--*  ADDR      byref 
               [000097] -------N----              |     \--*  LCL_VAR   struct<System.ByReference`1[Char], 8> V10 tmp9         
               [000096] ------------              \--*  LCL_VAR   byref  V09 tmp8         

***** BB17
STMT00024 (IL 0x006...  ???)
               [000105] -A----------              *  ASG       struct (copy)
               [000104] ------------              +--*  OBJ       struct<System.ByReference`1[Char], 8>
               [000103] ------------              |  \--*  ADDR      byref 
               [000102] -------N----              |     \--*  FIELD     struct _pointer
               [000094] ------------              |        \--*  ADDR      byref 
               [000095] -------N----              |           \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V06 tmp5         
               [000101] -------N----              \--*  LCL_VAR   struct<System.ByReference`1[Char], 8> V10 tmp9         

***** BB17
STMT00025 (IL 0x006...  ???)
               [000110] -A----------              *  ASG       int   
               [000109] -------N----              +--*  FIELD     int    _length
               [000106] ------------              |  \--*  ADDR      byref 
               [000107] -------N----              |     \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V06 tmp5         
               [000108] ------------              \--*  LCL_VAR   int    V08 tmp7         

***** BB17
STMT00018 (IL 0x006...  ???)
               [000067] -A----------              *  ASG       struct (copy)
               [000065] D------N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V05 tmp4         
               [000064] ------------              \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V06 tmp5         

------------ BB10 [???..???) (return), preds={} succs={}

***** BB10
STMT00003 (IL   ???...  ???)
               [000071] -A----------              *  ASG       struct (copy)
               [000069] D------N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V03 tmp2         
               [000070] ------------              \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V05 tmp4         

***** BB10
STMT00004 (IL   ???...  ???)
               [000011] --C-G-------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer.TokenizeLine
               [000007] ------------ this in rcx  +--*  LCL_VAR   ref    V02 tmp1         
               [000016] n----------- arg1         \--*  OBJ       struct<System.ReadOnlySpan`1[Char], 16>
               [000015] ------------                 \--*  ADDR      byref 
               [000014] -------N----                    \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V03 tmp2         

***** BB10
STMT00005 (IL 0x011...  ???)
               [000017] ------------              *  RETURN    void  

-------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Allocate Objects
disabled, punting

*************** Finishing PHASE Allocate Objects [no changes]

*************** Starting PHASE Morph - Add internal blocks

*************** After fgAddInternal()

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)                                     i newobj 
BB07 [0006]  1                             1        [006..007)-> BB09 ( cond )                     i 
BB08 [0007]  1                             1        [006..007)-> BB10 (always)                     i 
BB09 [0008]  1                             1        [006..007)                                     i idxlen nullcheck 
BB14 [0013]  1                             1        [006..007)-> BB16 ( cond )                     i 
BB15 [0014]  1                             0.50     [006..007)                                     i 
BB16 [0015]  2                             1        [006..007)                                     i 
BB17 [0016]  1                             1        [???..???)                                     internal idxlen nullcheck 
BB10 [0009]  1                             1        [???..???)        (return)                     internal newobj 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table is empty

*************** Finishing PHASE Morph - Add internal blocks

*************** Starting PHASE Remove empty try

*************** In fgRemoveEmptyTry()
No EH in this method, nothing to remove.

*************** Finishing PHASE Remove empty try [no changes]

*************** Starting PHASE Remove empty finally
No EH in this method, nothing to remove.

*************** Finishing PHASE Remove empty finally [no changes]

*************** Starting PHASE Merge callfinally chains
No EH in this method, nothing to merge.

*************** Finishing PHASE Merge callfinally chains [no changes]

*************** Starting PHASE Clone finally
No EH in this method, no cloning.

*************** Finishing PHASE Clone finally [no changes]

*************** Starting PHASE Compute preds

Renumbering the basic blocks for fgComputePred

*************** Before renumbering the basic blocks

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)                                     i newobj 
BB07 [0006]  1                             1        [006..007)-> BB09 ( cond )                     i 
BB08 [0007]  1                             1        [006..007)-> BB10 (always)                     i 
BB09 [0008]  1                             1        [006..007)                                     i idxlen nullcheck 
BB14 [0013]  1                             1        [006..007)-> BB16 ( cond )                     i 
BB15 [0014]  1                             0.50     [006..007)                                     i 
BB16 [0015]  2                             1        [006..007)                                     i 
BB17 [0016]  1                             1        [???..???)                                     internal idxlen nullcheck 
BB10 [0009]  1                             1        [???..???)        (return)                     internal newobj 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table is empty
Renumber BB07 to BB02
Renumber BB08 to BB03
Renumber BB09 to BB04
Renumber BB14 to BB05
Renumber BB15 to BB06
Renumber BB16 to BB07
Renumber BB17 to BB08
Renumber BB10 to BB09

*************** After renumbering the basic blocks

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)                                     i newobj 
BB02 [0006]  1                             1        [006..007)-> BB04 ( cond )                     i 
BB03 [0007]  1                             1        [006..007)-> BB09 (always)                     i 
BB04 [0008]  1                             1        [006..007)                                     i idxlen nullcheck 
BB05 [0013]  1                             1        [006..007)-> BB07 ( cond )                     i 
BB06 [0014]  1                             0.50     [006..007)                                     i 
BB07 [0015]  2                             1        [006..007)                                     i 
BB08 [0016]  1                             1        [???..???)                                     internal idxlen nullcheck 
BB09 [0009]  1                             1        [???..???)        (return)                     internal newobj 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table is empty

New BlockSet epoch 2, # of blocks (including unused BB00): 10, bitset array size: 1 (short)

*************** In fgComputePreds()

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)                                     i newobj 
BB02 [0006]  1                             1        [006..007)-> BB04 ( cond )                     i 
BB03 [0007]  1                             1        [006..007)-> BB09 (always)                     i 
BB04 [0008]  1                             1        [006..007)                                     i idxlen nullcheck 
BB05 [0013]  1                             1        [006..007)-> BB07 ( cond )                     i 
BB06 [0014]  1                             0.50     [006..007)                                     i 
BB07 [0015]  2                             1        [006..007)                                     i 
BB08 [0016]  1                             1        [???..???)                                     internal idxlen nullcheck 
BB09 [0009]  1                             1        [???..???)        (return)                     internal newobj 
-----------------------------------------------------------------------------------------------------------------------------------------


*************** After fgComputePreds()

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)                                     i label target newobj 
BB02 [0006]  1       BB01                  1        [006..007)-> BB04 ( cond )                     i 
BB03 [0007]  1       BB02                  1        [006..007)-> BB09 (always)                     i 
BB04 [0008]  1       BB02                  1        [006..007)                                     i label target idxlen nullcheck 
BB05 [0013]  1       BB04                  1        [006..007)-> BB07 ( cond )                     i 
BB06 [0014]  1       BB05                  0.50     [006..007)                                     i 
BB07 [0015]  2       BB05,BB06             1        [006..007)                                     i label target 
BB08 [0016]  1       BB07                  1        [???..???)                                     internal idxlen nullcheck 
BB09 [0009]  2       BB03,BB08             1        [???..???)        (return)                     internal label target newobj 
-----------------------------------------------------------------------------------------------------------------------------------------


*************** Finishing PHASE Compute preds

*************** Starting PHASE Merge throw blocks

*************** In fgTailMergeThrows
Method does not have multiple noreturn calls.

*************** Finishing PHASE Merge throw blocks [no changes]

*************** Starting PHASE Update flow graph early pass

*************** In fgUpdateFlowGraph()
Before updating the flow graph:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)                                     i label target newobj 
BB02 [0006]  1       BB01                  1        [006..007)-> BB04 ( cond )                     i 
BB03 [0007]  1       BB02                  1        [006..007)-> BB09 (always)                     i 
BB04 [0008]  1       BB02                  1        [006..007)                                     i label target idxlen nullcheck 
BB05 [0013]  1       BB04                  1        [006..007)-> BB07 ( cond )                     i 
BB06 [0014]  1       BB05                  0.50     [006..007)                                     i 
BB07 [0015]  2       BB05,BB06             1        [006..007)                                     i label target 
BB08 [0016]  1       BB07                  1        [???..???)                                     internal idxlen nullcheck 
BB09 [0009]  2       BB03,BB08             1        [???..???)        (return)                     internal label target newobj 
-----------------------------------------------------------------------------------------------------------------------------------------


Compacting blocks BB01 and BB02:
*************** In fgDebugCheckBBlist

Compacting blocks BB04 and BB05:
*************** In fgDebugCheckBBlist

Compacting blocks BB07 and BB08:
*************** In fgDebugCheckBBlist

After updating the flow graph:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)-> BB04 ( cond )                     i label target newobj 
BB03 [0007]  1       BB01                  1        [006..007)-> BB09 (always)                     i 
BB04 [0008]  1       BB01                  1        [006..007)-> BB07 ( cond )                     i label target idxlen nullcheck 
BB06 [0014]  1       BB04                  0.50     [006..007)                                     i 
BB07 [0015]  2       BB04,BB06             1        [006..007)                                     i label target idxlen nullcheck 
BB09 [0009]  2       BB03,BB07             1        [???..???)        (return)                     internal label target newobj 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table is empty
*************** In fgDebugCheckBBlist

*************** Finishing PHASE Update flow graph early pass

*************** Starting PHASE Morph - Promote Structs

*************** In fgResetImplicitByRefRefCount()
*************** In fgPromoteStructs()

lvaTable before fgPromoteStructs
; Initial local variable assignments
;
;  V00 arg0              ref  class-hnd
;  V01 OutArgs        lclBlk <na>  "OutgoingArgSpace"
;  V02 tmp1              ref  class-hnd exact "NewObj constructor temp"
;  V03 tmp2           struct <System.ReadOnlySpan`1[Char], 16> "struct address for call/obj"
;  V04 tmp3              ref  class-hnd exact "NewObj constructor temp"
;  V05 tmp4           struct <System.ReadOnlySpan`1[Char], 16> "Inline return value spill temp"
;  V06 tmp5           struct <System.ReadOnlySpan`1[Char], 16> "NewObj constructor temp"
;  V07 tmp6           struct <System.ReadOnlySpan`1[Char], 16> ld-addr-op "Inline ldloca(s) first use temp"
;  V08 tmp7              int  "Inlining Arg"
;  V09 tmp8            byref  "Inlining Arg"
;  V10 tmp9           struct <System.ByReference`1[Char], 8> "NewObj constructor temp"
;  V11 tmp10            bool  "Inlining Arg"
;  V12 tmp11            bool  "Inlining Arg"
;  V13 tmp12             ref  class-hnd "Inlining Arg"
;  V14 tmp13             ref  class-hnd "Inlining Arg"

Promoting struct local V03 (System.ReadOnlySpan`1[Char]):
lvaGrabTemp returning 15 (V15 tmp14) (a long lifetime temp) called for field V03._pointer (fldOffset=0x0).

lvaGrabTemp returning 16 (V16 tmp15) (a long lifetime temp) called for field V03._length (fldOffset=0x8).

Promoting struct local V05 (System.ReadOnlySpan`1[Char]):
lvaGrabTemp returning 17 (V17 tmp16) (a long lifetime temp) called for field V05._pointer (fldOffset=0x0).

lvaGrabTemp returning 18 (V18 tmp17) (a long lifetime temp) called for field V05._length (fldOffset=0x8).

Promoting struct local V06 (System.ReadOnlySpan`1[Char]):
lvaGrabTemp returning 19 (V19 tmp18) (a long lifetime temp) called for field V06._pointer (fldOffset=0x0).

lvaGrabTemp returning 20 (V20 tmp19) (a long lifetime temp) called for field V06._length (fldOffset=0x8).

Promoting struct local V07 (System.ReadOnlySpan`1[Char]):
lvaGrabTemp returning 21 (V21 tmp20) (a long lifetime temp) called for field V07._pointer (fldOffset=0x0).

lvaGrabTemp returning 22 (V22 tmp21) (a long lifetime temp) called for field V07._length (fldOffset=0x8).

Promoting struct local V10 (System.ByReference`1[Char]):
lvaGrabTemp returning 23 (V23 tmp22) (a long lifetime temp) called for field V10._value (fldOffset=0x0).

lvaTable after fgPromoteStructs
; Initial local variable assignments
;
;  V00 arg0              ref  class-hnd
;  V01 OutArgs        lclBlk <na>  "OutgoingArgSpace"
;  V02 tmp1              ref  class-hnd exact "NewObj constructor temp"
;  V03 tmp2           struct <System.ReadOnlySpan`1[Char], 16> "struct address for call/obj"
;  V04 tmp3              ref  class-hnd exact "NewObj constructor temp"
;  V05 tmp4           struct <System.ReadOnlySpan`1[Char], 16> "Inline return value spill temp"
;  V06 tmp5           struct <System.ReadOnlySpan`1[Char], 16> "NewObj constructor temp"
;  V07 tmp6           struct <System.ReadOnlySpan`1[Char], 16> ld-addr-op "Inline ldloca(s) first use temp"
;  V08 tmp7              int  "Inlining Arg"
;  V09 tmp8            byref  "Inlining Arg"
;  V10 tmp9           struct <System.ByReference`1[Char], 8> "NewObj constructor temp"
;  V11 tmp10            bool  "Inlining Arg"
;  V12 tmp11            bool  "Inlining Arg"
;  V13 tmp12             ref  class-hnd "Inlining Arg"
;  V14 tmp13             ref  class-hnd "Inlining Arg"
;  V15 tmp14           byref  V03._pointer(offs=0x00) P-INDEP "field V03._pointer (fldOffset=0x0)"
;  V16 tmp15             int  V03._length(offs=0x08) P-INDEP "field V03._length (fldOffset=0x8)"
;  V17 tmp16           byref  V05._pointer(offs=0x00) P-INDEP "field V05._pointer (fldOffset=0x0)"
;  V18 tmp17             int  V05._length(offs=0x08) P-INDEP "field V05._length (fldOffset=0x8)"
;  V19 tmp18           byref  V06._pointer(offs=0x00) P-INDEP "field V06._pointer (fldOffset=0x0)"
;  V20 tmp19             int  V06._length(offs=0x08) P-INDEP "field V06._length (fldOffset=0x8)"
;  V21 tmp20           byref  V07._pointer(offs=0x00) P-INDEP "field V07._pointer (fldOffset=0x0)"
;  V22 tmp21             int  V07._length(offs=0x08) P-INDEP "field V07._length (fldOffset=0x8)"
;  V23 tmp22           byref  V10._value(offs=0x00) P-INDEP "field V10._value (fldOffset=0x0)"

*************** Finishing PHASE Morph - Promote Structs

*************** Starting PHASE Morph - Structs/AddrExp

*************** In fgMarkAddressExposedLocals()
LocalAddressVisitor visiting statement:
STMT00000 (IL 0x000...0x011)
               [000004] -AC---------              *  ASG       ref   
               [000003] D------N----              +--*  LCL_VAR   ref    V02 tmp1         
               [000002] --C---------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST
               [000001] H----------- arg0            \--*  CNS_INT(h) long   0xd1ffab1e token

LocalAddressVisitor visiting statement:
STMT00006 (IL   ???...  ???)
               [000021] -AC---------              *  ASG       ref   
               [000020] D------N----              +--*  LCL_VAR   ref    V04 tmp3         
               [000019] --C---------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST
               [000018] H----------- arg0            \--*  CNS_INT(h) long   0xd1ffab1e token

LocalAddressVisitor visiting statement:
STMT00013 (IL   ???...  ???)
               [000039] -ACXG-------              *  ASG       ref   
               [000038] ---XG--N----              +--*  FIELD     ref    _array
               [000035] ------------              |  \--*  LCL_VAR   ref    V04 tmp3         
               [000047] --CXG-------              \--*  COMMA     ref   
               [000046] H-CXG-------                 +--*  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS
               [000044] ------------ arg0            |  +--*  CNS_INT   long   0x7ffa40fb0028
               [000045] ------------ arg1            |  \--*  CNS_INT   int    6
               [000042] ----G-------                 \--*  FIELD     ref    Value

LocalAddressVisitor visiting statement:
STMT00008 (IL   ???...  ???)
               [000026] -A-XG-------              *  ASG       ref   
               [000025] ---XG--N----              +--*  FIELD     ref    _tokensBuffer
               [000005] ------------              |  \--*  LCL_VAR   ref    V02 tmp1         
               [000024] ------------              \--*  LCL_VAR   ref    V04 tmp3         

LocalAddressVisitor visiting statement:
STMT00010 (IL   ???...  ???)
               [000032] -A-XG-------              *  ASG       ref   
               [000031] ---XG--N----              +--*  FIELD     ref    _reader
               [000029] ------------              |  \--*  LCL_VAR   ref    V02 tmp1         
               [000030] ------------              \--*  CNS_INT   ref    null

LocalAddressVisitor visiting statement:
STMT00014 (IL 0x006...  ???)
               [000052] ------------              *  JTRUE     void  
               [000051] ------------              \--*  NE        int   
               [000008] ------------                 +--*  LCL_VAR   ref    V00 arg0         
               [000050] ------------                 \--*  CNS_INT   ref    null

LocalAddressVisitor visiting statement:
STMT00019 (IL 0x006...  ???)
               [000075] IA----------              *  ASG       struct (init)
               [000072] D------N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V07 tmp6         
                                                  +--*    byref  V07._pointer (offs=0x00) -> V21 tmp20        
                                                  +--*    int    V07._length (offs=0x08) -> V22 tmp21        
               [000074] ------------              \--*  CNS_INT   int    0

LocalAddressVisitor visiting statement:
STMT00020 (IL 0x006...  ???)
               [000079] -A----------              *  ASG       struct (copy)
               [000077] D------N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V05 tmp4         
                                                  +--*    byref  V05._pointer (offs=0x00) -> V17 tmp16        
                                                  +--*    int    V05._length (offs=0x08) -> V18 tmp17        
               [000076] ------------              \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V07 tmp6         
                                                  \--*    byref  V07._pointer (offs=0x00) -> V21 tmp20        
                                                  \--*    int    V07._length (offs=0x08) -> V22 tmp21        

LocalAddressVisitor visiting statement:
STMT00021 (IL 0x006...  ???)
               [000086] ---X--------              *  NULLCHECK byte  
               [000085] ------------              \--*  LCL_VAR   ref    V00 arg0         

LocalAddressVisitor visiting statement:
STMT00016 (IL 0x006...  ???)
               [000060] IA----------              *  ASG       struct (init)
               [000058] D------N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V06 tmp5         
                                                  +--*    byref  V06._pointer (offs=0x00) -> V19 tmp18        
                                                  +--*    int    V06._length (offs=0x08) -> V20 tmp19        
               [000059] ------------              \--*  CNS_INT   int    0

LocalAddressVisitor visiting statement:
STMT00026 (IL 0x006...  ???)
               [000112] -A-XG-------              *  ASG       byref 
               [000111] D------N----              +--*  LCL_VAR   byref  V09 tmp8         
               [000084] ---XG-------              \--*  ADDR      byref 
               [000083] ---XG--N----                 \--*  FIELD     ushort _firstChar
               [000053] ------------                    \--*  LCL_VAR   ref    V00 arg0         

LocalAddressVisitor visiting statement:
STMT00027 (IL 0x006...  ???)
               [000114] -A-X--------              *  ASG       int   
               [000113] D------N----              +--*  LCL_VAR   int    V08 tmp7         
               [000057] ---X--------              \--*  ARR_LENGTH int   
               [000056] ------------                 \--*  LCL_VAR   ref    V00 arg0         

LocalAddressVisitor visiting statement:
STMT00031 (IL 0x006...  ???)
               [000133] -A--G-------              *  ASG       ref   
               [000132] D------N----              +--*  LCL_VAR   ref    V13 tmp12        
               [000119] #---G-------              \--*  IND       ref   
               [000118] H-----------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]

LocalAddressVisitor visiting statement:
STMT00032 (IL 0x006...  ???)
               [000135] -A--G-------              *  ASG       ref   
               [000134] D------N----              +--*  LCL_VAR   ref    V14 tmp13        
               [000121] #---G-------              \--*  IND       ref   
               [000120] H-----------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]

LocalAddressVisitor visiting statement:
STMT00029 (IL 0x006...  ???)
               [000128] ------------              *  JTRUE     void  
               [000127] ------------              \--*  NE        int   
               [000124] ------------                 +--*  CAST      int <- bool <- int
               [000116] ------------                 |  \--*  CAST      int <- bool <- int
               [000092] ------------                 |     \--*  EQ        int   
               [000090] ------------                 |        +--*  LT        int   
               [000088] ------------                 |        |  +--*  LCL_VAR   int    V08 tmp7         
               [000089] ------------                 |        |  \--*  CNS_INT   int    0
               [000091] ------------                 |        \--*  CNS_INT   int    0
               [000126] ------------                 \--*  CNS_INT   int    0

LocalAddressVisitor visiting statement:
STMT00030 (IL 0x006...  ???)
               [000131] --C-G-------              *  CALL      void   System.Diagnostics.Debug.Fail
               [000129] ------------ arg0         +--*  LCL_VAR   ref    V13 tmp12        
               [000130] ------------ arg1         \--*  LCL_VAR   ref    V14 tmp13        

LocalAddressVisitor visiting statement:
STMT00023 (IL 0x006...  ???)
               [000100] -A----------              *  ASG       byref 
               [000099] -------N----              +--*  FIELD     byref  _value
               [000098] ------------              |  \--*  ADDR      byref 
               [000097] -------N----              |     \--*  LCL_VAR   struct<System.ByReference`1[Char], 8>(P) V10 tmp9         
                                                  |     \--*    byref  V10._value (offs=0x00) -> V23 tmp22        
               [000096] ------------              \--*  LCL_VAR   byref  V09 tmp8         
Replacing the field in promoted struct with local var V23
LocalAddressVisitor modified statement:
STMT00023 (IL 0x006...  ???)
               [000100] -A----------              *  ASG       byref 
               [000099] D------N----              +--*  LCL_VAR   byref  V23 tmp22        
               [000096] ------------              \--*  LCL_VAR   byref  V09 tmp8         

LocalAddressVisitor visiting statement:
STMT00024 (IL 0x006...  ???)
               [000105] -A----------              *  ASG       struct (copy)
               [000104] ------------              +--*  OBJ       struct<System.ByReference`1[Char], 8>
               [000103] ------------              |  \--*  ADDR      byref 
               [000102] -------N----              |     \--*  FIELD     struct _pointer
               [000094] ------------              |        \--*  ADDR      byref 
               [000095] -------N----              |           \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V06 tmp5         
                                                  |           \--*    byref  V06._pointer (offs=0x00) -> V19 tmp18        
                                                  |           \--*    int    V06._length (offs=0x08) -> V20 tmp19        
               [000101] -------N----              \--*  LCL_VAR   struct<System.ByReference`1[Char], 8>(P) V10 tmp9         
                                                  \--*    byref  V10._value (offs=0x00) -> V23 tmp22        
Replacing the field in promoted struct with local var V19
LocalAddressVisitor modified statement:
STMT00024 (IL 0x006...  ???)
               [000105] -A----------              *  ASG       struct (copy)
               [000104] ------------              +--*  OBJ       struct<System.ByReference`1[Char], 8>
               [000103] ------------              |  \--*  ADDR      byref 
               [000102] ------------              |     \--*  LCL_VAR   byref  V19 tmp18        
               [000101] -------N----              \--*  LCL_VAR   struct<System.ByReference`1[Char], 8>(P) V10 tmp9         
                                                  \--*    byref  V10._value (offs=0x00) -> V23 tmp22        

LocalAddressVisitor visiting statement:
STMT00025 (IL 0x006...  ???)
               [000110] -A----------              *  ASG       int   
               [000109] -------N----              +--*  FIELD     int    _length
               [000106] ------------              |  \--*  ADDR      byref 
               [000107] -------N----              |     \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V06 tmp5         
                                                  |     \--*    byref  V06._pointer (offs=0x00) -> V19 tmp18        
                                                  |     \--*    int    V06._length (offs=0x08) -> V20 tmp19        
               [000108] ------------              \--*  LCL_VAR   int    V08 tmp7         
Replacing the field in promoted struct with local var V20
LocalAddressVisitor modified statement:
STMT00025 (IL 0x006...  ???)
               [000110] -A----------              *  ASG       int   
               [000109] D------N----              +--*  LCL_VAR   int    V20 tmp19        
               [000108] ------------              \--*  LCL_VAR   int    V08 tmp7         

LocalAddressVisitor visiting statement:
STMT00018 (IL 0x006...  ???)
               [000067] -A----------              *  ASG       struct (copy)
               [000065] D------N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V05 tmp4         
                                                  +--*    byref  V05._pointer (offs=0x00) -> V17 tmp16        
                                                  +--*    int    V05._length (offs=0x08) -> V18 tmp17        
               [000064] ------------              \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V06 tmp5         
                                                  \--*    byref  V06._pointer (offs=0x00) -> V19 tmp18        
                                                  \--*    int    V06._length (offs=0x08) -> V20 tmp19        

LocalAddressVisitor visiting statement:
STMT00003 (IL   ???...  ???)
               [000071] -A----------              *  ASG       struct (copy)
               [000069] D------N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V03 tmp2         
                                                  +--*    byref  V03._pointer (offs=0x00) -> V15 tmp14        
                                                  +--*    int    V03._length (offs=0x08) -> V16 tmp15        
               [000070] ------------              \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V05 tmp4         
                                                  \--*    byref  V05._pointer (offs=0x00) -> V17 tmp16        
                                                  \--*    int    V05._length (offs=0x08) -> V18 tmp17        

LocalAddressVisitor visiting statement:
STMT00004 (IL   ???...  ???)
               [000011] --C-G-------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer.TokenizeLine
               [000007] ------------ this in rcx  +--*  LCL_VAR   ref    V02 tmp1         
               [000016] n----------- arg1         \--*  OBJ       struct<System.ReadOnlySpan`1[Char], 16>
               [000015] ------------                 \--*  ADDR      byref 
               [000014] -------N----                    \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V03 tmp2         
                                                        \--*    byref  V03._pointer (offs=0x00) -> V15 tmp14        
                                                        \--*    int    V03._length (offs=0x08) -> V16 tmp15        

LocalAddressVisitor visiting statement:
STMT00005 (IL 0x011...  ???)
               [000017] ------------              *  RETURN    void  


*************** Finishing PHASE Morph - Structs/AddrExp

*************** Starting PHASE Morph - ByRefs

*************** In fgRetypeImplicitByRefArgs()

*************** Finishing PHASE Morph - ByRefs

*************** Starting PHASE Morph - Global

*************** In fgMorphBlocks()

Morphing BB01 of 'Accretion.JitDumpVisualizer.CLI.Program:Tokenize(System.String)'

fgMorphTree BB01, STMT00000 (before)
               [000004] -AC---------              *  ASG       ref   
               [000003] D------N----              +--*  LCL_VAR   ref    V02 tmp1         
               [000002] --C---------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST
               [000001] H----------- arg0            \--*  CNS_INT(h) long   0xd1ffab1e token
Initializing arg info for 2.CALL:
ArgTable for 2.CALL after fgInitArgInfo:
fgArgTabEntry[arg 0 1.CNS_INT long (By ref), 1 reg: rcx, byteAlignment=8]

Morphing args for 2.CALL:
argSlots=1, preallocatedArgCount=4, nextSlotNum=4, nextSlotByteOffset=32, outgoingArgSpaceSize=32

Sorting the arguments:
Deferred argument ('rcx'):
               [000001] H----+------              *  CNS_INT(h) long   0xd1ffab1e token
Replaced with placeholder node:
               [000137] ----------L-              *  ARGPLACE  long  

Shuffled argument table:    rcx 
ArgTable for 2.CALL after fgMorphArgs:
fgArgTabEntry[arg 0 1.CNS_INT long (By ref), 1 reg: rcx, byteAlignment=8, lateArgInx=0, processed]


fgMorphTree BB01, STMT00000 (after)
               [000004] -AC--+------              *  ASG       ref   
               [000003] D----+-N----              +--*  LCL_VAR   ref    V02 tmp1         
               [000002] --C--+------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST
               [000001] H----+------ arg0 in rcx     \--*  CNS_INT(h) long   0xd1ffab1e token

fgMorphTree BB01, STMT00006 (before)
               [000021] -AC---------              *  ASG       ref   
               [000020] D------N----              +--*  LCL_VAR   ref    V04 tmp3         
               [000019] --C---------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST
               [000018] H----------- arg0            \--*  CNS_INT(h) long   0xd1ffab1e token
Initializing arg info for 19.CALL:
ArgTable for 19.CALL after fgInitArgInfo:
fgArgTabEntry[arg 0 18.CNS_INT long (By ref), 1 reg: rcx, byteAlignment=8]

Morphing args for 19.CALL:
argSlots=1, preallocatedArgCount=4, nextSlotNum=4, nextSlotByteOffset=32, outgoingArgSpaceSize=32

Sorting the arguments:
Deferred argument ('rcx'):
               [000018] H----+------              *  CNS_INT(h) long   0xd1ffab1e token
Replaced with placeholder node:
               [000138] ----------L-              *  ARGPLACE  long  

Shuffled argument table:    rcx 
ArgTable for 19.CALL after fgMorphArgs:
fgArgTabEntry[arg 0 18.CNS_INT long (By ref), 1 reg: rcx, byteAlignment=8, lateArgInx=0, processed]


fgMorphTree BB01, STMT00006 (after)
               [000021] -AC--+------              *  ASG       ref   
               [000020] D----+-N----              +--*  LCL_VAR   ref    V04 tmp3         
               [000019] --C--+------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST
               [000018] H----+------ arg0 in rcx     \--*  CNS_INT(h) long   0xd1ffab1e token

fgMorphTree BB01, STMT00013 (before)
               [000039] -ACXG-------              *  ASG       ref   
               [000038] ---XG--N----              +--*  FIELD     ref    _array
               [000035] ------------              |  \--*  LCL_VAR   ref    V04 tmp3         
               [000047] --CXG-------              \--*  COMMA     ref   
               [000046] H-CXG-------                 +--*  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS
               [000044] ------------ arg0            |  +--*  CNS_INT   long   0x7ffa40fb0028
               [000045] ------------ arg1            |  \--*  CNS_INT   int    6
               [000042] ----G-------                 \--*  FIELD     ref    Value

Final value of Compiler::fgMorphField after calling fgMorphSmpOp:
               [000038] ---XG--N----              *  IND       ref   
               [000140] -----+------              \--*  ADD       byref 
               [000035] -----+------                 +--*  LCL_VAR   ref    V04 tmp3         
               [000139] -----+------                 \--*  CNS_INT   long   8 field offset Fseq[_array]
GenTreeNode creates assertion:
               [000038] ---XG--N----              *  IND       ref   
In BB01 New Local Constant Assertion: V04 != null index=#01, mask=0000000000000001
Initializing arg info for 46.CALL:
ArgTable for 46.CALL after fgInitArgInfo:
fgArgTabEntry[arg 0 44.CNS_INT long (By ref), 1 reg: rcx, byteAlignment=8]
fgArgTabEntry[arg 1 45.CNS_INT int (By ref), 1 reg: rdx, byteAlignment=8]

Morphing args for 46.CALL:
argSlots=2, preallocatedArgCount=4, nextSlotNum=4, nextSlotByteOffset=32, outgoingArgSpaceSize=32

Sorting the arguments:
Deferred argument ('rcx'):
               [000044] -----+------              *  CNS_INT   long   0x7ffa40fb0028
Replaced with placeholder node:
               [000141] ----------L-              *  ARGPLACE  long  
Deferred argument ('rdx'):
               [000045] -----+------              *  CNS_INT   int    6
Replaced with placeholder node:
               [000142] ----------L-              *  ARGPLACE  int   

Shuffled argument table:    rcx rdx 
ArgTable for 46.CALL after fgMorphArgs:
fgArgTabEntry[arg 0 44.CNS_INT long (By ref), 1 reg: rcx, byteAlignment=8, lateArgInx=0, processed]
fgArgTabEntry[arg 1 45.CNS_INT int (By ref), 1 reg: rdx, byteAlignment=8, lateArgInx=1, processed]


fgMorphTree BB01, STMT00013 (after)
               [000039] -ACXG+------              *  ASG       ref   
               [000038] ---XG+-N----              +--*  IND       ref   
               [000140] -----+------              |  \--*  ADD       byref 
               [000035] -----+------              |     +--*  LCL_VAR   ref    V04 tmp3         
               [000139] -----+------              |     \--*  CNS_INT   long   8 field offset Fseq[_array]
               [000047] --CXG+------              \--*  COMMA     ref   
               [000046] H-CXG+------                 +--*  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS
               [000044] -----+------ arg0 in rcx     |  +--*  CNS_INT   long   0x7ffa40fb0028
               [000045] -----+------ arg1 in rdx     |  \--*  CNS_INT   int    6
               [000042] n---G+------                 \--*  IND       ref   
               [000143] I----+------                    \--*  CNS_INT(h) long   0xd1ffab1e static Fseq[Value]

fgMorphTree BB01, STMT00008 (before)
               [000026] -A-XG-------              *  ASG       ref   
               [000025] ---XG--N----              +--*  FIELD     ref    _tokensBuffer
               [000005] ------------              |  \--*  LCL_VAR   ref    V02 tmp1         
               [000024] ------------              \--*  LCL_VAR   ref    V04 tmp3         

Final value of Compiler::fgMorphField after calling fgMorphSmpOp:
               [000025] ---XG--N----              *  IND       ref   
               [000145] -----+------              \--*  ADD       byref 
               [000005] -----+------                 +--*  LCL_VAR   ref    V02 tmp1         
               [000144] -----+------                 \--*  CNS_INT   long   16 field offset Fseq[_tokensBuffer]
GenTreeNode creates assertion:
               [000025] ---XG--N----              *  IND       ref   
In BB01 New Local Constant Assertion: V02 != null index=#02, mask=0000000000000002

fgMorphTree BB01, STMT00008 (after)
               [000026] -A-XG+------              *  ASG       ref   
               [000025] ---XG+-N----              +--*  IND       ref   
               [000145] -----+------              |  \--*  ADD       byref 
               [000005] -----+------              |     +--*  LCL_VAR   ref    V02 tmp1         
               [000144] -----+------              |     \--*  CNS_INT   long   16 field offset Fseq[_tokensBuffer]
               [000024] -----+------              \--*  LCL_VAR   ref    V04 tmp3         

fgMorphTree BB01, STMT00010 (before)
               [000032] -A-XG-------              *  ASG       ref   
               [000031] ---XG--N----              +--*  FIELD     ref    _reader
               [000029] ------------              |  \--*  LCL_VAR   ref    V02 tmp1         
               [000030] ------------              \--*  CNS_INT   ref    null

Final value of Compiler::fgMorphField after calling fgMorphSmpOp:
               [000031] ---XG--N----              *  IND       ref   
               [000147] -----+------              \--*  ADD       byref 
               [000029] -----+------                 +--*  LCL_VAR   ref    V02 tmp1         
               [000146] -----+------                 \--*  CNS_INT   long   8 field offset Fseq[_reader]

fgMorphTree BB01, STMT00010 (after)
               [000032] -A-XG+------              *  ASG       ref   
               [000031] ---XG+-N----              +--*  IND       ref   
               [000147] -----+------              |  \--*  ADD       byref 
               [000029] -----+------              |     +--*  LCL_VAR   ref    V02 tmp1         
               [000146] -----+------              |     \--*  CNS_INT   long   8 field offset Fseq[_reader]
               [000030] -----+------              \--*  CNS_INT   ref    null

fgMorphTree BB01, STMT00014 (before)
               [000052] ------------              *  JTRUE     void  
               [000051] ------------              \--*  NE        int   
               [000008] ------------                 +--*  LCL_VAR   ref    V00 arg0         
               [000050] ------------                 \--*  CNS_INT   ref    null

Morphing BB03 of 'Accretion.JitDumpVisualizer.CLI.Program:Tokenize(System.String)'

fgMorphTree BB03, STMT00019 (before)
               [000075] IA----------              *  ASG       struct (init)
               [000072] D------N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V07 tmp6         
                                                  +--*    byref  V07._pointer (offs=0x00) -> V21 tmp20        
                                                  +--*    int    V07._length (offs=0x08) -> V22 tmp21        
               [000074] ------------              \--*  CNS_INT   int    0
fgMorphBlkNode for dst tree, before:
               [000072] D----+-N----              *  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V07 tmp6         
                                                  *    byref  V07._pointer (offs=0x00) -> V21 tmp20        
                                                  *    int    V07._length (offs=0x08) -> V22 tmp21        
fgMorphBlkNode after:
               [000072] D----+-N----              *  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V07 tmp6         
                                                  *    byref  V07._pointer (offs=0x00) -> V21 tmp20        
                                                  *    int    V07._length (offs=0x08) -> V22 tmp21        

fgMorphInitBlock: using field by field initialization.
GenTreeNode creates assertion:
               [000150] -A----------              *  ASG       byref 
In BB03 New Local Constant Assertion: V21 == 0 index=#01, mask=0000000000000001
GenTreeNode creates assertion:
               [000153] -A----------              *  ASG       int   
In BB03 New Local Constant Assertion: V22 == 0 index=#02, mask=0000000000000002
fgMorphInitBlock (after):
               [000154] -A---+------              *  COMMA     void  
               [000150] -A----------              +--*  ASG       byref 
               [000148] D------N----              |  +--*  LCL_VAR   byref  V21 tmp20        
               [000149] ------------              |  \--*  CNS_INT   byref  0
               [000153] -A----------              \--*  ASG       int   
               [000151] D------N----                 +--*  LCL_VAR   int    V22 tmp21        
               [000152] ------------                 \--*  CNS_INT   int    0

fgMorphTree BB03, STMT00019 (after)
               [000154] -A---+------              *  COMMA     void  
               [000150] -A----------              +--*  ASG       byref 
               [000148] D------N----              |  +--*  LCL_VAR   byref  V21 tmp20        
               [000149] ------------              |  \--*  CNS_INT   byref  0
               [000153] -A----------              \--*  ASG       int   
               [000151] D------N----                 +--*  LCL_VAR   int    V22 tmp21        
               [000152] ------------                 \--*  CNS_INT   int    0

fgMorphTree BB03, STMT00020 (before)
               [000079] -A----------              *  ASG       struct (copy)
               [000077] D------N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V05 tmp4         
                                                  +--*    byref  V05._pointer (offs=0x00) -> V17 tmp16        
                                                  +--*    int    V05._length (offs=0x08) -> V18 tmp17        
               [000076] ------------              \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V07 tmp6         
                                                  \--*    byref  V07._pointer (offs=0x00) -> V21 tmp20        
                                                  \--*    int    V07._length (offs=0x08) -> V22 tmp21        
fgMorphCopyBlock:
fgMorphBlkNode for dst tree, before:
               [000077] D----+-N----              *  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V05 tmp4         
                                                  *    byref  V05._pointer (offs=0x00) -> V17 tmp16        
                                                  *    int    V05._length (offs=0x08) -> V18 tmp17        
fgMorphBlkNode after:
               [000077] D----+-N----              *  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V05 tmp4         
                                                  *    byref  V05._pointer (offs=0x00) -> V17 tmp16        
                                                  *    int    V05._length (offs=0x08) -> V18 tmp17        
fgMorphBlkNode for src tree, before:
               [000076] -----+------              *  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V07 tmp6         
                                                  *    byref  V07._pointer (offs=0x00) -> V21 tmp20        
                                                  *    int    V07._length (offs=0x08) -> V22 tmp21        
fgMorphBlkNode after:
               [000076] -----+------              *  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V07 tmp6         
                                                  *    byref  V07._pointer (offs=0x00) -> V21 tmp20        
                                                  *    int    V07._length (offs=0x08) -> V22 tmp21        
block assignment to morph:
               [000079] -A----------              *  ASG       struct (copy)
               [000077] D----+-N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V05 tmp4         
                                                  +--*    byref  V05._pointer (offs=0x00) -> V17 tmp16        
                                                  +--*    int    V05._length (offs=0x08) -> V18 tmp17        
               [000076] -----+------              \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V07 tmp6         
                                                  \--*    byref  V07._pointer (offs=0x00) -> V21 tmp20        
                                                  \--*    int    V07._length (offs=0x08) -> V22 tmp21        
 (destDoFldAsg=true) (srcDoFldAsg=true) using field by field assignments.
GenTreeNode creates assertion:
               [000157] -A----------              *  ASG       byref 
In BB03 New Local Copy     Assertion: V17 == V21 index=#03, mask=0000000000000004
GenTreeNode creates assertion:
               [000160] -A----------              *  ASG       int   
In BB03 New Local Copy     Assertion: V18 == V22 index=#04, mask=0000000000000008

fgMorphCopyBlock (after):
               [000161] -A---+------              *  COMMA     void  
               [000157] -A----------              +--*  ASG       byref 
               [000155] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        
               [000156] ------------              |  \--*  LCL_VAR   byref  V21 tmp20        
               [000160] -A----------              \--*  ASG       int   
               [000158] D------N----                 +--*  LCL_VAR   int    V18 tmp17        
               [000159] ------------                 \--*  LCL_VAR   int    V22 tmp21        

fgMorphTree BB03, STMT00020 (after)
               [000161] -A---+------              *  COMMA     void  
               [000157] -A----------              +--*  ASG       byref 
               [000155] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        
               [000156] ------------              |  \--*  LCL_VAR   byref  V21 tmp20        
               [000160] -A----------              \--*  ASG       int   
               [000158] D------N----                 +--*  LCL_VAR   int    V18 tmp17        
               [000159] ------------                 \--*  LCL_VAR   int    V22 tmp21        

Morphing BB04 of 'Accretion.JitDumpVisualizer.CLI.Program:Tokenize(System.String)'

fgMorphTree BB04, STMT00021 (before)
               [000086] ---X--------              *  NULLCHECK byte  
               [000085] ------------              \--*  LCL_VAR   ref    V00 arg0         
GenTreeNode creates assertion:
               [000086] ---X--------              *  NULLCHECK byte  
In BB04 New Local Constant Assertion: V00 != null index=#01, mask=0000000000000001

fgMorphTree BB04, STMT00016 (before)
               [000060] IA----------              *  ASG       struct (init)
               [000058] D------N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V06 tmp5         
                                                  +--*    byref  V06._pointer (offs=0x00) -> V19 tmp18        
                                                  +--*    int    V06._length (offs=0x08) -> V20 tmp19        
               [000059] ------------              \--*  CNS_INT   int    0
fgMorphBlkNode for dst tree, before:
               [000058] D----+-N----              *  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V06 tmp5         
                                                  *    byref  V06._pointer (offs=0x00) -> V19 tmp18        
                                                  *    int    V06._length (offs=0x08) -> V20 tmp19        
fgMorphBlkNode after:
               [000058] D----+-N----              *  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V06 tmp5         
                                                  *    byref  V06._pointer (offs=0x00) -> V19 tmp18        
                                                  *    int    V06._length (offs=0x08) -> V20 tmp19        

fgMorphInitBlock: using field by field initialization.
GenTreeNode creates assertion:
               [000164] -A----------              *  ASG       byref 
In BB04 New Local Constant Assertion: V19 == 0 index=#02, mask=0000000000000002
GenTreeNode creates assertion:
               [000167] -A----------              *  ASG       int   
In BB04 New Local Constant Assertion: V20 == 0 index=#03, mask=0000000000000004
fgMorphInitBlock (after):
               [000168] -A---+------              *  COMMA     void  
               [000164] -A----------              +--*  ASG       byref 
               [000162] D------N----              |  +--*  LCL_VAR   byref  V19 tmp18        
               [000163] ------------              |  \--*  CNS_INT   byref  0
               [000167] -A----------              \--*  ASG       int   
               [000165] D------N----                 +--*  LCL_VAR   int    V20 tmp19        
               [000166] ------------                 \--*  CNS_INT   int    0

fgMorphTree BB04, STMT00016 (after)
               [000168] -A---+------              *  COMMA     void  
               [000164] -A----------              +--*  ASG       byref 
               [000162] D------N----              |  +--*  LCL_VAR   byref  V19 tmp18        
               [000163] ------------              |  \--*  CNS_INT   byref  0
               [000167] -A----------              \--*  ASG       int   
               [000165] D------N----                 +--*  LCL_VAR   int    V20 tmp19        
               [000166] ------------                 \--*  CNS_INT   int    0

fgMorphTree BB04, STMT00026 (before)
               [000112] -A-XG-------              *  ASG       byref 
               [000111] D------N----              +--*  LCL_VAR   byref  V09 tmp8         
               [000084] ---XG-------              \--*  ADDR      byref 
               [000083] ---XG--N----                 \--*  FIELD     ushort _firstChar
               [000053] ------------                    \--*  LCL_VAR   ref    V00 arg0         
Before explicit null check morphing:
               [000083] ---XG--N----              *  FIELD     ushort _firstChar
               [000053] ------------              \--*  LCL_VAR   ref    V00 arg0         
After adding explicit null check:
               [000083] ---XG--N----              *  IND       ushort
               [000174] ---X--------              \--*  COMMA     byref 
               [000170] ---X---N----                 +--*  NULLCHECK byte  
               [000169] ------------                 |  \--*  LCL_VAR   ref    V00 arg0         
               [000173] ------------                 \--*  ADD       byref 
               [000171] ------------                    +--*  LCL_VAR   ref    V00 arg0         
               [000172] ------------                    \--*  CNS_INT   long   12 field offset Fseq[_firstChar]

Non-null prop for index #01 in BB04:
               [000170] ---X---N----              *  NULLCHECK byte  

Final value of Compiler::fgMorphField after calling fgMorphSmpOp:
               [000083] ---XG--N----              *  IND       ushort
               [000173] -----+------              \--*  ADD       byref 
               [000171] -----+------                 +--*  LCL_VAR   ref    V00 arg0         
               [000172] -----+------                 \--*  CNS_INT   long   12 field offset Fseq[_firstChar]

fgMorphTree BB04, STMT00026 (after)
               [000112] -A--G+------              *  ASG       byref 
               [000111] D----+-N----              +--*  LCL_VAR   byref  V09 tmp8         
               [000173] -----+------              \--*  ADD       byref 
               [000171] -----+------                 +--*  LCL_VAR   ref    V00 arg0         
               [000172] -----+------                 \--*  CNS_INT   long   12 field offset Fseq[_firstChar]

fgMorphTree BB04, STMT00027 (before)
               [000114] -A-X--------              *  ASG       int   
               [000113] D------N----              +--*  LCL_VAR   int    V08 tmp7         
               [000057] ---X--------              \--*  ARR_LENGTH int   
               [000056] ------------                 \--*  LCL_VAR   ref    V00 arg0         

fgMorphTree BB04, STMT00031 (before)
               [000133] -A--G-------              *  ASG       ref   
               [000132] D------N----              +--*  LCL_VAR   ref    V13 tmp12        
               [000119] #---G-------              \--*  IND       ref   
               [000118] H-----------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]

fgMorphTree BB04, STMT00032 (before)
               [000135] -A--G-------              *  ASG       ref   
               [000134] D------N----              +--*  LCL_VAR   ref    V14 tmp13        
               [000121] #---G-------              \--*  IND       ref   
               [000120] H-----------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]

fgMorphTree BB04, STMT00029 (before)
               [000128] ------------              *  JTRUE     void  
               [000127] ------------              \--*  NE        int   
               [000124] ------------                 +--*  CAST      int <- bool <- int
               [000116] ------------                 |  \--*  CAST      int <- bool <- int
               [000092] ------------                 |     \--*  EQ        int   
               [000090] ------------                 |        +--*  LT        int   
               [000088] ------------                 |        |  +--*  LCL_VAR   int    V08 tmp7         
               [000089] ------------                 |        |  \--*  CNS_INT   int    0
               [000091] ------------                 |        \--*  CNS_INT   int    0
               [000126] ------------                 \--*  CNS_INT   int    0

fgMorphTree BB04, STMT00029 (after)
               [000128] -----+------              *  JTRUE     void  
               [000090] J----+-N----              \--*  GE        int   
               [000088] -----+------                 +--*  LCL_VAR   int    V08 tmp7         
               [000089] -----+------                 \--*  CNS_INT   int    0

Morphing BB06 of 'Accretion.JitDumpVisualizer.CLI.Program:Tokenize(System.String)'

fgMorphTree BB06, STMT00030 (before)
               [000131] --C-G-------              *  CALL      void   System.Diagnostics.Debug.Fail
               [000129] ------------ arg0         +--*  LCL_VAR   ref    V13 tmp12        
               [000130] ------------ arg1         \--*  LCL_VAR   ref    V14 tmp13        
Initializing arg info for 131.CALL:
ArgTable for 131.CALL after fgInitArgInfo:
fgArgTabEntry[arg 0 129.LCL_VAR ref (By ref), 1 reg: rcx, byteAlignment=8]
fgArgTabEntry[arg 1 130.LCL_VAR ref (By ref), 1 reg: rdx, byteAlignment=8]

Morphing args for 131.CALL:
argSlots=2, preallocatedArgCount=4, nextSlotNum=4, nextSlotByteOffset=32, outgoingArgSpaceSize=32

Sorting the arguments:
Deferred argument ('rcx'):
               [000129] -----+------              *  LCL_VAR   ref    V13 tmp12        
Replaced with placeholder node:
               [000175] ----------L-              *  ARGPLACE  ref   
Deferred argument ('rdx'):
               [000130] -----+------              *  LCL_VAR   ref    V14 tmp13        
Replaced with placeholder node:
               [000176] ----------L-              *  ARGPLACE  ref   

Shuffled argument table:    rcx rdx 
ArgTable for 131.CALL after fgMorphArgs:
fgArgTabEntry[arg 0 129.LCL_VAR ref (By ref), 1 reg: rcx, byteAlignment=8, lateArgInx=0, processed]
fgArgTabEntry[arg 1 130.LCL_VAR ref (By ref), 1 reg: rdx, byteAlignment=8, lateArgInx=1, processed]


fgMorphTree BB06, STMT00030 (after)
               [000131] --CXG+------              *  CALL      void   System.Diagnostics.Debug.Fail
               [000129] -----+------ arg0 in rcx  +--*  LCL_VAR   ref    V13 tmp12        
               [000130] -----+------ arg1 in rdx  \--*  LCL_VAR   ref    V14 tmp13        

Morphing BB07 of 'Accretion.JitDumpVisualizer.CLI.Program:Tokenize(System.String)'

fgMorphTree BB07, STMT00023 (before)
               [000100] -A----------              *  ASG       byref 
               [000099] D------N----              +--*  LCL_VAR   byref  V23 tmp22        
               [000096] ------------              \--*  LCL_VAR   byref  V09 tmp8         
GenTreeNode creates assertion:
               [000100] -A----------              *  ASG       byref 
In BB07 New Local Copy     Assertion: V23 == V09 index=#01, mask=0000000000000001

fgMorphTree BB07, STMT00024 (before)
               [000105] -A----------              *  ASG       struct (copy)
               [000104] ------------              +--*  OBJ       struct<System.ByReference`1[Char], 8>
               [000103] ------------              |  \--*  ADDR      byref 
               [000102] ------------              |     \--*  LCL_VAR   byref  V19 tmp18        
               [000101] -------N----              \--*  LCL_VAR   struct<System.ByReference`1[Char], 8>(P) V10 tmp9         
                                                  \--*    byref  V10._value (offs=0x00) -> V23 tmp22        
fgMorphCopyBlock:
fgMorphBlkNode for dst tree, before:
               [000104] n----+------              *  OBJ       struct<System.ByReference`1[Char], 8>
               [000103] -----+------              \--*  ADDR      byref 
               [000102] D----+-N----                 \--*  LCL_VAR   byref  V19 tmp18        
fgMorphBlkNode after:
               [000104] n----+------              *  OBJ       struct<System.ByReference`1[Char], 8>
               [000103] -----+------              \--*  ADDR      byref 
               [000102] D----+-N----                 \--*  LCL_VAR   byref  V19 tmp18        
fgMorphBlkNode for src tree, before:
               [000101] -----+-N----              *  LCL_VAR   struct<System.ByReference`1[Char], 8>(P) V10 tmp9         
                                                  *    byref  V10._value (offs=0x00) -> V23 tmp22        
fgMorphBlkNode after:
               [000101] -----+-N----              *  LCL_VAR   struct<System.ByReference`1[Char], 8>(P) V10 tmp9         
                                                  *    byref  V10._value (offs=0x00) -> V23 tmp22        
block assignment to morph:
               [000105] -A----------              *  ASG       struct (copy)
               [000104] n----+------              +--*  OBJ       struct<System.ByReference`1[Char], 8>
               [000103] -----+------              |  \--*  ADDR      byref 
               [000102] D----+-N----              |     \--*  LCL_VAR   byref  V19 tmp18        
               [000101] -----+-N----              \--*  LCL_VAR   struct<System.ByReference`1[Char], 8>(P) V10 tmp9         
                                                  \--*    byref  V10._value (offs=0x00) -> V23 tmp22        
 (srcDoFldAsg=true) using field by field assignments.
GenTreeNode creates assertion:
               [000179] -A----------              *  ASG       byref 
In BB07 New Local Copy     Assertion: V19 == V23 index=#02, mask=0000000000000002

fgMorphCopyBlock (after):
               [000179] -A---+------              *  ASG       byref 
               [000177] D------N----              +--*  LCL_VAR   byref  V19 tmp18        
               [000178] -------N----              \--*  LCL_VAR   byref  V23 tmp22        

The assignment [000179] using V19 removes: Copy     Assertion: V19 == V23
GenTreeNode creates assertion:
               [000179] -A---+------              *  ASG       byref 
In BB07 New Local Copy     Assertion: V19 == V23 index=#02, mask=0000000000000002

fgMorphTree BB07, STMT00024 (after)
               [000179] -A---+------              *  ASG       byref 
               [000177] D------N----              +--*  LCL_VAR   byref  V19 tmp18        
               [000178] -------N----              \--*  LCL_VAR   byref  V23 tmp22        

fgMorphTree BB07, STMT00025 (before)
               [000110] -A----------              *  ASG       int   
               [000109] D------N----              +--*  LCL_VAR   int    V20 tmp19        
               [000108] ------------              \--*  LCL_VAR   int    V08 tmp7         
GenTreeNode creates assertion:
               [000110] -A----------              *  ASG       int   
In BB07 New Local Copy     Assertion: V20 == V08 index=#03, mask=0000000000000004

fgMorphTree BB07, STMT00018 (before)
               [000067] -A----------              *  ASG       struct (copy)
               [000065] D------N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V05 tmp4         
                                                  +--*    byref  V05._pointer (offs=0x00) -> V17 tmp16        
                                                  +--*    int    V05._length (offs=0x08) -> V18 tmp17        
               [000064] ------------              \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V06 tmp5         
                                                  \--*    byref  V06._pointer (offs=0x00) -> V19 tmp18        
                                                  \--*    int    V06._length (offs=0x08) -> V20 tmp19        
fgMorphCopyBlock:
fgMorphBlkNode for dst tree, before:
               [000065] D----+-N----              *  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V05 tmp4         
                                                  *    byref  V05._pointer (offs=0x00) -> V17 tmp16        
                                                  *    int    V05._length (offs=0x08) -> V18 tmp17        
fgMorphBlkNode after:
               [000065] D----+-N----              *  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V05 tmp4         
                                                  *    byref  V05._pointer (offs=0x00) -> V17 tmp16        
                                                  *    int    V05._length (offs=0x08) -> V18 tmp17        
fgMorphBlkNode for src tree, before:
               [000064] -----+------              *  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V06 tmp5         
                                                  *    byref  V06._pointer (offs=0x00) -> V19 tmp18        
                                                  *    int    V06._length (offs=0x08) -> V20 tmp19        
fgMorphBlkNode after:
               [000064] -----+------              *  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V06 tmp5         
                                                  *    byref  V06._pointer (offs=0x00) -> V19 tmp18        
                                                  *    int    V06._length (offs=0x08) -> V20 tmp19        
block assignment to morph:
               [000067] -A----------              *  ASG       struct (copy)
               [000065] D----+-N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V05 tmp4         
                                                  +--*    byref  V05._pointer (offs=0x00) -> V17 tmp16        
                                                  +--*    int    V05._length (offs=0x08) -> V18 tmp17        
               [000064] -----+------              \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V06 tmp5         
                                                  \--*    byref  V06._pointer (offs=0x00) -> V19 tmp18        
                                                  \--*    int    V06._length (offs=0x08) -> V20 tmp19        
 (destDoFldAsg=true) (srcDoFldAsg=true) using field by field assignments.
GenTreeNode creates assertion:
               [000182] -A----------              *  ASG       byref 
In BB07 New Local Copy     Assertion: V17 == V19 index=#04, mask=0000000000000008
GenTreeNode creates assertion:
               [000185] -A----------              *  ASG       int   
In BB07 New Local Copy     Assertion: V18 == V20 index=#05, mask=0000000000000010

fgMorphCopyBlock (after):
               [000186] -A---+------              *  COMMA     void  
               [000182] -A----------              +--*  ASG       byref 
               [000180] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        
               [000181] ------------              |  \--*  LCL_VAR   byref  V19 tmp18        
               [000185] -A----------              \--*  ASG       int   
               [000183] D------N----                 +--*  LCL_VAR   int    V18 tmp17        
               [000184] ------------                 \--*  LCL_VAR   int    V20 tmp19        

fgMorphTree BB07, STMT00018 (after)
               [000186] -A---+------              *  COMMA     void  
               [000182] -A----------              +--*  ASG       byref 
               [000180] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        
               [000181] ------------              |  \--*  LCL_VAR   byref  V19 tmp18        
               [000185] -A----------              \--*  ASG       int   
               [000183] D------N----                 +--*  LCL_VAR   int    V18 tmp17        
               [000184] ------------                 \--*  LCL_VAR   int    V20 tmp19        

Morphing BB09 of 'Accretion.JitDumpVisualizer.CLI.Program:Tokenize(System.String)'

fgMorphTree BB09, STMT00003 (before)
               [000071] -A----------              *  ASG       struct (copy)
               [000069] D------N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V03 tmp2         
                                                  +--*    byref  V03._pointer (offs=0x00) -> V15 tmp14        
                                                  +--*    int    V03._length (offs=0x08) -> V16 tmp15        
               [000070] ------------              \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V05 tmp4         
                                                  \--*    byref  V05._pointer (offs=0x00) -> V17 tmp16        
                                                  \--*    int    V05._length (offs=0x08) -> V18 tmp17        
fgMorphCopyBlock:
fgMorphBlkNode for dst tree, before:
               [000069] D----+-N----              *  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V03 tmp2         
                                                  *    byref  V03._pointer (offs=0x00) -> V15 tmp14        
                                                  *    int    V03._length (offs=0x08) -> V16 tmp15        
fgMorphBlkNode after:
               [000069] D----+-N----              *  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V03 tmp2         
                                                  *    byref  V03._pointer (offs=0x00) -> V15 tmp14        
                                                  *    int    V03._length (offs=0x08) -> V16 tmp15        
fgMorphBlkNode for src tree, before:
               [000070] -----+------              *  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V05 tmp4         
                                                  *    byref  V05._pointer (offs=0x00) -> V17 tmp16        
                                                  *    int    V05._length (offs=0x08) -> V18 tmp17        
fgMorphBlkNode after:
               [000070] -----+------              *  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V05 tmp4         
                                                  *    byref  V05._pointer (offs=0x00) -> V17 tmp16        
                                                  *    int    V05._length (offs=0x08) -> V18 tmp17        
block assignment to morph:
               [000071] -A----------              *  ASG       struct (copy)
               [000069] D----+-N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V03 tmp2         
                                                  +--*    byref  V03._pointer (offs=0x00) -> V15 tmp14        
                                                  +--*    int    V03._length (offs=0x08) -> V16 tmp15        
               [000070] -----+------              \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V05 tmp4         
                                                  \--*    byref  V05._pointer (offs=0x00) -> V17 tmp16        
                                                  \--*    int    V05._length (offs=0x08) -> V18 tmp17        
 (destDoFldAsg=true) (srcDoFldAsg=true) using field by field assignments.
GenTreeNode creates assertion:
               [000189] -A----------              *  ASG       byref 
In BB09 New Local Copy     Assertion: V15 == V17 index=#01, mask=0000000000000001
GenTreeNode creates assertion:
               [000192] -A----------              *  ASG       int   
In BB09 New Local Copy     Assertion: V16 == V18 index=#02, mask=0000000000000002

fgMorphCopyBlock (after):
               [000193] -A---+------              *  COMMA     void  
               [000189] -A----------              +--*  ASG       byref 
               [000187] D------N----              |  +--*  LCL_VAR   byref  V15 tmp14        
               [000188] ------------              |  \--*  LCL_VAR   byref  V17 tmp16        
               [000192] -A----------              \--*  ASG       int   
               [000190] D------N----                 +--*  LCL_VAR   int    V16 tmp15        
               [000191] ------------                 \--*  LCL_VAR   int    V18 tmp17        

fgMorphTree BB09, STMT00003 (after)
               [000193] -A---+------              *  COMMA     void  
               [000189] -A----------              +--*  ASG       byref 
               [000187] D------N----              |  +--*  LCL_VAR   byref  V15 tmp14        
               [000188] ------------              |  \--*  LCL_VAR   byref  V17 tmp16        
               [000192] -A----------              \--*  ASG       int   
               [000190] D------N----                 +--*  LCL_VAR   int    V16 tmp15        
               [000191] ------------                 \--*  LCL_VAR   int    V18 tmp17        

fgMorphTree BB09, STMT00004 (before)
               [000011] --C-G-------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer.TokenizeLine
               [000007] ------------ this in rcx  +--*  LCL_VAR   ref    V02 tmp1         
               [000016] n----------- arg1         \--*  OBJ       struct<System.ReadOnlySpan`1[Char], 16>
               [000015] ------------                 \--*  ADDR      byref 
               [000014] -------N----                    \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V03 tmp2         
                                                        \--*    byref  V03._pointer (offs=0x00) -> V15 tmp14        
                                                        \--*    int    V03._length (offs=0x08) -> V16 tmp15        

Rejecting tail call in morph for call [000011]: Local address taken V07
Initializing arg info for 11.CALL:
ArgTable for 11.CALL after fgInitArgInfo:
fgArgTabEntry[arg 0 7.LCL_VAR ref (By ref), 1 reg: rcx, byteAlignment=8]
fgArgTabEntry[arg 1 16.OBJ struct (By ref), 1 reg: rdx, byteAlignment=8, isStruct]

Morphing args for 11.CALL:
making an outgoing copy for struct arg

lvaGrabTemp returning 24 (V24 tmp23) called for by-value struct argument.
fgMorphCopyBlock:
fgMorphBlkNode for dst tree, before:
               [000194] D------N----              *  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V24 tmp23        
fgMorphBlkNode after:
               [000194] D------N----              *  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V24 tmp23        
fgMorphBlkNode for src tree, before:
               [000014] -----+-N----              *  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V03 tmp2         
                                                  *    byref  V03._pointer (offs=0x00) -> V15 tmp14        
                                                  *    int    V03._length (offs=0x08) -> V16 tmp15        
fgMorphBlkNode after:
               [000014] -----+-N----              *  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V03 tmp2         
                                                  *    byref  V03._pointer (offs=0x00) -> V15 tmp14        
                                                  *    int    V03._length (offs=0x08) -> V16 tmp15        
block assignment to morph:
               [000195] -A----------              *  ASG       struct (copy)
               [000194] D------N----              +--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16> V24 tmp23        
               [000014] -----+-N----              \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(P) V03 tmp2         
                                                  \--*    byref  V03._pointer (offs=0x00) -> V15 tmp14        
                                                  \--*    int    V03._length (offs=0x08) -> V16 tmp15        
 (srcDoFldAsg=true) using field by field assignments.

Local V24 should not be enregistered because: written in a block op

lvaGrabTemp returning 25 (V25 tmp24) called for BlockOp address local.

Local V24 should not be enregistered because: it is address exposed

fgAddFieldSeqForZeroOffset for Fseq[_pointer]
addr (Before)
               [000201] ------------                LCL_VAR   byref 
     (After)
               [000201] ------------                LCL_VAR   byref  Zero Fseq[_pointer]

fgMorphCopyBlock (after):
               [000212] -A---+------              *  COMMA     void  
               [000205] -A----------              +--*  COMMA     void  
               [000200] -A----------              |  +--*  ASG       byref 
               [000199] D------N----              |  |  +--*  LCL_VAR   byref  V25 tmp24        
               [000197] -----+------              |  |  \--*  ADDR      byref 
               [000198] -----+-N----              |  |     \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(AX) V24 tmp23        
               [000204] -A----------              |  \--*  ASG       byref 
               [000202] *------N----              |     +--*  IND       byref 
               [000201] ------------              |     |  \--*  LCL_VAR   byref  V25 tmp24         Zero Fseq[_pointer]
               [000203] -------N----              |     \--*  LCL_VAR   byref  V15 tmp14        
               [000211] -A----------              \--*  ASG       int   
               [000209] *------N----                 +--*  IND       int   
               [000208] ------------                 |  \--*  ADD       byref 
               [000206] ------------                 |     +--*  LCL_VAR   byref  V25 tmp24        
               [000207] ------------                 |     \--*  CNS_INT   long   8 Fseq[_length]
               [000210] -------N----                 \--*  LCL_VAR   int    V16 tmp15        
argSlots=2, preallocatedArgCount=4, nextSlotNum=4, nextSlotByteOffset=32, outgoingArgSpaceSize=32

Sorting the arguments:
Argument with 'side effect'...
               [000007] -----+------              *  LCL_VAR   ref    V02 tmp1         

lvaGrabTemp returning 26 (V26 tmp25) called for argument with side effect.

  Evaluate to a temp:
               [000214] -A--------L-              *  ASG       ref   
               [000213] D------N----              +--*  LCL_VAR   ref    V26 tmp25        
               [000007] -----+------              \--*  LCL_VAR   ref    V02 tmp1         

Local V24 should not be enregistered because: it is address exposed

Shuffled argument table:    rcx rdx 
ArgTable for 11.CALL after fgMorphArgs:
fgArgTabEntry[arg 0 215.LCL_VAR ref (By ref), 1 reg: rcx, byteAlignment=8, lateArgInx=0, tmpNum=V26, isTmp, processed]
fgArgTabEntry[arg 1 217.ADDR struct (By ref), 1 reg: rdx, byteAlignment=8, lateArgInx=1, tmpNum=V24, isTmp, processed, isStruct]


fgMorphTree BB09, STMT00004 (after)
               [000011] -ACXG+------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer.TokenizeLine
               [000214] -A--------L- this SETUP   +--*  ASG       ref   
               [000213] D------N----              |  +--*  LCL_VAR   ref    V26 tmp25        
               [000007] -----+------              |  \--*  LCL_VAR   ref    V02 tmp1         
               [000212] -A---+----L- arg1 SETUP   +--*  COMMA     void  
               [000205] -A----------              |  +--*  COMMA     void  
               [000200] -A----------              |  |  +--*  ASG       byref 
               [000199] D------N----              |  |  |  +--*  LCL_VAR   byref  V25 tmp24        
               [000197] -----+------              |  |  |  \--*  ADDR      byref 
               [000198] -----+-N----              |  |  |     \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(AX) V24 tmp23        
               [000204] -A----------              |  |  \--*  ASG       byref 
               [000202] *------N----              |  |     +--*  IND       byref 
               [000201] ------------              |  |     |  \--*  LCL_VAR   byref  V25 tmp24         Zero Fseq[_pointer]
               [000203] -------N----              |  |     \--*  LCL_VAR   byref  V15 tmp14        
               [000211] -A----------              |  \--*  ASG       int   
               [000209] *------N----              |     +--*  IND       int   
               [000208] ------------              |     |  \--*  ADD       byref 
               [000206] ------------              |     |     +--*  LCL_VAR   byref  V25 tmp24        
               [000207] ------------              |     |     \--*  CNS_INT   long   8 Fseq[_length]
               [000210] -------N----              |     \--*  LCL_VAR   int    V16 tmp15        
               [000215] ------------ this in rcx  +--*  LCL_VAR   ref    V26 tmp25        
               [000217] ------------ arg1 in rdx  \--*  ADDR      byref 
               [000216] -------N----                 \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(AX) V24 tmp23        

fgMorphTree BB09, STMT00005 (before)
               [000017] ------------              *  RETURN    void  

*************** Finishing PHASE Morph - Global
Trees after Morph - Global

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)-> BB04 ( cond )                     i label target hascall newobj 
BB03 [0007]  1       BB01                  1        [006..007)-> BB09 (always)                     i 
BB04 [0008]  1       BB01                  1        [006..007)-> BB07 ( cond )                     i label target idxlen nullcheck 
BB06 [0014]  1       BB04                  0.50     [006..007)                                     i hascall gcsafe 
BB07 [0015]  2       BB04,BB06             1        [006..007)                                     i label target idxlen nullcheck 
BB09 [0009]  2       BB03,BB07             1        [???..???)        (return)                     internal label target hascall gcsafe newobj 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..012) -> BB04 (cond), preds={} succs={BB03,BB04}

***** BB01
STMT00000 (IL 0x000...0x011)
               [000004] -AC--+------              *  ASG       ref   
               [000003] D----+-N----              +--*  LCL_VAR   ref    V02 tmp1         
               [000002] --C--+------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST
               [000001] H----+------ arg0 in rcx     \--*  CNS_INT(h) long   0xd1ffab1e token

***** BB01
STMT00006 (IL   ???...  ???)
               [000021] -AC--+------              *  ASG       ref   
               [000020] D----+-N----              +--*  LCL_VAR   ref    V04 tmp3         
               [000019] --C--+------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST
               [000018] H----+------ arg0 in rcx     \--*  CNS_INT(h) long   0xd1ffab1e token

***** BB01
STMT00013 (IL   ???...  ???)
               [000039] -ACXG+------              *  ASG       ref   
               [000038] ---XG+-N----              +--*  IND       ref   
               [000140] -----+------              |  \--*  ADD       byref 
               [000035] -----+------              |     +--*  LCL_VAR   ref    V04 tmp3         
               [000139] -----+------              |     \--*  CNS_INT   long   8 field offset Fseq[_array]
               [000047] --CXG+------              \--*  COMMA     ref   
               [000046] H-CXG+------                 +--*  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS
               [000044] -----+------ arg0 in rcx     |  +--*  CNS_INT   long   0x7ffa40fb0028
               [000045] -----+------ arg1 in rdx     |  \--*  CNS_INT   int    6
               [000042] n---G+------                 \--*  IND       ref   
               [000143] I----+------                    \--*  CNS_INT(h) long   0xd1ffab1e static Fseq[Value]

***** BB01
STMT00008 (IL   ???...  ???)
               [000026] -A-XG+------              *  ASG       ref   
               [000025] ---XG+-N----              +--*  IND       ref   
               [000145] -----+------              |  \--*  ADD       byref 
               [000005] -----+------              |     +--*  LCL_VAR   ref    V02 tmp1         
               [000144] -----+------              |     \--*  CNS_INT   long   16 field offset Fseq[_tokensBuffer]
               [000024] -----+------              \--*  LCL_VAR   ref    V04 tmp3         

***** BB01
STMT00010 (IL   ???...  ???)
               [000032] -A-XG+------              *  ASG       ref   
               [000031] ---XG+-N----              +--*  IND       ref   
               [000147] -----+------              |  \--*  ADD       byref 
               [000029] -----+------              |     +--*  LCL_VAR   ref    V02 tmp1         
               [000146] -----+------              |     \--*  CNS_INT   long   8 field offset Fseq[_reader]
               [000030] -----+------              \--*  CNS_INT   ref    null

***** BB01
STMT00014 (IL 0x006...  ???)
               [000052] -----+------              *  JTRUE     void  
               [000051] J----+-N----              \--*  NE        int   
               [000008] -----+------                 +--*  LCL_VAR   ref    V00 arg0         
               [000050] -----+------                 \--*  CNS_INT   ref    null

------------ BB03 [006..007) -> BB09 (always), preds={BB01} succs={BB09}

***** BB03
STMT00019 (IL 0x006...  ???)
               [000154] -A---+------              *  COMMA     void  
               [000150] -A----------              +--*  ASG       byref 
               [000148] D------N----              |  +--*  LCL_VAR   byref  V21 tmp20        
               [000149] ------------              |  \--*  CNS_INT   byref  0
               [000153] -A----------              \--*  ASG       int   
               [000151] D------N----                 +--*  LCL_VAR   int    V22 tmp21        
               [000152] ------------                 \--*  CNS_INT   int    0

***** BB03
STMT00020 (IL 0x006...  ???)
               [000161] -A---+------              *  COMMA     void  
               [000157] -A----------              +--*  ASG       byref 
               [000155] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        
               [000156] ------------              |  \--*  LCL_VAR   byref  V21 tmp20        
               [000160] -A----------              \--*  ASG       int   
               [000158] D------N----                 +--*  LCL_VAR   int    V18 tmp17        
               [000159] ------------                 \--*  LCL_VAR   int    V22 tmp21        

------------ BB04 [006..007) -> BB07 (cond), preds={BB01} succs={BB06,BB07}

***** BB04
STMT00021 (IL 0x006...  ???)
               [000086] ---X-+------              *  NULLCHECK byte  
               [000085] -----+------              \--*  LCL_VAR   ref    V00 arg0         

***** BB04
STMT00016 (IL 0x006...  ???)
               [000168] -A---+------              *  COMMA     void  
               [000164] -A----------              +--*  ASG       byref 
               [000162] D------N----              |  +--*  LCL_VAR   byref  V19 tmp18        
               [000163] ------------              |  \--*  CNS_INT   byref  0
               [000167] -A----------              \--*  ASG       int   
               [000165] D------N----                 +--*  LCL_VAR   int    V20 tmp19        
               [000166] ------------                 \--*  CNS_INT   int    0

***** BB04
STMT00026 (IL 0x006...  ???)
               [000112] -A--G+------              *  ASG       byref 
               [000111] D----+-N----              +--*  LCL_VAR   byref  V09 tmp8         
               [000173] -----+------              \--*  ADD       byref 
               [000171] -----+------                 +--*  LCL_VAR   ref    V00 arg0         
               [000172] -----+------                 \--*  CNS_INT   long   12 field offset Fseq[_firstChar]

***** BB04
STMT00027 (IL 0x006...  ???)
               [000114] -A-X-+------              *  ASG       int   
               [000113] D----+-N----              +--*  LCL_VAR   int    V08 tmp7         
               [000057] ---X-+------              \--*  ARR_LENGTH int   
               [000056] -----+------                 \--*  LCL_VAR   ref    V00 arg0         

***** BB04
STMT00031 (IL 0x006...  ???)
               [000133] -A--G+------              *  ASG       ref   
               [000132] D----+-N----              +--*  LCL_VAR   ref    V13 tmp12        
               [000119] #---G+------              \--*  IND       ref   
               [000118] H----+------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]

***** BB04
STMT00032 (IL 0x006...  ???)
               [000135] -A--G+------              *  ASG       ref   
               [000134] D----+-N----              +--*  LCL_VAR   ref    V14 tmp13        
               [000121] #---G+------              \--*  IND       ref   
               [000120] H----+------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]

***** BB04
STMT00029 (IL 0x006...  ???)
               [000128] -----+------              *  JTRUE     void  
               [000090] J----+-N----              \--*  GE        int   
               [000088] -----+------                 +--*  LCL_VAR   int    V08 tmp7         
               [000089] -----+------                 \--*  CNS_INT   int    0

------------ BB06 [006..007), preds={BB04} succs={BB07}

***** BB06
STMT00030 (IL 0x006...  ???)
               [000131] --CXG+------              *  CALL      void   System.Diagnostics.Debug.Fail
               [000129] -----+------ arg0 in rcx  +--*  LCL_VAR   ref    V13 tmp12        
               [000130] -----+------ arg1 in rdx  \--*  LCL_VAR   ref    V14 tmp13        

------------ BB07 [006..007), preds={BB04,BB06} succs={BB09}

***** BB07
STMT00023 (IL 0x006...  ???)
               [000100] -A---+------              *  ASG       byref 
               [000099] D----+-N----              +--*  LCL_VAR   byref  V23 tmp22        
               [000096] -----+------              \--*  LCL_VAR   byref  V09 tmp8         

***** BB07
STMT00024 (IL 0x006...  ???)
               [000179] -A---+------              *  ASG       byref 
               [000177] D------N----              +--*  LCL_VAR   byref  V19 tmp18        
               [000178] -------N----              \--*  LCL_VAR   byref  V23 tmp22        

***** BB07
STMT00025 (IL 0x006...  ???)
               [000110] -A---+------              *  ASG       int   
               [000109] D----+-N----              +--*  LCL_VAR   int    V20 tmp19        
               [000108] -----+------              \--*  LCL_VAR   int    V08 tmp7         

***** BB07
STMT00018 (IL 0x006...  ???)
               [000186] -A---+------              *  COMMA     void  
               [000182] -A----------              +--*  ASG       byref 
               [000180] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        
               [000181] ------------              |  \--*  LCL_VAR   byref  V19 tmp18        
               [000185] -A----------              \--*  ASG       int   
               [000183] D------N----                 +--*  LCL_VAR   int    V18 tmp17        
               [000184] ------------                 \--*  LCL_VAR   int    V20 tmp19        

------------ BB09 [???..???) (return), preds={BB03,BB07} succs={}

***** BB09
STMT00003 (IL   ???...  ???)
               [000193] -A---+------              *  COMMA     void  
               [000189] -A----------              +--*  ASG       byref 
               [000187] D------N----              |  +--*  LCL_VAR   byref  V15 tmp14        
               [000188] ------------              |  \--*  LCL_VAR   byref  V17 tmp16        
               [000192] -A----------              \--*  ASG       int   
               [000190] D------N----                 +--*  LCL_VAR   int    V16 tmp15        
               [000191] ------------                 \--*  LCL_VAR   int    V18 tmp17        

***** BB09
STMT00004 (IL   ???...  ???)
               [000011] -ACXG+------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer.TokenizeLine
               [000214] -A--------L- this SETUP   +--*  ASG       ref   
               [000213] D------N----              |  +--*  LCL_VAR   ref    V26 tmp25        
               [000007] -----+------              |  \--*  LCL_VAR   ref    V02 tmp1         
               [000212] -A---+----L- arg1 SETUP   +--*  COMMA     void  
               [000205] -A----------              |  +--*  COMMA     void  
               [000200] -A----------              |  |  +--*  ASG       byref 
               [000199] D------N----              |  |  |  +--*  LCL_VAR   byref  V25 tmp24        
               [000197] -----+------              |  |  |  \--*  ADDR      byref 
               [000198] -----+-N----              |  |  |     \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(AX) V24 tmp23        
               [000204] -A----------              |  |  \--*  ASG       byref 
               [000202] *------N----              |  |     +--*  IND       byref 
               [000201] ------------              |  |     |  \--*  LCL_VAR   byref  V25 tmp24         Zero Fseq[_pointer]
               [000203] -------N----              |  |     \--*  LCL_VAR   byref  V15 tmp14        
               [000211] -A----------              |  \--*  ASG       int   
               [000209] *------N----              |     +--*  IND       int   
               [000208] ------------              |     |  \--*  ADD       byref 
               [000206] ------------              |     |     +--*  LCL_VAR   byref  V25 tmp24        
               [000207] ------------              |     |     \--*  CNS_INT   long   8 Fseq[_length]
               [000210] -------N----              |     \--*  LCL_VAR   int    V16 tmp15        
               [000215] ------------ this in rcx  +--*  LCL_VAR   ref    V26 tmp25        
               [000217] ------------ arg1 in rdx  \--*  ADDR      byref 
               [000216] -------N----                 \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(AX) V24 tmp23        

***** BB09
STMT00005 (IL 0x011...  ???)
               [000017] -----+------              *  RETURN    void  

-------------------------------------------------------------------------------------------------------------------
*************** In fgDebugCheckBBlist

*************** Starting PHASE GS Cookie
No GS security needed

*************** Finishing PHASE GS Cookie

*************** Starting PHASE Compute edge weights (1, false)
*************** In fgComputeBlockAndEdgeWeights()

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)-> BB04 ( cond )                     i label target hascall newobj 
BB03 [0007]  1       BB01                  1        [006..007)-> BB09 (always)                     i 
BB04 [0008]  1       BB01                  1        [006..007)-> BB07 ( cond )                     i label target idxlen nullcheck 
BB06 [0014]  1       BB04                  0.50     [006..007)                                     i hascall gcsafe 
BB07 [0015]  2       BB04,BB06             1        [006..007)                                     i label target idxlen nullcheck 
BB09 [0009]  2       BB03,BB07             1        [???..???)        (return)                     internal label target hascall gcsafe newobj 
-----------------------------------------------------------------------------------------------------------------------------------------

 -- no profile data, so using default called count
fgComputeEdgeWeights() found inconsistent profile data, not using the edge weights

*************** Finishing PHASE Compute edge weights (1, false)

*************** Starting PHASE Create EH funclets
*************** In fgCreateFunclets()

After fgCreateFunclets()
-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)-> BB04 ( cond )                     i label target hascall newobj 
BB03 [0007]  1       BB01                  1        [006..007)-> BB09 (always)                     i 
BB04 [0008]  1       BB01                  1        [006..007)-> BB07 ( cond )                     i label target idxlen nullcheck 
BB06 [0014]  1       BB04                  0.50     [006..007)                                     i hascall gcsafe 
BB07 [0015]  2       BB04,BB06             1        [006..007)                                     i label target idxlen nullcheck 
BB09 [0009]  2       BB03,BB07             1        [???..???)        (return)                     internal label target hascall gcsafe newobj 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table is empty
*************** In fgDebugCheckBBlist

*************** Finishing PHASE Create EH funclets

*************** Starting PHASE Optimize layout
*************** In optOptimizeLayout()

***************  Exception Handling table is empty
*************** In fgDebugCheckBBlist

*************** In fgUpdateFlowGraph()
Before updating the flow graph:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)-> BB04 ( cond )                     i label target hascall newobj 
BB03 [0007]  1       BB01                  1        [006..007)-> BB09 (always)                     i 
BB04 [0008]  1       BB01                  1        [006..007)-> BB07 ( cond )                     i label target idxlen nullcheck 
BB06 [0014]  1       BB04                  0.50     [006..007)                                     i hascall gcsafe 
BB07 [0015]  2       BB04,BB06             1        [006..007)                                     i label target idxlen nullcheck 
BB09 [0009]  2       BB03,BB07             1        [???..???)        (return)                     internal label target hascall gcsafe newobj 
-----------------------------------------------------------------------------------------------------------------------------------------

*************** In fgDebugCheckBBlist

*************** In fgExpandRarelyRunBlocks()
*************** In fgReorderBlocks()

Initial BasicBlocks
-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)-> BB04 ( cond )                     i label target hascall newobj 
BB03 [0007]  1       BB01                  1        [006..007)-> BB09 (always)                     i 
BB04 [0008]  1       BB01                  1        [006..007)-> BB07 ( cond )                     i label target idxlen nullcheck 
BB06 [0014]  1       BB04                  0.50     [006..007)                                     i hascall gcsafe 
BB07 [0015]  2       BB04,BB06             1        [006..007)                                     i label target idxlen nullcheck 
BB09 [0009]  2       BB03,BB07             1        [???..???)        (return)                     internal label target hascall gcsafe newobj 
-----------------------------------------------------------------------------------------------------------------------------------------


*************** In fgUpdateFlowGraph()
Before updating the flow graph:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)-> BB04 ( cond )                     i label target hascall newobj 
BB03 [0007]  1       BB01                  1        [006..007)-> BB09 (always)                     i 
BB04 [0008]  1       BB01                  1        [006..007)-> BB07 ( cond )                     i label target idxlen nullcheck 
BB06 [0014]  1       BB04                  0.50     [006..007)                                     i hascall gcsafe 
BB07 [0015]  2       BB04,BB06             1        [006..007)                                     i label target idxlen nullcheck 
BB09 [0009]  2       BB03,BB07             1        [???..???)        (return)                     internal label target hascall gcsafe newobj 
-----------------------------------------------------------------------------------------------------------------------------------------

*************** In fgDebugCheckBBlist

*************** Finishing PHASE Optimize layout

*************** Starting PHASE Compute blocks reachability
*************** In fgComputeReachability
*************** In fgDebugCheckBBlist

Renumbering the basic blocks for fgComputeReachability pass #1

*************** Before renumbering the basic blocks

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)-> BB04 ( cond )                     i label target hascall newobj 
BB03 [0007]  1       BB01                  1        [006..007)-> BB09 (always)                     i 
BB04 [0008]  1       BB01                  1        [006..007)-> BB07 ( cond )                     i label target idxlen nullcheck 
BB06 [0014]  1       BB04                  0.50     [006..007)                                     i hascall gcsafe 
BB07 [0015]  2       BB04,BB06             1        [006..007)                                     i label target idxlen nullcheck 
BB09 [0009]  2       BB03,BB07             1        [???..???)        (return)                     internal label target hascall gcsafe newobj 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table is empty
Renumber BB03 to BB02
Renumber BB04 to BB03
Renumber BB06 to BB04
Renumber BB07 to BB05
Renumber BB09 to BB06

*************** After renumbering the basic blocks

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)-> BB03 ( cond )                     i label target hascall newobj 
BB02 [0007]  1       BB01                  1        [006..007)-> BB06 (always)                     i 
BB03 [0008]  1       BB01                  1        [006..007)-> BB05 ( cond )                     i label target idxlen nullcheck 
BB04 [0014]  1       BB03                  0.50     [006..007)                                     i hascall gcsafe 
BB05 [0015]  2       BB03,BB04             1        [006..007)                                     i label target idxlen nullcheck 
BB06 [0009]  2       BB02,BB05             1        [???..???)        (return)                     internal label target hascall gcsafe newobj 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table is empty

New BlockSet epoch 3, # of blocks (including unused BB00): 7, bitset array size: 1 (short)
Enter blocks: BB01 

After computing reachability sets:
------------------------------------------------
BBnum  Reachable by 
------------------------------------------------
BB01 : BB01 
BB02 : BB01 BB02 
BB03 : BB01 BB03 
BB04 : BB01 BB03 BB04 
BB05 : BB01 BB03 BB04 BB05 
BB06 : BB01 BB02 BB03 BB04 BB05 BB06 

After computing reachability:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)-> BB03 ( cond )                     i label target hascall newobj 
BB02 [0007]  1       BB01                  1        [006..007)-> BB06 (always)                     i 
BB03 [0008]  1       BB01                  1        [006..007)-> BB05 ( cond )                     i label target idxlen nullcheck 
BB04 [0014]  1       BB03                  0.50     [006..007)                                     i hascall gcsafe 
BB05 [0015]  2       BB03,BB04             1        [006..007)                                     i label target idxlen nullcheck 
BB06 [0009]  2       BB02,BB05             1        [???..???)        (return)                     internal label target hascall gcsafe newobj 
-----------------------------------------------------------------------------------------------------------------------------------------

*************** In fgDebugCheckBBlist
*************** In fgComputeDoms
*************** In fgDebugCheckBBlist

Dominator computation start blocks (those blocks with no incoming edges):
BB01 
------------------------------------------------
BBnum  Dominated by
------------------------------------------------
BB01:  BB01 
BB02:  BB02 BB01 
BB03:  BB03 BB01 
BB04:  BB04 BB03 BB01 
BB05:  BB05 BB03 BB01 
BB06:  BB06 BB01 

Inside fgBuildDomTree

After computing the Dominance Tree:
BB01 : BB06 BB03 BB02 
BB03 : BB05 BB04 


After numbering the dominator tree:
BB01: pre=01, post=06
BB02: pre=06, post=05
BB03: pre=03, post=04
BB04: pre=05, post=03
BB05: pre=04, post=02
BB06: pre=02, post=01

*************** Finishing PHASE Compute blocks reachability

*************** Starting PHASE Optimize loops
*************** In optOptimizeLoops()

After optSetBlockWeights:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)-> BB03 ( cond )                     i label target hascall newobj 
BB02 [0007]  1       BB01                  0.50     [006..007)-> BB06 (always)                     i 
BB03 [0008]  1       BB01                  0.50     [006..007)-> BB05 ( cond )                     i label target idxlen nullcheck 
BB04 [0014]  1       BB03                  0.25     [006..007)                                     i hascall gcsafe 
BB05 [0015]  2       BB03,BB04             0.50     [006..007)                                     i label target idxlen nullcheck 
BB06 [0009]  2       BB02,BB05             1        [???..???)        (return)                     internal label target hascall gcsafe newobj 
-----------------------------------------------------------------------------------------------------------------------------------------

*************** In fgDebugCheckBBlist

*************** Finishing PHASE Optimize loops

*************** Starting PHASE Clone loops

*************** In optCloneLoops()

*************** Finishing PHASE Clone loops

*************** Starting PHASE Unroll loops

*************** Finishing PHASE Unroll loops

*************** Starting PHASE Mark local vars

*************** In lvaMarkLocalVars()
*** lvaComputeRefCounts ***

*** lvaComputeRefCounts -- explicit counts ***

*** marking local variables in block BB01 (weight=1   )
STMT00000 (IL 0x000...0x011)
               [000004] -AC--+------              *  ASG       ref   
               [000003] D----+-N----              +--*  LCL_VAR   ref    V02 tmp1         
               [000002] --C--+------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST
               [000001] H----+------ arg0 in rcx     \--*  CNS_INT(h) long   0xd1ffab1e token
New refCnts for V02: refCnt =  1, refCntWtd = 2   
STMT00006 (IL   ???...  ???)
               [000021] -AC--+------              *  ASG       ref   
               [000020] D----+-N----              +--*  LCL_VAR   ref    V04 tmp3         
               [000019] --C--+------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST
               [000018] H----+------ arg0 in rcx     \--*  CNS_INT(h) long   0xd1ffab1e token
New refCnts for V04: refCnt =  1, refCntWtd = 2   
STMT00013 (IL   ???...  ???)
               [000039] -ACXG+------              *  ASG       ref   
               [000038] ---XG+-N----              +--*  IND       ref   
               [000140] -----+------              |  \--*  ADD       byref 
               [000035] -----+------              |     +--*  LCL_VAR   ref    V04 tmp3         
               [000139] -----+------              |     \--*  CNS_INT   long   8 field offset Fseq[_array]
               [000047] --CXG+------              \--*  COMMA     ref   
               [000046] H-CXG+------                 +--*  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS
               [000044] -----+------ arg0 in rcx     |  +--*  CNS_INT   long   0x7ffa40fb0028
               [000045] -----+------ arg1 in rdx     |  \--*  CNS_INT   int    6
               [000042] n---G+------                 \--*  IND       ref   
               [000143] I----+------                    \--*  CNS_INT(h) long   0xd1ffab1e static Fseq[Value]
New refCnts for V04: refCnt =  2, refCntWtd = 4   
STMT00008 (IL   ???...  ???)
               [000026] -A-XG+------              *  ASG       ref   
               [000025] ---XG+-N----              +--*  IND       ref   
               [000145] -----+------              |  \--*  ADD       byref 
               [000005] -----+------              |     +--*  LCL_VAR   ref    V02 tmp1         
               [000144] -----+------              |     \--*  CNS_INT   long   16 field offset Fseq[_tokensBuffer]
               [000024] -----+------              \--*  LCL_VAR   ref    V04 tmp3         
New refCnts for V02: refCnt =  2, refCntWtd = 4   
New refCnts for V04: refCnt =  3, refCntWtd = 6   
STMT00010 (IL   ???...  ???)
               [000032] -A-XG+------              *  ASG       ref   
               [000031] ---XG+-N----              +--*  IND       ref   
               [000147] -----+------              |  \--*  ADD       byref 
               [000029] -----+------              |     +--*  LCL_VAR   ref    V02 tmp1         
               [000146] -----+------              |     \--*  CNS_INT   long   8 field offset Fseq[_reader]
               [000030] -----+------              \--*  CNS_INT   ref    null
New refCnts for V02: refCnt =  3, refCntWtd = 6   
STMT00014 (IL 0x006...  ???)
               [000052] -----+------              *  JTRUE     void  
               [000051] J----+-N----              \--*  NE        int   
               [000008] -----+------                 +--*  LCL_VAR   ref    V00 arg0         
               [000050] -----+------                 \--*  CNS_INT   ref    null
New refCnts for V00: refCnt =  1, refCntWtd = 1   

*** marking local variables in block BB02 (weight=0.50)
STMT00019 (IL 0x006...  ???)
               [000154] -A---+------              *  COMMA     void  
               [000150] -A----------              +--*  ASG       byref 
               [000148] D------N----              |  +--*  LCL_VAR   byref  V21 tmp20        
               [000149] ------------              |  \--*  CNS_INT   byref  0
               [000153] -A----------              \--*  ASG       int   
               [000151] D------N----                 +--*  LCL_VAR   int    V22 tmp21        
               [000152] ------------                 \--*  CNS_INT   int    0
New refCnts for V21: refCnt =  1, refCntWtd = 0.50
New refCnts for V22: refCnt =  1, refCntWtd = 0.50
STMT00020 (IL 0x006...  ???)
               [000161] -A---+------              *  COMMA     void  
               [000157] -A----------              +--*  ASG       byref 
               [000155] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        
               [000156] ------------              |  \--*  LCL_VAR   byref  V21 tmp20        
               [000160] -A----------              \--*  ASG       int   
               [000158] D------N----                 +--*  LCL_VAR   int    V18 tmp17        
               [000159] ------------                 \--*  LCL_VAR   int    V22 tmp21        
New refCnts for V17: refCnt =  1, refCntWtd = 0.50
New refCnts for V21: refCnt =  2, refCntWtd = 1   
New refCnts for V18: refCnt =  1, refCntWtd = 0.50
New refCnts for V22: refCnt =  2, refCntWtd = 1   

*** marking local variables in block BB03 (weight=0.50)
STMT00021 (IL 0x006...  ???)
               [000086] ---X-+------              *  NULLCHECK byte  
               [000085] -----+------              \--*  LCL_VAR   ref    V00 arg0         
New refCnts for V00: refCnt =  2, refCntWtd = 1.50
STMT00016 (IL 0x006...  ???)
               [000168] -A---+------              *  COMMA     void  
               [000164] -A----------              +--*  ASG       byref 
               [000162] D------N----              |  +--*  LCL_VAR   byref  V19 tmp18        
               [000163] ------------              |  \--*  CNS_INT   byref  0
               [000167] -A----------              \--*  ASG       int   
               [000165] D------N----                 +--*  LCL_VAR   int    V20 tmp19        
               [000166] ------------                 \--*  CNS_INT   int    0
New refCnts for V19: refCnt =  1, refCntWtd = 0.50
New refCnts for V20: refCnt =  1, refCntWtd = 0.50
STMT00026 (IL 0x006...  ???)
               [000112] -A--G+------              *  ASG       byref 
               [000111] D----+-N----              +--*  LCL_VAR   byref  V09 tmp8         
               [000173] -----+------              \--*  ADD       byref 
               [000171] -----+------                 +--*  LCL_VAR   ref    V00 arg0         
               [000172] -----+------                 \--*  CNS_INT   long   12 field offset Fseq[_firstChar]
New refCnts for V09: refCnt =  1, refCntWtd = 1   
New refCnts for V00: refCnt =  3, refCntWtd = 2   
STMT00027 (IL 0x006...  ???)
               [000114] -A-X-+------              *  ASG       int   
               [000113] D----+-N----              +--*  LCL_VAR   int    V08 tmp7         
               [000057] ---X-+------              \--*  ARR_LENGTH int   
               [000056] -----+------                 \--*  LCL_VAR   ref    V00 arg0         
New refCnts for V08: refCnt =  1, refCntWtd = 1   
New refCnts for V00: refCnt =  4, refCntWtd = 2.50
STMT00031 (IL 0x006...  ???)
               [000133] -A--G+------              *  ASG       ref   
               [000132] D----+-N----              +--*  LCL_VAR   ref    V13 tmp12        
               [000119] #---G+------              \--*  IND       ref   
               [000118] H----+------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]
New refCnts for V13: refCnt =  1, refCntWtd = 1   
STMT00032 (IL 0x006...  ???)
               [000135] -A--G+------              *  ASG       ref   
               [000134] D----+-N----              +--*  LCL_VAR   ref    V14 tmp13        
               [000121] #---G+------              \--*  IND       ref   
               [000120] H----+------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]
New refCnts for V14: refCnt =  1, refCntWtd = 1   
STMT00029 (IL 0x006...  ???)
               [000128] -----+------              *  JTRUE     void  
               [000090] J----+-N----              \--*  GE        int   
               [000088] -----+------                 +--*  LCL_VAR   int    V08 tmp7         
               [000089] -----+------                 \--*  CNS_INT   int    0
New refCnts for V08: refCnt =  2, refCntWtd = 2   

*** marking local variables in block BB04 (weight=0.25)
STMT00030 (IL 0x006...  ???)
               [000131] --CXG+------              *  CALL      void   System.Diagnostics.Debug.Fail
               [000129] -----+------ arg0 in rcx  +--*  LCL_VAR   ref    V13 tmp12        
               [000130] -----+------ arg1 in rdx  \--*  LCL_VAR   ref    V14 tmp13        
New refCnts for V13: refCnt =  2, refCntWtd = 1.50
New refCnts for V14: refCnt =  2, refCntWtd = 1.50

*** marking local variables in block BB05 (weight=0.50)
STMT00023 (IL 0x006...  ???)
               [000100] -A---+------              *  ASG       byref 
               [000099] D----+-N----              +--*  LCL_VAR   byref  V23 tmp22        
               [000096] -----+------              \--*  LCL_VAR   byref  V09 tmp8         
New refCnts for V23: refCnt =  1, refCntWtd = 0.50
New refCnts for V09: refCnt =  2, refCntWtd = 2   
STMT00024 (IL 0x006...  ???)
               [000179] -A---+------              *  ASG       byref 
               [000177] D------N----              +--*  LCL_VAR   byref  V19 tmp18        
               [000178] -------N----              \--*  LCL_VAR   byref  V23 tmp22        
New refCnts for V19: refCnt =  2, refCntWtd = 1   
New refCnts for V23: refCnt =  2, refCntWtd = 1   
STMT00025 (IL 0x006...  ???)
               [000110] -A---+------              *  ASG       int   
               [000109] D----+-N----              +--*  LCL_VAR   int    V20 tmp19        
               [000108] -----+------              \--*  LCL_VAR   int    V08 tmp7         
New refCnts for V20: refCnt =  2, refCntWtd = 1   
New refCnts for V08: refCnt =  3, refCntWtd = 3   
STMT00018 (IL 0x006...  ???)
               [000186] -A---+------              *  COMMA     void  
               [000182] -A----------              +--*  ASG       byref 
               [000180] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        
               [000181] ------------              |  \--*  LCL_VAR   byref  V19 tmp18        
               [000185] -A----------              \--*  ASG       int   
               [000183] D------N----                 +--*  LCL_VAR   int    V18 tmp17        
               [000184] ------------                 \--*  LCL_VAR   int    V20 tmp19        
New refCnts for V17: refCnt =  2, refCntWtd = 1   
New refCnts for V19: refCnt =  3, refCntWtd = 1.50
New refCnts for V18: refCnt =  2, refCntWtd = 1   
New refCnts for V20: refCnt =  3, refCntWtd = 1.50

*** marking local variables in block BB06 (weight=1   )
STMT00003 (IL   ???...  ???)
               [000193] -A---+------              *  COMMA     void  
               [000189] -A----------              +--*  ASG       byref 
               [000187] D------N----              |  +--*  LCL_VAR   byref  V15 tmp14        
               [000188] ------------              |  \--*  LCL_VAR   byref  V17 tmp16        
               [000192] -A----------              \--*  ASG       int   
               [000190] D------N----                 +--*  LCL_VAR   int    V16 tmp15        
               [000191] ------------                 \--*  LCL_VAR   int    V18 tmp17        
New refCnts for V15: refCnt =  1, refCntWtd = 1   
New refCnts for V17: refCnt =  3, refCntWtd = 2   
New refCnts for V16: refCnt =  1, refCntWtd = 1   
New refCnts for V18: refCnt =  3, refCntWtd = 2   
STMT00004 (IL   ???...  ???)
               [000011] -ACXG+------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer.TokenizeLine
               [000214] -A--------L- this SETUP   +--*  ASG       ref   
               [000213] D------N----              |  +--*  LCL_VAR   ref    V26 tmp25        
               [000007] -----+------              |  \--*  LCL_VAR   ref    V02 tmp1         
               [000212] -A---+----L- arg1 SETUP   +--*  COMMA     void  
               [000205] -A----------              |  +--*  COMMA     void  
               [000200] -A----------              |  |  +--*  ASG       byref 
               [000199] D------N----              |  |  |  +--*  LCL_VAR   byref  V25 tmp24        
               [000197] -----+------              |  |  |  \--*  ADDR      byref 
               [000198] -----+-N----              |  |  |     \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(AX) V24 tmp23        
               [000204] -A----------              |  |  \--*  ASG       byref 
               [000202] *------N----              |  |     +--*  IND       byref 
               [000201] ------------              |  |     |  \--*  LCL_VAR   byref  V25 tmp24         Zero Fseq[_pointer]
               [000203] -------N----              |  |     \--*  LCL_VAR   byref  V15 tmp14        
               [000211] -A----------              |  \--*  ASG       int   
               [000209] *------N----              |     +--*  IND       int   
               [000208] ------------              |     |  \--*  ADD       byref 
               [000206] ------------              |     |     +--*  LCL_VAR   byref  V25 tmp24        
               [000207] ------------              |     |     \--*  CNS_INT   long   8 Fseq[_length]
               [000210] -------N----              |     \--*  LCL_VAR   int    V16 tmp15        
               [000215] ------------ this in rcx  +--*  LCL_VAR   ref    V26 tmp25        
               [000217] ------------ arg1 in rdx  \--*  ADDR      byref 
               [000216] -------N----                 \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(AX) V24 tmp23        
New refCnts for V26: refCnt =  1, refCntWtd = 2   
New refCnts for V02: refCnt =  4, refCntWtd = 8   
New refCnts for V25: refCnt =  1, refCntWtd = 2   
New refCnts for V24: refCnt =  1, refCntWtd = 2   
New refCnts for V25: refCnt =  2, refCntWtd = 4   
New refCnts for V15: refCnt =  2, refCntWtd = 2   
New refCnts for V25: refCnt =  3, refCntWtd = 6   
New refCnts for V16: refCnt =  2, refCntWtd = 2   
New refCnts for V26: refCnt =  2, refCntWtd = 4   
New refCnts for V24: refCnt =  2, refCntWtd = 4   
STMT00005 (IL 0x011...  ???)
               [000017] -----+------              *  RETURN    void  

*** lvaComputeRefCounts -- implicit counts ***
New refCnts for V00: refCnt =  5, refCntWtd = 3.50
New refCnts for V00: refCnt =  6, refCntWtd = 4.50

*************** In optAddCopies()


*************** Finishing PHASE Mark local vars

*************** Starting PHASE Optimize bools
*************** In optOptimizeBools()
*************** In fgDebugCheckBBlist

*************** Finishing PHASE Optimize bools

*************** Starting PHASE Find oper order
*************** In fgFindOperOrder()

*************** Finishing PHASE Find oper order

*************** Starting PHASE Set block order
*************** In fgSetBlockOrder()
The biggest BB has   23 tree nodes

*************** Finishing PHASE Set block order
Trees before Build SSA representation

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)-> BB03 ( cond )                     i label target hascall newobj 
BB02 [0007]  1       BB01                  0.50     [006..007)-> BB06 (always)                     i 
BB03 [0008]  1       BB01                  0.50     [006..007)-> BB05 ( cond )                     i label target idxlen nullcheck 
BB04 [0014]  1       BB03                  0.25     [006..007)                                     i hascall gcsafe 
BB05 [0015]  2       BB03,BB04             0.50     [006..007)                                     i label target idxlen nullcheck 
BB06 [0009]  2       BB02,BB05             1        [???..???)        (return)                     internal label target hascall gcsafe newobj 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..012) -> BB03 (cond), preds={} succs={BB02,BB03}

***** BB01
STMT00000 (IL 0x000...0x011)
N005 ( 16, 16) [000004] -AC-----R---              *  ASG       ref   
N004 (  1,  1) [000003] D------N----              +--*  LCL_VAR   ref    V02 tmp1         
N003 ( 16, 16) [000002] --C---------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST
N002 (  2, 10) [000001] H----------- arg0 in rcx     \--*  CNS_INT(h) long   0xd1ffab1e token

***** BB01
STMT00006 (IL   ???...  ???)
N005 ( 16, 16) [000021] -AC-----R---              *  ASG       ref   
N004 (  1,  1) [000020] D------N----              +--*  LCL_VAR   ref    V04 tmp3         
N003 ( 16, 16) [000019] --C---------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST
N002 (  2, 10) [000018] H----------- arg0 in rcx     \--*  CNS_INT(h) long   0xd1ffab1e token

***** BB01
STMT00013 (IL   ???...  ???)
N013 ( 26, 35) [000039] -ACXG---R---              *  ASG       ref   
N012 (  4,  4) [000038] ---XG--N----              +--*  IND       ref   
N011 (  2,  2) [000140] -------N----              |  \--*  ADD       byref 
N009 (  1,  1) [000035] ------------              |     +--*  LCL_VAR   ref    V04 tmp3         
N010 (  1,  1) [000139] ------------              |     \--*  CNS_INT   long   8 field offset Fseq[_array]
N008 ( 21, 30) [000047] --CXG-------              \--*  COMMA     ref   
N005 ( 17, 18) [000046] H-CXG-------                 +--*  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS
N003 (  2, 10) [000044] ------------ arg0 in rcx     |  +--*  CNS_INT   long   0x7ffa40fb0028
N004 (  1,  1) [000045] ------------ arg1 in rdx     |  \--*  CNS_INT   int    6
N007 (  4, 12) [000042] n---G-------                 \--*  IND       ref   
N006 (  2, 10) [000143] I-----------                    \--*  CNS_INT(h) long   0xd1ffab1e static Fseq[Value]

***** BB01
STMT00008 (IL   ???...  ???)
N006 (  6,  6) [000026] -A-XG-------              *  ASG       ref   
N004 (  4,  4) [000025] ---XG--N----              +--*  IND       ref   
N003 (  2,  2) [000145] -------N----              |  \--*  ADD       byref 
N001 (  1,  1) [000005] ------------              |     +--*  LCL_VAR   ref    V02 tmp1         
N002 (  1,  1) [000144] ------------              |     \--*  CNS_INT   long   16 field offset Fseq[_tokensBuffer]
N005 (  1,  1) [000024] ------------              \--*  LCL_VAR   ref    V04 tmp3         

***** BB01
STMT00010 (IL   ???...  ???)
N006 (  6,  6) [000032] -A-XG-------              *  ASG       ref   
N004 (  4,  4) [000031] ---XG--N----              +--*  IND       ref   
N003 (  2,  2) [000147] -------N----              |  \--*  ADD       byref 
N001 (  1,  1) [000029] ------------              |     +--*  LCL_VAR   ref    V02 tmp1         
N002 (  1,  1) [000146] ------------              |     \--*  CNS_INT   long   8 field offset Fseq[_reader]
N005 (  1,  1) [000030] ------------              \--*  CNS_INT   ref    null

***** BB01
STMT00014 (IL 0x006...  ???)
N004 (  5,  5) [000052] ------------              *  JTRUE     void  
N003 (  3,  3) [000051] J------N----              \--*  NE        int   
N001 (  1,  1) [000008] ------------                 +--*  LCL_VAR   ref    V00 arg0         
N002 (  1,  1) [000050] ------------                 \--*  CNS_INT   ref    null

------------ BB02 [006..007) -> BB06 (always), preds={BB01} succs={BB06}

***** BB02
STMT00019 (IL 0x006...  ???)
N007 ( 10,  8) [000154] -A----------              *  COMMA     void  
N003 (  5,  4) [000150] -A------R---              +--*  ASG       byref 
N002 (  3,  2) [000148] D------N----              |  +--*  LCL_VAR   byref  V21 tmp20        
N001 (  1,  1) [000149] ------------              |  \--*  CNS_INT   byref  0
N006 (  5,  4) [000153] -A------R---              \--*  ASG       int   
N005 (  3,  2) [000151] D------N----                 +--*  LCL_VAR   int    V22 tmp21        
N004 (  1,  1) [000152] ------------                 \--*  CNS_INT   int    0

***** BB02
STMT00020 (IL 0x006...  ???)
N007 ( 14, 10) [000161] -A----------              *  COMMA     void  
N003 (  7,  5) [000157] -A------R---              +--*  ASG       byref 
N002 (  3,  2) [000155] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        
N001 (  3,  2) [000156] ------------              |  \--*  LCL_VAR   byref  V21 tmp20        
N006 (  7,  5) [000160] -A------R---              \--*  ASG       int   
N005 (  3,  2) [000158] D------N----                 +--*  LCL_VAR   int    V18 tmp17        
N004 (  3,  2) [000159] ------------                 \--*  LCL_VAR   int    V22 tmp21        

------------ BB03 [006..007) -> BB05 (cond), preds={BB01} succs={BB04,BB05}

***** BB03
STMT00021 (IL 0x006...  ???)
N002 (  2,  2) [000086] ---X--------              *  NULLCHECK byte  
N001 (  1,  1) [000085] ------------              \--*  LCL_VAR   ref    V00 arg0         

***** BB03
STMT00016 (IL 0x006...  ???)
N007 ( 10,  8) [000168] -A----------              *  COMMA     void  
N003 (  5,  4) [000164] -A------R---              +--*  ASG       byref 
N002 (  3,  2) [000162] D------N----              |  +--*  LCL_VAR   byref  V19 tmp18        
N001 (  1,  1) [000163] ------------              |  \--*  CNS_INT   byref  0
N006 (  5,  4) [000167] -A------R---              \--*  ASG       int   
N005 (  3,  2) [000165] D------N----                 +--*  LCL_VAR   int    V20 tmp19        
N004 (  1,  1) [000166] ------------                 \--*  CNS_INT   int    0

***** BB03
STMT00026 (IL 0x006...  ???)
N005 (  7,  6) [000112] -A--G---R---              *  ASG       byref 
N004 (  3,  2) [000111] D------N----              +--*  LCL_VAR   byref  V09 tmp8         
N003 (  3,  3) [000173] ------------              \--*  ADD       byref 
N001 (  1,  1) [000171] ------------                 +--*  LCL_VAR   ref    V00 arg0         
N002 (  1,  1) [000172] ------------                 \--*  CNS_INT   long   12 field offset Fseq[_firstChar]

***** BB03
STMT00027 (IL 0x006...  ???)
N004 (  3,  3) [000114] -A-X----R---              *  ASG       int   
N003 (  1,  1) [000113] D------N----              +--*  LCL_VAR   int    V08 tmp7         
N002 (  3,  3) [000057] ---X--------              \--*  ARR_LENGTH int   
N001 (  1,  1) [000056] ------------                 \--*  LCL_VAR   ref    V00 arg0         

***** BB03
STMT00031 (IL 0x006...  ???)
N004 (  8, 15) [000133] -A--G---R---              *  ASG       ref   
N003 (  3,  2) [000132] D------N----              +--*  LCL_VAR   ref    V13 tmp12        
N002 (  4, 12) [000119] #---G-------              \--*  IND       ref   
N001 (  2, 10) [000118] H-----------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]

***** BB03
STMT00032 (IL 0x006...  ???)
N004 (  8, 15) [000135] -A--G---R---              *  ASG       ref   
N003 (  3,  2) [000134] D------N----              +--*  LCL_VAR   ref    V14 tmp13        
N002 (  4, 12) [000121] #---G-------              \--*  IND       ref   
N001 (  2, 10) [000120] H-----------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]

***** BB03
STMT00029 (IL 0x006...  ???)
N004 (  5,  5) [000128] ------------              *  JTRUE     void  
N003 (  3,  3) [000090] J------N----              \--*  GE        int   
N001 (  1,  1) [000088] ------------                 +--*  LCL_VAR   int    V08 tmp7         
N002 (  1,  1) [000089] ------------                 \--*  CNS_INT   int    0

------------ BB04 [006..007), preds={BB03} succs={BB05}

***** BB04
STMT00030 (IL 0x006...  ???)
N005 ( 20, 11) [000131] --CXG-------              *  CALL      void   System.Diagnostics.Debug.Fail
N003 (  3,  2) [000129] ------------ arg0 in rcx  +--*  LCL_VAR   ref    V13 tmp12        
N004 (  3,  2) [000130] ------------ arg1 in rdx  \--*  LCL_VAR   ref    V14 tmp13        

------------ BB05 [006..007), preds={BB03,BB04} succs={BB06}

***** BB05
STMT00023 (IL 0x006...  ???)
N003 (  7,  5) [000100] -A------R---              *  ASG       byref 
N002 (  3,  2) [000099] D------N----              +--*  LCL_VAR   byref  V23 tmp22        
N001 (  3,  2) [000096] ------------              \--*  LCL_VAR   byref  V09 tmp8         

***** BB05
STMT00024 (IL 0x006...  ???)
N003 (  7,  5) [000179] -A------R---              *  ASG       byref 
N002 (  3,  2) [000177] D------N----              +--*  LCL_VAR   byref  V19 tmp18        
N001 (  3,  2) [000178] -------N----              \--*  LCL_VAR   byref  V23 tmp22        

***** BB05
STMT00025 (IL 0x006...  ???)
N003 (  5,  4) [000110] -A------R---              *  ASG       int   
N002 (  3,  2) [000109] D------N----              +--*  LCL_VAR   int    V20 tmp19        
N001 (  1,  1) [000108] ------------              \--*  LCL_VAR   int    V08 tmp7         

***** BB05
STMT00018 (IL 0x006...  ???)
N007 ( 14, 10) [000186] -A----------              *  COMMA     void  
N003 (  7,  5) [000182] -A------R---              +--*  ASG       byref 
N002 (  3,  2) [000180] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        
N001 (  3,  2) [000181] ------------              |  \--*  LCL_VAR   byref  V19 tmp18        
N006 (  7,  5) [000185] -A------R---              \--*  ASG       int   
N005 (  3,  2) [000183] D------N----                 +--*  LCL_VAR   int    V18 tmp17        
N004 (  3,  2) [000184] ------------                 \--*  LCL_VAR   int    V20 tmp19        

------------ BB06 [???..???) (return), preds={BB02,BB05} succs={}

***** BB06
STMT00003 (IL   ???...  ???)
N007 ( 14, 10) [000193] -A----------              *  COMMA     void  
N003 (  7,  5) [000189] -A------R---              +--*  ASG       byref 
N002 (  3,  2) [000187] D------N----              |  +--*  LCL_VAR   byref  V15 tmp14        
N001 (  3,  2) [000188] ------------              |  \--*  LCL_VAR   byref  V17 tmp16        
N006 (  7,  5) [000192] -A------R---              \--*  ASG       int   
N005 (  3,  2) [000190] D------N----                 +--*  LCL_VAR   int    V16 tmp15        
N004 (  3,  2) [000191] ------------                 \--*  LCL_VAR   int    V18 tmp17        

***** BB06
STMT00004 (IL   ???...  ???)
N023 ( 40, 30) [000011] -ACXG-------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer.TokenizeLine
N003 (  1,  3) [000214] -A------R-L- this SETUP   +--*  ASG       ref   
N002 (  1,  1) [000213] D------N----              |  +--*  LCL_VAR   ref    V26 tmp25        
N001 (  1,  1) [000007] ------------              |  \--*  LCL_VAR   ref    V02 tmp1         
N019 ( 18, 15) [000212] -A--------L- arg1 SETUP   +--*  COMMA     void  
N012 ( 10,  8) [000205] -A----------              |  +--*  COMMA     void  
N007 (  3,  3) [000200] -A------R---              |  |  +--*  ASG       byref 
N006 (  1,  1) [000199] D------N----              |  |  |  +--*  LCL_VAR   byref  V25 tmp24        
N005 (  3,  3) [000197] ------------              |  |  |  \--*  ADDR      byref 
N004 (  3,  2) [000198] -------N----              |  |  |     \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(AX) V24 tmp23        
N011 (  7,  5) [000204] -A----------              |  |  \--*  ASG       byref 
N009 (  3,  2) [000202] *------N----              |  |     +--*  IND       byref 
N008 (  1,  1) [000201] ------------              |  |     |  \--*  LCL_VAR   byref  V25 tmp24         Zero Fseq[_pointer]
N010 (  3,  2) [000203] -------N----              |  |     \--*  LCL_VAR   byref  V15 tmp14        
N018 (  8,  7) [000211] -A----------              |  \--*  ASG       int   
N016 (  4,  4) [000209] *------N----              |     +--*  IND       int   
N015 (  2,  2) [000208] -------N----              |     |  \--*  ADD       byref 
N013 (  1,  1) [000206] ------------              |     |     +--*  LCL_VAR   byref  V25 tmp24        
N014 (  1,  1) [000207] ------------              |     |     \--*  CNS_INT   long   8 Fseq[_length]
N017 (  3,  2) [000210] -------N----              |     \--*  LCL_VAR   int    V16 tmp15        
N020 (  1,  1) [000215] ------------ this in rcx  +--*  LCL_VAR   ref    V26 tmp25        
N022 (  3,  3) [000217] ------------ arg1 in rdx  \--*  ADDR      byref 
N021 (  3,  2) [000216] -------N----                 \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(AX) V24 tmp23        

***** BB06
STMT00005 (IL 0x011...  ???)
N001 (  0,  0) [000017] ------------              *  RETURN    void  

-------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Build SSA representation
*************** In SsaBuilder::Build()
[SsaBuilder] Max block count is 7.

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)-> BB03 ( cond )                     i label target hascall newobj 
BB02 [0007]  1       BB01                  0.50     [006..007)-> BB06 (always)                     i 
BB03 [0008]  1       BB01                  0.50     [006..007)-> BB05 ( cond )                     i label target idxlen nullcheck 
BB04 [0014]  1       BB03                  0.25     [006..007)                                     i hascall gcsafe 
BB05 [0015]  2       BB03,BB04             0.50     [006..007)                                     i label target idxlen nullcheck 
BB06 [0009]  2       BB02,BB05             1        [???..???)        (return)                     internal label target hascall gcsafe newobj 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table is empty
[SsaBuilder] Topologically sorted the graph.
[SsaBuilder::ComputeImmediateDom]

Inside fgBuildDomTree

After computing the Dominance Tree:
BB01 : BB06 BB03 BB02 
BB03 : BB05 BB04 

*************** In fgLocalVarLiveness()
In fgLocalVarLivenessInit
Tracked variable (18 out of 27) table:
V02 tmp1          [   ref]: refCnt =    4, refCntWtd =   8   
V00 arg0          [   ref]: refCnt =    6, refCntWtd =   4.50
V04 tmp3          [   ref]: refCnt =    3, refCntWtd =   6   
V25 tmp24         [ byref]: refCnt =    3, refCntWtd =   6   
V26 tmp25         [   ref]: refCnt =    2, refCntWtd =   4   
V08 tmp7          [   int]: refCnt =    3, refCntWtd =   3   
V17 tmp16         [ byref]: refCnt =    3, refCntWtd =   2   
V18 tmp17         [   int]: refCnt =    3, refCntWtd =   2   
V09 tmp8          [ byref]: refCnt =    2, refCntWtd =   2   
V15 tmp14         [ byref]: refCnt =    2, refCntWtd =   2   
V16 tmp15         [   int]: refCnt =    2, refCntWtd =   2   
V19 tmp18         [ byref]: refCnt =    3, refCntWtd =   1.50
V20 tmp19         [   int]: refCnt =    3, refCntWtd =   1.50
V13 tmp12         [   ref]: refCnt =    2, refCntWtd =   1.50
V14 tmp13         [   ref]: refCnt =    2, refCntWtd =   1.50
V21 tmp20         [ byref]: refCnt =    2, refCntWtd =   1   
V23 tmp22         [ byref]: refCnt =    2, refCntWtd =   1   
V22 tmp21         [   int]: refCnt =    2, refCntWtd =   1   

*************** In fgPerBlockLocalVarLiveness()
BB01 USE(1)={    V00    } + ByrefExposed + GcHeap
     DEF(2)={V02     V04} + ByrefExposed* + GcHeap*

BB02 USE(0)={               }
     DEF(4)={V17 V18 V21 V22}

BB03 USE(1)={V00                        } + ByrefExposed + GcHeap
     DEF(6)={    V08 V09 V19 V20 V13 V14}

BB04 USE(2)={V13 V14} + ByrefExposed + GcHeap
     DEF(0)={       } + ByrefExposed* + GcHeap*

BB05 USE(2)={V08         V09            }
     DEF(5)={    V17 V18     V19 V20 V23}

BB06 USE(3)={V02         V17 V18        } + ByrefExposed + GcHeap
     DEF(4)={    V25 V26         V15 V16} + ByrefExposed* + GcHeap*

** Memory liveness computed, GcHeap states and ByrefExposed states match
*************** In fgInterBlockLocalVarLiveness()

BB liveness after fgLiveVarAnalysis():

BB01 IN (1)={    V00} + ByrefExposed + GcHeap
     OUT(2)={V02 V00} + ByrefExposed + GcHeap

BB02 IN (1)={V02        } + ByrefExposed + GcHeap
     OUT(3)={V02 V17 V18} + ByrefExposed + GcHeap

BB03 IN (2)={V02 V00                } + ByrefExposed + GcHeap
     OUT(5)={V02     V08 V09 V13 V14} + ByrefExposed + GcHeap

BB04 IN (5)={V02 V08 V09 V13 V14} + ByrefExposed + GcHeap
     OUT(3)={V02 V08 V09        } + ByrefExposed + GcHeap

BB05 IN (3)={V02 V08         V09} + ByrefExposed + GcHeap
     OUT(3)={V02     V17 V18    } + ByrefExposed + GcHeap

BB06 IN (3)={V02 V17 V18} + ByrefExposed + GcHeap
     OUT(0)={           }


Removing tree [000167] in BB03 as useless
N006 (  5,  4) [000167] -A------R---              *  ASG       int   
N005 (  3,  2) [000165] D------N----              +--*  LCL_VAR   int    V20 tmp19        
N004 (  1,  1) [000166] ------------              \--*  CNS_INT   int    0


Removing tree [000164] in BB03 as useless
N003 (  5,  4) [000164] -A------R---              *  ASG       byref 
N002 (  3,  2) [000162] D------N----              +--*  LCL_VAR   byref  V19 tmp18        
N001 (  1,  1) [000163] ------------              \--*  CNS_INT   byref  0


fgComputeLife modified tree:
N003 (  0,  0) [000168] ------------              *  COMMA     void  
N001 (  0,  0) [000164] ------------              +--*  NOP       void  
N002 (  0,  0) [000167] ------------              \--*  NOP       void  

*************** In optRemoveRedundantZeroInits()
*************** In SsaBuilder::InsertPhiFunctions()
Inserting phi functions:
Added PHI definition for V17 at start of BB06.
Added PHI definition for V18 at start of BB06.
Inserting phi definition for ByrefExposed at start of BB05.
Inserting phi definition for ByrefExposed at start of BB06.
*************** In SsaBuilder::RenameVariables()

After fgSsaBuild:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)-> BB03 ( cond )                     i label target hascall newobj 
BB02 [0007]  1       BB01                  0.50     [006..007)-> BB06 (always)                     i 
BB03 [0008]  1       BB01                  0.50     [006..007)-> BB05 ( cond )                     i label target idxlen nullcheck 
BB04 [0014]  1       BB03                  0.25     [006..007)                                     i hascall gcsafe 
BB05 [0015]  2       BB03,BB04             0.50     [006..007)                                     i label target idxlen nullcheck 
BB06 [0009]  2       BB02,BB05             1        [???..???)        (return)                     internal label target hascall gcsafe newobj 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..012) -> BB03 (cond), preds={} succs={BB02,BB03}

***** BB01
STMT00000 (IL 0x000...0x011)
N005 ( 16, 16) [000004] -AC-----R---              *  ASG       ref   
N004 (  1,  1) [000003] D------N----              +--*  LCL_VAR   ref    V02 tmp1         d:1
N003 ( 16, 16) [000002] --C---------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST
N002 (  2, 10) [000001] H----------- arg0 in rcx     \--*  CNS_INT(h) long   0xd1ffab1e token

***** BB01
STMT00006 (IL   ???...  ???)
N005 ( 16, 16) [000021] -AC-----R---              *  ASG       ref   
N004 (  1,  1) [000020] D------N----              +--*  LCL_VAR   ref    V04 tmp3         d:1
N003 ( 16, 16) [000019] --C---------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST
N002 (  2, 10) [000018] H----------- arg0 in rcx     \--*  CNS_INT(h) long   0xd1ffab1e token

***** BB01
STMT00013 (IL   ???...  ???)
N013 ( 26, 35) [000039] -ACXG---R---              *  ASG       ref   
N012 (  4,  4) [000038] D--XG--N----              +--*  IND       ref   
N011 (  2,  2) [000140] -------N----              |  \--*  ADD       byref 
N009 (  1,  1) [000035] ------------              |     +--*  LCL_VAR   ref    V04 tmp3         u:1
N010 (  1,  1) [000139] ------------              |     \--*  CNS_INT   long   8 field offset Fseq[_array]
N008 ( 21, 30) [000047] --CXG-------              \--*  COMMA     ref   
N005 ( 17, 18) [000046] H-CXG-------                 +--*  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS
N003 (  2, 10) [000044] ------------ arg0 in rcx     |  +--*  CNS_INT   long   0x7ffa40fb0028
N004 (  1,  1) [000045] ------------ arg1 in rdx     |  \--*  CNS_INT   int    6
N007 (  4, 12) [000042] n---G-------                 \--*  IND       ref   
N006 (  2, 10) [000143] I-----------                    \--*  CNS_INT(h) long   0xd1ffab1e static Fseq[Value]

***** BB01
STMT00008 (IL   ???...  ???)
N006 (  6,  6) [000026] -A-XG-------              *  ASG       ref   
N004 (  4,  4) [000025] D--XG--N----              +--*  IND       ref   
N003 (  2,  2) [000145] -------N----              |  \--*  ADD       byref 
N001 (  1,  1) [000005] ------------              |     +--*  LCL_VAR   ref    V02 tmp1         u:1
N002 (  1,  1) [000144] ------------              |     \--*  CNS_INT   long   16 field offset Fseq[_tokensBuffer]
N005 (  1,  1) [000024] ------------              \--*  LCL_VAR   ref    V04 tmp3         u:1 (last use)

***** BB01
STMT00010 (IL   ???...  ???)
N006 (  6,  6) [000032] -A-XG-------              *  ASG       ref   
N004 (  4,  4) [000031] D--XG--N----              +--*  IND       ref   
N003 (  2,  2) [000147] -------N----              |  \--*  ADD       byref 
N001 (  1,  1) [000029] ------------              |     +--*  LCL_VAR   ref    V02 tmp1         u:1
N002 (  1,  1) [000146] ------------              |     \--*  CNS_INT   long   8 field offset Fseq[_reader]
N005 (  1,  1) [000030] ------------              \--*  CNS_INT   ref    null

***** BB01
STMT00014 (IL 0x006...  ???)
N004 (  5,  5) [000052] ------------              *  JTRUE     void  
N003 (  3,  3) [000051] J------N----              \--*  NE        int   
N001 (  1,  1) [000008] ------------                 +--*  LCL_VAR   ref    V00 arg0         u:1
N002 (  1,  1) [000050] ------------                 \--*  CNS_INT   ref    null

------------ BB02 [006..007) -> BB06 (always), preds={BB01} succs={BB06}

***** BB02
STMT00019 (IL 0x006...  ???)
N007 ( 10,  8) [000154] -A----------              *  COMMA     void  
N003 (  5,  4) [000150] -A------R---              +--*  ASG       byref 
N002 (  3,  2) [000148] D------N----              |  +--*  LCL_VAR   byref  V21 tmp20        d:1
N001 (  1,  1) [000149] ------------              |  \--*  CNS_INT   byref  0
N006 (  5,  4) [000153] -A------R---              \--*  ASG       int   
N005 (  3,  2) [000151] D------N----                 +--*  LCL_VAR   int    V22 tmp21        d:1
N004 (  1,  1) [000152] ------------                 \--*  CNS_INT   int    0

***** BB02
STMT00020 (IL 0x006...  ???)
N007 ( 14, 10) [000161] -A----------              *  COMMA     void  
N003 (  7,  5) [000157] -A------R---              +--*  ASG       byref 
N002 (  3,  2) [000155] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        d:3
N001 (  3,  2) [000156] ------------              |  \--*  LCL_VAR   byref  V21 tmp20        u:1 (last use)
N006 (  7,  5) [000160] -A------R---              \--*  ASG       int   
N005 (  3,  2) [000158] D------N----                 +--*  LCL_VAR   int    V18 tmp17        d:3
N004 (  3,  2) [000159] ------------                 \--*  LCL_VAR   int    V22 tmp21        u:1 (last use)

------------ BB03 [006..007) -> BB05 (cond), preds={BB01} succs={BB04,BB05}

***** BB03
STMT00021 (IL 0x006...  ???)
N002 (  2,  2) [000086] ---X--------              *  NULLCHECK byte  
N001 (  1,  1) [000085] ------------              \--*  LCL_VAR   ref    V00 arg0         u:1

***** BB03
STMT00016 (IL 0x006...  ???)
N003 (  0,  0) [000168] ------------              *  COMMA     void  
N001 (  0,  0) [000164] ------------              +--*  NOP       void  
N002 (  0,  0) [000167] ------------              \--*  NOP       void  

***** BB03
STMT00026 (IL 0x006...  ???)
N005 (  7,  6) [000112] -A--G---R---              *  ASG       byref 
N004 (  3,  2) [000111] D------N----              +--*  LCL_VAR   byref  V09 tmp8         d:1
N003 (  3,  3) [000173] ------------              \--*  ADD       byref 
N001 (  1,  1) [000171] ------------                 +--*  LCL_VAR   ref    V00 arg0         u:1
N002 (  1,  1) [000172] ------------                 \--*  CNS_INT   long   12 field offset Fseq[_firstChar]

***** BB03
STMT00027 (IL 0x006...  ???)
N004 (  3,  3) [000114] -A-X----R---              *  ASG       int   
N003 (  1,  1) [000113] D------N----              +--*  LCL_VAR   int    V08 tmp7         d:1
N002 (  3,  3) [000057] ---X--------              \--*  ARR_LENGTH int   
N001 (  1,  1) [000056] ------------                 \--*  LCL_VAR   ref    V00 arg0         u:1 (last use)

***** BB03
STMT00031 (IL 0x006...  ???)
N004 (  8, 15) [000133] -A--G---R---              *  ASG       ref   
N003 (  3,  2) [000132] D------N----              +--*  LCL_VAR   ref    V13 tmp12        d:1
N002 (  4, 12) [000119] #---G-------              \--*  IND       ref   
N001 (  2, 10) [000118] H-----------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]

***** BB03
STMT00032 (IL 0x006...  ???)
N004 (  8, 15) [000135] -A--G---R---              *  ASG       ref   
N003 (  3,  2) [000134] D------N----              +--*  LCL_VAR   ref    V14 tmp13        d:1
N002 (  4, 12) [000121] #---G-------              \--*  IND       ref   
N001 (  2, 10) [000120] H-----------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]

***** BB03
STMT00029 (IL 0x006...  ???)
N004 (  5,  5) [000128] ------------              *  JTRUE     void  
N003 (  3,  3) [000090] J------N----              \--*  GE        int   
N001 (  1,  1) [000088] ------------                 +--*  LCL_VAR   int    V08 tmp7         u:1
N002 (  1,  1) [000089] ------------                 \--*  CNS_INT   int    0

------------ BB04 [006..007), preds={BB03} succs={BB05}

***** BB04
STMT00030 (IL 0x006...  ???)
N005 ( 20, 11) [000131] --CXG-------              *  CALL      void   System.Diagnostics.Debug.Fail
N003 (  3,  2) [000129] ------------ arg0 in rcx  +--*  LCL_VAR   ref    V13 tmp12        u:1 (last use)
N004 (  3,  2) [000130] ------------ arg1 in rdx  \--*  LCL_VAR   ref    V14 tmp13        u:1 (last use)

------------ BB05 [006..007), preds={BB03,BB04} succs={BB06}

***** BB05
STMT00023 (IL 0x006...  ???)
N003 (  7,  5) [000100] -A------R---              *  ASG       byref 
N002 (  3,  2) [000099] D------N----              +--*  LCL_VAR   byref  V23 tmp22        d:1
N001 (  3,  2) [000096] ------------              \--*  LCL_VAR   byref  V09 tmp8         u:1 (last use)

***** BB05
STMT00024 (IL 0x006...  ???)
N003 (  7,  5) [000179] -A------R---              *  ASG       byref 
N002 (  3,  2) [000177] D------N----              +--*  LCL_VAR   byref  V19 tmp18        d:1
N001 (  3,  2) [000178] -------N----              \--*  LCL_VAR   byref  V23 tmp22        u:1 (last use)

***** BB05
STMT00025 (IL 0x006...  ???)
N003 (  5,  4) [000110] -A------R---              *  ASG       int   
N002 (  3,  2) [000109] D------N----              +--*  LCL_VAR   int    V20 tmp19        d:1
N001 (  1,  1) [000108] ------------              \--*  LCL_VAR   int    V08 tmp7         u:1 (last use)

***** BB05
STMT00018 (IL 0x006...  ???)
N007 ( 14, 10) [000186] -A----------              *  COMMA     void  
N003 (  7,  5) [000182] -A------R---              +--*  ASG       byref 
N002 (  3,  2) [000180] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        d:2
N001 (  3,  2) [000181] ------------              |  \--*  LCL_VAR   byref  V19 tmp18        u:1 (last use)
N006 (  7,  5) [000185] -A------R---              \--*  ASG       int   
N005 (  3,  2) [000183] D------N----                 +--*  LCL_VAR   int    V18 tmp17        d:2
N004 (  3,  2) [000184] ------------                 \--*  LCL_VAR   int    V20 tmp19        u:1 (last use)

------------ BB06 [???..???) (return), preds={BB02,BB05} succs={}

***** BB06
STMT00034 (IL   ???...  ???)
N005 (  0,  0) [000223] -A------R---              *  ASG       int   
N004 (  0,  0) [000221] D------N----              +--*  LCL_VAR   int    V18 tmp17        d:1
N003 (  0,  0) [000222] ------------              \--*  PHI       int   
N001 (  0,  0) [000226] ------------ pred BB02       +--*  PHI_ARG   int    V18 tmp17        u:3
N002 (  0,  0) [000224] ------------ pred BB05       \--*  PHI_ARG   int    V18 tmp17        u:2

***** BB06
STMT00033 (IL   ???...  ???)
N005 (  0,  0) [000220] -A------R---              *  ASG       byref 
N004 (  0,  0) [000218] D------N----              +--*  LCL_VAR   byref  V17 tmp16        d:1
N003 (  0,  0) [000219] ------------              \--*  PHI       byref 
N001 (  0,  0) [000227] ------------ pred BB02       +--*  PHI_ARG   byref  V17 tmp16        u:3
N002 (  0,  0) [000225] ------------ pred BB05       \--*  PHI_ARG   byref  V17 tmp16        u:2

***** BB06
STMT00003 (IL   ???...  ???)
N007 ( 14, 10) [000193] -A----------              *  COMMA     void  
N003 (  7,  5) [000189] -A------R---              +--*  ASG       byref 
N002 (  3,  2) [000187] D------N----              |  +--*  LCL_VAR   byref  V15 tmp14        d:1
N001 (  3,  2) [000188] ------------              |  \--*  LCL_VAR   byref  V17 tmp16        u:1 (last use)
N006 (  7,  5) [000192] -A------R---              \--*  ASG       int   
N005 (  3,  2) [000190] D------N----                 +--*  LCL_VAR   int    V16 tmp15        d:1
N004 (  3,  2) [000191] ------------                 \--*  LCL_VAR   int    V18 tmp17        u:1 (last use)

***** BB06
STMT00004 (IL   ???...  ???)
N023 ( 40, 30) [000011] -ACXG-------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer.TokenizeLine
N003 (  1,  3) [000214] -A------R-L- this SETUP   +--*  ASG       ref   
N002 (  1,  1) [000213] D------N----              |  +--*  LCL_VAR   ref    V26 tmp25        d:1
N001 (  1,  1) [000007] ------------              |  \--*  LCL_VAR   ref    V02 tmp1         u:1 (last use)
N019 ( 18, 15) [000212] -A--------L- arg1 SETUP   +--*  COMMA     void  
N012 ( 10,  8) [000205] -A----------              |  +--*  COMMA     void  
N007 (  3,  3) [000200] -A------R---              |  |  +--*  ASG       byref 
N006 (  1,  1) [000199] D------N----              |  |  |  +--*  LCL_VAR   byref  V25 tmp24        d:1
N005 (  3,  3) [000197] ------------              |  |  |  \--*  ADDR      byref 
N004 (  3,  2) [000198] -------N----              |  |  |     \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(AX) V24 tmp23        
N011 (  7,  5) [000204] -A----------              |  |  \--*  ASG       byref 
N009 (  3,  2) [000202] *------N----              |  |     +--*  IND       byref 
N008 (  1,  1) [000201] ------------              |  |     |  \--*  LCL_VAR   byref  V25 tmp24        u:1 Zero Fseq[_pointer]
N010 (  3,  2) [000203] -------N----              |  |     \--*  LCL_VAR   byref  V15 tmp14        u:1 (last use)
N018 (  8,  7) [000211] -A----------              |  \--*  ASG       int   
N016 (  4,  4) [000209] *------N----              |     +--*  IND       int   
N015 (  2,  2) [000208] -------N----              |     |  \--*  ADD       byref 
N013 (  1,  1) [000206] ------------              |     |     +--*  LCL_VAR   byref  V25 tmp24        u:1 (last use)
N014 (  1,  1) [000207] ------------              |     |     \--*  CNS_INT   long   8 Fseq[_length]
N017 (  3,  2) [000210] -------N----              |     \--*  LCL_VAR   int    V16 tmp15        u:1 (last use)
N020 (  1,  1) [000215] ------------ this in rcx  +--*  LCL_VAR   ref    V26 tmp25        u:1 (last use)
N022 (  3,  3) [000217] ------------ arg1 in rdx  \--*  ADDR      byref 
N021 (  3,  2) [000216] -------N----                 \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(AX) V24 tmp23        

***** BB06
STMT00005 (IL 0x011...  ???)
N001 (  0,  0) [000017] ------------              *  RETURN    void  

-------------------------------------------------------------------------------------------------------------------

*************** Finishing PHASE Build SSA representation
Trees after Build SSA representation

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)-> BB03 ( cond )                     i label target hascall newobj 
BB02 [0007]  1       BB01                  0.50     [006..007)-> BB06 (always)                     i 
BB03 [0008]  1       BB01                  0.50     [006..007)-> BB05 ( cond )                     i label target idxlen nullcheck 
BB04 [0014]  1       BB03                  0.25     [006..007)                                     i hascall gcsafe 
BB05 [0015]  2       BB03,BB04             0.50     [006..007)                                     i label target idxlen nullcheck 
BB06 [0009]  2       BB02,BB05             1        [???..???)        (return)                     internal label target hascall gcsafe newobj 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..012) -> BB03 (cond), preds={} succs={BB02,BB03}

***** BB01
STMT00000 (IL 0x000...0x011)
N005 ( 16, 16) [000004] -AC-----R---              *  ASG       ref   
N004 (  1,  1) [000003] D------N----              +--*  LCL_VAR   ref    V02 tmp1         d:1
N003 ( 16, 16) [000002] --C---------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST
N002 (  2, 10) [000001] H----------- arg0 in rcx     \--*  CNS_INT(h) long   0xd1ffab1e token

***** BB01
STMT00006 (IL   ???...  ???)
N005 ( 16, 16) [000021] -AC-----R---              *  ASG       ref   
N004 (  1,  1) [000020] D------N----              +--*  LCL_VAR   ref    V04 tmp3         d:1
N003 ( 16, 16) [000019] --C---------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST
N002 (  2, 10) [000018] H----------- arg0 in rcx     \--*  CNS_INT(h) long   0xd1ffab1e token

***** BB01
STMT00013 (IL   ???...  ???)
N013 ( 26, 35) [000039] -ACXG---R---              *  ASG       ref   
N012 (  4,  4) [000038] D--XG--N----              +--*  IND       ref   
N011 (  2,  2) [000140] -------N----              |  \--*  ADD       byref 
N009 (  1,  1) [000035] ------------              |     +--*  LCL_VAR   ref    V04 tmp3         u:1
N010 (  1,  1) [000139] ------------              |     \--*  CNS_INT   long   8 field offset Fseq[_array]
N008 ( 21, 30) [000047] --CXG-------              \--*  COMMA     ref   
N005 ( 17, 18) [000046] H-CXG-------                 +--*  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS
N003 (  2, 10) [000044] ------------ arg0 in rcx     |  +--*  CNS_INT   long   0x7ffa40fb0028
N004 (  1,  1) [000045] ------------ arg1 in rdx     |  \--*  CNS_INT   int    6
N007 (  4, 12) [000042] n---G-------                 \--*  IND       ref   
N006 (  2, 10) [000143] I-----------                    \--*  CNS_INT(h) long   0xd1ffab1e static Fseq[Value]

***** BB01
STMT00008 (IL   ???...  ???)
N006 (  6,  6) [000026] -A-XG-------              *  ASG       ref   
N004 (  4,  4) [000025] D--XG--N----              +--*  IND       ref   
N003 (  2,  2) [000145] -------N----              |  \--*  ADD       byref 
N001 (  1,  1) [000005] ------------              |     +--*  LCL_VAR   ref    V02 tmp1         u:1
N002 (  1,  1) [000144] ------------              |     \--*  CNS_INT   long   16 field offset Fseq[_tokensBuffer]
N005 (  1,  1) [000024] ------------              \--*  LCL_VAR   ref    V04 tmp3         u:1 (last use)

***** BB01
STMT00010 (IL   ???...  ???)
N006 (  6,  6) [000032] -A-XG-------              *  ASG       ref   
N004 (  4,  4) [000031] D--XG--N----              +--*  IND       ref   
N003 (  2,  2) [000147] -------N----              |  \--*  ADD       byref 
N001 (  1,  1) [000029] ------------              |     +--*  LCL_VAR   ref    V02 tmp1         u:1
N002 (  1,  1) [000146] ------------              |     \--*  CNS_INT   long   8 field offset Fseq[_reader]
N005 (  1,  1) [000030] ------------              \--*  CNS_INT   ref    null

***** BB01
STMT00014 (IL 0x006...  ???)
N004 (  5,  5) [000052] ------------              *  JTRUE     void  
N003 (  3,  3) [000051] J------N----              \--*  NE        int   
N001 (  1,  1) [000008] ------------                 +--*  LCL_VAR   ref    V00 arg0         u:1
N002 (  1,  1) [000050] ------------                 \--*  CNS_INT   ref    null

------------ BB02 [006..007) -> BB06 (always), preds={BB01} succs={BB06}

***** BB02
STMT00019 (IL 0x006...  ???)
N007 ( 10,  8) [000154] -A----------              *  COMMA     void  
N003 (  5,  4) [000150] -A------R---              +--*  ASG       byref 
N002 (  3,  2) [000148] D------N----              |  +--*  LCL_VAR   byref  V21 tmp20        d:1
N001 (  1,  1) [000149] ------------              |  \--*  CNS_INT   byref  0
N006 (  5,  4) [000153] -A------R---              \--*  ASG       int   
N005 (  3,  2) [000151] D------N----                 +--*  LCL_VAR   int    V22 tmp21        d:1
N004 (  1,  1) [000152] ------------                 \--*  CNS_INT   int    0

***** BB02
STMT00020 (IL 0x006...  ???)
N007 ( 14, 10) [000161] -A----------              *  COMMA     void  
N003 (  7,  5) [000157] -A------R---              +--*  ASG       byref 
N002 (  3,  2) [000155] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        d:3
N001 (  3,  2) [000156] ------------              |  \--*  LCL_VAR   byref  V21 tmp20        u:1 (last use)
N006 (  7,  5) [000160] -A------R---              \--*  ASG       int   
N005 (  3,  2) [000158] D------N----                 +--*  LCL_VAR   int    V18 tmp17        d:3
N004 (  3,  2) [000159] ------------                 \--*  LCL_VAR   int    V22 tmp21        u:1 (last use)

------------ BB03 [006..007) -> BB05 (cond), preds={BB01} succs={BB04,BB05}

***** BB03
STMT00021 (IL 0x006...  ???)
N002 (  2,  2) [000086] ---X--------              *  NULLCHECK byte  
N001 (  1,  1) [000085] ------------              \--*  LCL_VAR   ref    V00 arg0         u:1

***** BB03
STMT00016 (IL 0x006...  ???)
N003 (  0,  0) [000168] ------------              *  COMMA     void  
N001 (  0,  0) [000164] ------------              +--*  NOP       void  
N002 (  0,  0) [000167] ------------              \--*  NOP       void  

***** BB03
STMT00026 (IL 0x006...  ???)
N005 (  7,  6) [000112] -A--G---R---              *  ASG       byref 
N004 (  3,  2) [000111] D------N----              +--*  LCL_VAR   byref  V09 tmp8         d:1
N003 (  3,  3) [000173] ------------              \--*  ADD       byref 
N001 (  1,  1) [000171] ------------                 +--*  LCL_VAR   ref    V00 arg0         u:1
N002 (  1,  1) [000172] ------------                 \--*  CNS_INT   long   12 field offset Fseq[_firstChar]

***** BB03
STMT00027 (IL 0x006...  ???)
N004 (  3,  3) [000114] -A-X----R---              *  ASG       int   
N003 (  1,  1) [000113] D------N----              +--*  LCL_VAR   int    V08 tmp7         d:1
N002 (  3,  3) [000057] ---X--------              \--*  ARR_LENGTH int   
N001 (  1,  1) [000056] ------------                 \--*  LCL_VAR   ref    V00 arg0         u:1 (last use)

***** BB03
STMT00031 (IL 0x006...  ???)
N004 (  8, 15) [000133] -A--G---R---              *  ASG       ref   
N003 (  3,  2) [000132] D------N----              +--*  LCL_VAR   ref    V13 tmp12        d:1
N002 (  4, 12) [000119] #---G-------              \--*  IND       ref   
N001 (  2, 10) [000118] H-----------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]

***** BB03
STMT00032 (IL 0x006...  ???)
N004 (  8, 15) [000135] -A--G---R---              *  ASG       ref   
N003 (  3,  2) [000134] D------N----              +--*  LCL_VAR   ref    V14 tmp13        d:1
N002 (  4, 12) [000121] #---G-------              \--*  IND       ref   
N001 (  2, 10) [000120] H-----------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]

***** BB03
STMT00029 (IL 0x006...  ???)
N004 (  5,  5) [000128] ------------              *  JTRUE     void  
N003 (  3,  3) [000090] J------N----              \--*  GE        int   
N001 (  1,  1) [000088] ------------                 +--*  LCL_VAR   int    V08 tmp7         u:1
N002 (  1,  1) [000089] ------------                 \--*  CNS_INT   int    0

------------ BB04 [006..007), preds={BB03} succs={BB05}

***** BB04
STMT00030 (IL 0x006...  ???)
N005 ( 20, 11) [000131] --CXG-------              *  CALL      void   System.Diagnostics.Debug.Fail
N003 (  3,  2) [000129] ------------ arg0 in rcx  +--*  LCL_VAR   ref    V13 tmp12        u:1 (last use)
N004 (  3,  2) [000130] ------------ arg1 in rdx  \--*  LCL_VAR   ref    V14 tmp13        u:1 (last use)

------------ BB05 [006..007), preds={BB03,BB04} succs={BB06}

***** BB05
STMT00023 (IL 0x006...  ???)
N003 (  7,  5) [000100] -A------R---              *  ASG       byref 
N002 (  3,  2) [000099] D------N----              +--*  LCL_VAR   byref  V23 tmp22        d:1
N001 (  3,  2) [000096] ------------              \--*  LCL_VAR   byref  V09 tmp8         u:1 (last use)

***** BB05
STMT00024 (IL 0x006...  ???)
N003 (  7,  5) [000179] -A------R---              *  ASG       byref 
N002 (  3,  2) [000177] D------N----              +--*  LCL_VAR   byref  V19 tmp18        d:1
N001 (  3,  2) [000178] -------N----              \--*  LCL_VAR   byref  V23 tmp22        u:1 (last use)

***** BB05
STMT00025 (IL 0x006...  ???)
N003 (  5,  4) [000110] -A------R---              *  ASG       int   
N002 (  3,  2) [000109] D------N----              +--*  LCL_VAR   int    V20 tmp19        d:1
N001 (  1,  1) [000108] ------------              \--*  LCL_VAR   int    V08 tmp7         u:1 (last use)

***** BB05
STMT00018 (IL 0x006...  ???)
N007 ( 14, 10) [000186] -A----------              *  COMMA     void  
N003 (  7,  5) [000182] -A------R---              +--*  ASG       byref 
N002 (  3,  2) [000180] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        d:2
N001 (  3,  2) [000181] ------------              |  \--*  LCL_VAR   byref  V19 tmp18        u:1 (last use)
N006 (  7,  5) [000185] -A------R---              \--*  ASG       int   
N005 (  3,  2) [000183] D------N----                 +--*  LCL_VAR   int    V18 tmp17        d:2
N004 (  3,  2) [000184] ------------                 \--*  LCL_VAR   int    V20 tmp19        u:1 (last use)

------------ BB06 [???..???) (return), preds={BB02,BB05} succs={}

***** BB06
STMT00034 (IL   ???...  ???)
N005 (  0,  0) [000223] -A------R---              *  ASG       int   
N004 (  0,  0) [000221] D------N----              +--*  LCL_VAR   int    V18 tmp17        d:1
N003 (  0,  0) [000222] ------------              \--*  PHI       int   
N001 (  0,  0) [000226] ------------ pred BB02       +--*  PHI_ARG   int    V18 tmp17        u:3
N002 (  0,  0) [000224] ------------ pred BB05       \--*  PHI_ARG   int    V18 tmp17        u:2

***** BB06
STMT00033 (IL   ???...  ???)
N005 (  0,  0) [000220] -A------R---              *  ASG       byref 
N004 (  0,  0) [000218] D------N----              +--*  LCL_VAR   byref  V17 tmp16        d:1
N003 (  0,  0) [000219] ------------              \--*  PHI       byref 
N001 (  0,  0) [000227] ------------ pred BB02       +--*  PHI_ARG   byref  V17 tmp16        u:3
N002 (  0,  0) [000225] ------------ pred BB05       \--*  PHI_ARG   byref  V17 tmp16        u:2

***** BB06
STMT00003 (IL   ???...  ???)
N007 ( 14, 10) [000193] -A----------              *  COMMA     void  
N003 (  7,  5) [000189] -A------R---              +--*  ASG       byref 
N002 (  3,  2) [000187] D------N----              |  +--*  LCL_VAR   byref  V15 tmp14        d:1
N001 (  3,  2) [000188] ------------              |  \--*  LCL_VAR   byref  V17 tmp16        u:1 (last use)
N006 (  7,  5) [000192] -A------R---              \--*  ASG       int   
N005 (  3,  2) [000190] D------N----                 +--*  LCL_VAR   int    V16 tmp15        d:1
N004 (  3,  2) [000191] ------------                 \--*  LCL_VAR   int    V18 tmp17        u:1 (last use)

***** BB06
STMT00004 (IL   ???...  ???)
N023 ( 40, 30) [000011] -ACXG-------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer.TokenizeLine
N003 (  1,  3) [000214] -A------R-L- this SETUP   +--*  ASG       ref   
N002 (  1,  1) [000213] D------N----              |  +--*  LCL_VAR   ref    V26 tmp25        d:1
N001 (  1,  1) [000007] ------------              |  \--*  LCL_VAR   ref    V02 tmp1         u:1 (last use)
N019 ( 18, 15) [000212] -A--------L- arg1 SETUP   +--*  COMMA     void  
N012 ( 10,  8) [000205] -A----------              |  +--*  COMMA     void  
N007 (  3,  3) [000200] -A------R---              |  |  +--*  ASG       byref 
N006 (  1,  1) [000199] D------N----              |  |  |  +--*  LCL_VAR   byref  V25 tmp24        d:1
N005 (  3,  3) [000197] ------------              |  |  |  \--*  ADDR      byref 
N004 (  3,  2) [000198] -------N----              |  |  |     \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(AX) V24 tmp23        
N011 (  7,  5) [000204] -A----------              |  |  \--*  ASG       byref 
N009 (  3,  2) [000202] *------N----              |  |     +--*  IND       byref 
N008 (  1,  1) [000201] ------------              |  |     |  \--*  LCL_VAR   byref  V25 tmp24        u:1 Zero Fseq[_pointer]
N010 (  3,  2) [000203] -------N----              |  |     \--*  LCL_VAR   byref  V15 tmp14        u:1 (last use)
N018 (  8,  7) [000211] -A----------              |  \--*  ASG       int   
N016 (  4,  4) [000209] *------N----              |     +--*  IND       int   
N015 (  2,  2) [000208] -------N----              |     |  \--*  ADD       byref 
N013 (  1,  1) [000206] ------------              |     |     +--*  LCL_VAR   byref  V25 tmp24        u:1 (last use)
N014 (  1,  1) [000207] ------------              |     |     \--*  CNS_INT   long   8 Fseq[_length]
N017 (  3,  2) [000210] -------N----              |     \--*  LCL_VAR   int    V16 tmp15        u:1 (last use)
N020 (  1,  1) [000215] ------------ this in rcx  +--*  LCL_VAR   ref    V26 tmp25        u:1 (last use)
N022 (  3,  3) [000217] ------------ arg1 in rdx  \--*  ADDR      byref 
N021 (  3,  2) [000216] -------N----                 \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(AX) V24 tmp23        

***** BB06
STMT00005 (IL 0x011...  ???)
N001 (  0,  0) [000017] ------------              *  RETURN    void  

-------------------------------------------------------------------------------------------------------------------
*************** In fgDebugCheckBBlist

*************** Starting PHASE Early Value Propagation
*************** In optEarlyProp()
optEarlyProp Marking a null check for removal
N002 (  2,  2) [000086] ---X--------              *  NULLCHECK byte  
N001 (  1,  1) [000085] ------------              \--*  LCL_VAR   ref    V00 arg0         u:1


Removing statement STMT00021 (IL 0x006...  ???)
N002 (  2,  2) [000086] -----O------              *  NULLCHECK byte  
N001 (  1,  1) [000085] ------------              \--*  LCL_VAR   ref    V00 arg0         u:1
 in BB03 as useless:

optFoldNullCheck removed tree:
N002 (  2,  2) [000086] -----O------              *  NULLCHECK byte  
N001 (  1,  1) [000085] ------------              \--*  LCL_VAR   ref    V00 arg0         u:1


After optEarlyProp:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)-> BB03 ( cond )                     i label target hascall newobj 
BB02 [0007]  1       BB01                  0.50     [006..007)-> BB06 (always)                     i 
BB03 [0008]  1       BB01                  0.50     [006..007)-> BB05 ( cond )                     i label target idxlen nullcheck 
BB04 [0014]  1       BB03                  0.25     [006..007)                                     i hascall gcsafe 
BB05 [0015]  2       BB03,BB04             0.50     [006..007)                                     i label target idxlen nullcheck 
BB06 [0009]  2       BB02,BB05             1        [???..???)        (return)                     internal label target hascall gcsafe newobj 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..012) -> BB03 (cond), preds={} succs={BB02,BB03}

***** BB01
STMT00000 (IL 0x000...0x011)
N005 ( 16, 16) [000004] -AC-----R---              *  ASG       ref   
N004 (  1,  1) [000003] D------N----              +--*  LCL_VAR   ref    V02 tmp1         d:1
N003 ( 16, 16) [000002] --C---------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST
N002 (  2, 10) [000001] H----------- arg0 in rcx     \--*  CNS_INT(h) long   0xd1ffab1e token

***** BB01
STMT00006 (IL   ???...  ???)
N005 ( 16, 16) [000021] -AC-----R---              *  ASG       ref   
N004 (  1,  1) [000020] D------N----              +--*  LCL_VAR   ref    V04 tmp3         d:1
N003 ( 16, 16) [000019] --C---------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST
N002 (  2, 10) [000018] H----------- arg0 in rcx     \--*  CNS_INT(h) long   0xd1ffab1e token

***** BB01
STMT00013 (IL   ???...  ???)
N013 ( 26, 35) [000039] -ACXG---R---              *  ASG       ref   
N012 (  4,  4) [000038] D--XG--N----              +--*  IND       ref   
N011 (  2,  2) [000140] -------N----              |  \--*  ADD       byref 
N009 (  1,  1) [000035] ------------              |     +--*  LCL_VAR   ref    V04 tmp3         u:1
N010 (  1,  1) [000139] ------------              |     \--*  CNS_INT   long   8 field offset Fseq[_array]
N008 ( 21, 30) [000047] --CXG-------              \--*  COMMA     ref   
N005 ( 17, 18) [000046] H-CXG-------                 +--*  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS
N003 (  2, 10) [000044] ------------ arg0 in rcx     |  +--*  CNS_INT   long   0x7ffa40fb0028
N004 (  1,  1) [000045] ------------ arg1 in rdx     |  \--*  CNS_INT   int    6
N007 (  4, 12) [000042] n---G-------                 \--*  IND       ref   
N006 (  2, 10) [000143] I-----------                    \--*  CNS_INT(h) long   0xd1ffab1e static Fseq[Value]

***** BB01
STMT00008 (IL   ???...  ???)
N006 (  6,  6) [000026] -A-XG-------              *  ASG       ref   
N004 (  4,  4) [000025] D--XG--N----              +--*  IND       ref   
N003 (  2,  2) [000145] -------N----              |  \--*  ADD       byref 
N001 (  1,  1) [000005] ------------              |     +--*  LCL_VAR   ref    V02 tmp1         u:1
N002 (  1,  1) [000144] ------------              |     \--*  CNS_INT   long   16 field offset Fseq[_tokensBuffer]
N005 (  1,  1) [000024] ------------              \--*  LCL_VAR   ref    V04 tmp3         u:1 (last use)

***** BB01
STMT00010 (IL   ???...  ???)
N006 (  6,  6) [000032] -A-XG-------              *  ASG       ref   
N004 (  4,  4) [000031] D--XG--N----              +--*  IND       ref   
N003 (  2,  2) [000147] -------N----              |  \--*  ADD       byref 
N001 (  1,  1) [000029] ------------              |     +--*  LCL_VAR   ref    V02 tmp1         u:1
N002 (  1,  1) [000146] ------------              |     \--*  CNS_INT   long   8 field offset Fseq[_reader]
N005 (  1,  1) [000030] ------------              \--*  CNS_INT   ref    null

***** BB01
STMT00014 (IL 0x006...  ???)
N004 (  5,  5) [000052] ------------              *  JTRUE     void  
N003 (  3,  3) [000051] J------N----              \--*  NE        int   
N001 (  1,  1) [000008] ------------                 +--*  LCL_VAR   ref    V00 arg0         u:1
N002 (  1,  1) [000050] ------------                 \--*  CNS_INT   ref    null

------------ BB02 [006..007) -> BB06 (always), preds={BB01} succs={BB06}

***** BB02
STMT00019 (IL 0x006...  ???)
N007 ( 10,  8) [000154] -A----------              *  COMMA     void  
N003 (  5,  4) [000150] -A------R---              +--*  ASG       byref 
N002 (  3,  2) [000148] D------N----              |  +--*  LCL_VAR   byref  V21 tmp20        d:1
N001 (  1,  1) [000149] ------------              |  \--*  CNS_INT   byref  0
N006 (  5,  4) [000153] -A------R---              \--*  ASG       int   
N005 (  3,  2) [000151] D------N----                 +--*  LCL_VAR   int    V22 tmp21        d:1
N004 (  1,  1) [000152] ------------                 \--*  CNS_INT   int    0

***** BB02
STMT00020 (IL 0x006...  ???)
N007 ( 14, 10) [000161] -A----------              *  COMMA     void  
N003 (  7,  5) [000157] -A------R---              +--*  ASG       byref 
N002 (  3,  2) [000155] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        d:3
N001 (  3,  2) [000156] ------------              |  \--*  LCL_VAR   byref  V21 tmp20        u:1 (last use)
N006 (  7,  5) [000160] -A------R---              \--*  ASG       int   
N005 (  3,  2) [000158] D------N----                 +--*  LCL_VAR   int    V18 tmp17        d:3
N004 (  3,  2) [000159] ------------                 \--*  LCL_VAR   int    V22 tmp21        u:1 (last use)

------------ BB03 [006..007) -> BB05 (cond), preds={BB01} succs={BB04,BB05}

***** BB03
STMT00016 (IL 0x006...  ???)
N003 (  0,  0) [000168] ------------              *  COMMA     void  
N001 (  0,  0) [000164] ------------              +--*  NOP       void  
N002 (  0,  0) [000167] ------------              \--*  NOP       void  

***** BB03
STMT00026 (IL 0x006...  ???)
N005 (  7,  6) [000112] -A--G---R---              *  ASG       byref 
N004 (  3,  2) [000111] D------N----              +--*  LCL_VAR   byref  V09 tmp8         d:1
N003 (  3,  3) [000173] ------------              \--*  ADD       byref 
N001 (  1,  1) [000171] ------------                 +--*  LCL_VAR   ref    V00 arg0         u:1
N002 (  1,  1) [000172] ------------                 \--*  CNS_INT   long   12 field offset Fseq[_firstChar]

***** BB03
STMT00027 (IL 0x006...  ???)
N004 (  3,  3) [000114] -A-X----R---              *  ASG       int   
N003 (  1,  1) [000113] D------N----              +--*  LCL_VAR   int    V08 tmp7         d:1
N002 (  3,  3) [000057] ---X--------              \--*  ARR_LENGTH int   
N001 (  1,  1) [000056] ------------                 \--*  LCL_VAR   ref    V00 arg0         u:1 (last use)

***** BB03
STMT00031 (IL 0x006...  ???)
N004 (  8, 15) [000133] -A--G---R---              *  ASG       ref   
N003 (  3,  2) [000132] D------N----              +--*  LCL_VAR   ref    V13 tmp12        d:1
N002 (  4, 12) [000119] #---G-------              \--*  IND       ref   
N001 (  2, 10) [000118] H-----------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]

***** BB03
STMT00032 (IL 0x006...  ???)
N004 (  8, 15) [000135] -A--G---R---              *  ASG       ref   
N003 (  3,  2) [000134] D------N----              +--*  LCL_VAR   ref    V14 tmp13        d:1
N002 (  4, 12) [000121] #---G-------              \--*  IND       ref   
N001 (  2, 10) [000120] H-----------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]

***** BB03
STMT00029 (IL 0x006...  ???)
N004 (  5,  5) [000128] ------------              *  JTRUE     void  
N003 (  3,  3) [000090] J------N----              \--*  GE        int   
N001 (  1,  1) [000088] ------------                 +--*  LCL_VAR   int    V08 tmp7         u:1
N002 (  1,  1) [000089] ------------                 \--*  CNS_INT   int    0

------------ BB04 [006..007), preds={BB03} succs={BB05}

***** BB04
STMT00030 (IL 0x006...  ???)
N005 ( 20, 11) [000131] --CXG-------              *  CALL      void   System.Diagnostics.Debug.Fail
N003 (  3,  2) [000129] ------------ arg0 in rcx  +--*  LCL_VAR   ref    V13 tmp12        u:1 (last use)
N004 (  3,  2) [000130] ------------ arg1 in rdx  \--*  LCL_VAR   ref    V14 tmp13        u:1 (last use)

------------ BB05 [006..007), preds={BB03,BB04} succs={BB06}

***** BB05
STMT00023 (IL 0x006...  ???)
N003 (  7,  5) [000100] -A------R---              *  ASG       byref 
N002 (  3,  2) [000099] D------N----              +--*  LCL_VAR   byref  V23 tmp22        d:1
N001 (  3,  2) [000096] ------------              \--*  LCL_VAR   byref  V09 tmp8         u:1 (last use)

***** BB05
STMT00024 (IL 0x006...  ???)
N003 (  7,  5) [000179] -A------R---              *  ASG       byref 
N002 (  3,  2) [000177] D------N----              +--*  LCL_VAR   byref  V19 tmp18        d:1
N001 (  3,  2) [000178] -------N----              \--*  LCL_VAR   byref  V23 tmp22        u:1 (last use)

***** BB05
STMT00025 (IL 0x006...  ???)
N003 (  5,  4) [000110] -A------R---              *  ASG       int   
N002 (  3,  2) [000109] D------N----              +--*  LCL_VAR   int    V20 tmp19        d:1
N001 (  1,  1) [000108] ------------              \--*  LCL_VAR   int    V08 tmp7         u:1 (last use)

***** BB05
STMT00018 (IL 0x006...  ???)
N007 ( 14, 10) [000186] -A----------              *  COMMA     void  
N003 (  7,  5) [000182] -A------R---              +--*  ASG       byref 
N002 (  3,  2) [000180] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        d:2
N001 (  3,  2) [000181] ------------              |  \--*  LCL_VAR   byref  V19 tmp18        u:1 (last use)
N006 (  7,  5) [000185] -A------R---              \--*  ASG       int   
N005 (  3,  2) [000183] D------N----                 +--*  LCL_VAR   int    V18 tmp17        d:2
N004 (  3,  2) [000184] ------------                 \--*  LCL_VAR   int    V20 tmp19        u:1 (last use)

------------ BB06 [???..???) (return), preds={BB02,BB05} succs={}

***** BB06
STMT00034 (IL   ???...  ???)
N005 (  0,  0) [000223] -A------R---              *  ASG       int   
N004 (  0,  0) [000221] D------N----              +--*  LCL_VAR   int    V18 tmp17        d:1
N003 (  0,  0) [000222] ------------              \--*  PHI       int   
N001 (  0,  0) [000226] ------------ pred BB02       +--*  PHI_ARG   int    V18 tmp17        u:3
N002 (  0,  0) [000224] ------------ pred BB05       \--*  PHI_ARG   int    V18 tmp17        u:2

***** BB06
STMT00033 (IL   ???...  ???)
N005 (  0,  0) [000220] -A------R---              *  ASG       byref 
N004 (  0,  0) [000218] D------N----              +--*  LCL_VAR   byref  V17 tmp16        d:1
N003 (  0,  0) [000219] ------------              \--*  PHI       byref 
N001 (  0,  0) [000227] ------------ pred BB02       +--*  PHI_ARG   byref  V17 tmp16        u:3
N002 (  0,  0) [000225] ------------ pred BB05       \--*  PHI_ARG   byref  V17 tmp16        u:2

***** BB06
STMT00003 (IL   ???...  ???)
N007 ( 14, 10) [000193] -A----------              *  COMMA     void  
N003 (  7,  5) [000189] -A------R---              +--*  ASG       byref 
N002 (  3,  2) [000187] D------N----              |  +--*  LCL_VAR   byref  V15 tmp14        d:1
N001 (  3,  2) [000188] ------------              |  \--*  LCL_VAR   byref  V17 tmp16        u:1 (last use)
N006 (  7,  5) [000192] -A------R---              \--*  ASG       int   
N005 (  3,  2) [000190] D------N----                 +--*  LCL_VAR   int    V16 tmp15        d:1
N004 (  3,  2) [000191] ------------                 \--*  LCL_VAR   int    V18 tmp17        u:1 (last use)

***** BB06
STMT00004 (IL   ???...  ???)
N023 ( 40, 30) [000011] -ACXG-------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer.TokenizeLine
N003 (  1,  3) [000214] -A------R-L- this SETUP   +--*  ASG       ref   
N002 (  1,  1) [000213] D------N----              |  +--*  LCL_VAR   ref    V26 tmp25        d:1
N001 (  1,  1) [000007] ------------              |  \--*  LCL_VAR   ref    V02 tmp1         u:1 (last use)
N019 ( 18, 15) [000212] -A--------L- arg1 SETUP   +--*  COMMA     void  
N012 ( 10,  8) [000205] -A----------              |  +--*  COMMA     void  
N007 (  3,  3) [000200] -A------R---              |  |  +--*  ASG       byref 
N006 (  1,  1) [000199] D------N----              |  |  |  +--*  LCL_VAR   byref  V25 tmp24        d:1
N005 (  3,  3) [000197] ------------              |  |  |  \--*  ADDR      byref 
N004 (  3,  2) [000198] -------N----              |  |  |     \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(AX) V24 tmp23        
N011 (  7,  5) [000204] -A----------              |  |  \--*  ASG       byref 
N009 (  3,  2) [000202] *------N----              |  |     +--*  IND       byref 
N008 (  1,  1) [000201] ------------              |  |     |  \--*  LCL_VAR   byref  V25 tmp24        u:1 Zero Fseq[_pointer]
N010 (  3,  2) [000203] -------N----              |  |     \--*  LCL_VAR   byref  V15 tmp14        u:1 (last use)
N018 (  8,  7) [000211] -A----------              |  \--*  ASG       int   
N016 (  4,  4) [000209] *------N----              |     +--*  IND       int   
N015 (  2,  2) [000208] -------N----              |     |  \--*  ADD       byref 
N013 (  1,  1) [000206] ------------              |     |     +--*  LCL_VAR   byref  V25 tmp24        u:1 (last use)
N014 (  1,  1) [000207] ------------              |     |     \--*  CNS_INT   long   8 Fseq[_length]
N017 (  3,  2) [000210] -------N----              |     \--*  LCL_VAR   int    V16 tmp15        u:1 (last use)
N020 (  1,  1) [000215] ------------ this in rcx  +--*  LCL_VAR   ref    V26 tmp25        u:1 (last use)
N022 (  3,  3) [000217] ------------ arg1 in rdx  \--*  ADDR      byref 
N021 (  3,  2) [000216] -------N----                 \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(AX) V24 tmp23        

***** BB06
STMT00005 (IL 0x011...  ???)
N001 (  0,  0) [000017] ------------              *  RETURN    void  

-------------------------------------------------------------------------------------------------------------------

*************** Finishing PHASE Early Value Propagation

*************** Starting PHASE Do value numbering

*************** In fgValueNumber()
Memory Initial Value in BB01 is: $81
The SSA definition for ByrefExposed (#1) at start of BB01 is $81 {InitVal($41)}
The SSA definition for GcHeap (#1) at start of BB01 is $81 {InitVal($41)}

***** BB01, STMT00000(before)
N005 ( 16, 16) [000004] -AC-----R---              *  ASG       ref   
N004 (  1,  1) [000003] D------N----              +--*  LCL_VAR   ref    V02 tmp1         d:1
N003 ( 16, 16) [000002] --C---------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST
N002 (  2, 10) [000001] H----------- arg0 in rcx     \--*  CNS_INT(h) long   0xd1ffab1e token

N001 [000137]   ARGPLACE  => $c0 {c0}
N002 [000001]   CNS_INT(h) 0xd1ffab1e token => $100 {Hnd const: 0x00000000D1FFAB1E}
VN of ARGPLACE tree [000137] updated to $100 {Hnd const: 0x00000000D1FFAB1E}
N003 [000002]   CALL help => $180 {JitNew($100, $140)}
N004 [000003]   LCL_VAR   V02 tmp1         d:1 => $180 {JitNew($100, $140)}
N005 [000004]   ASG       => $180 {JitNew($100, $140)}

***** BB01, STMT00000(after)
N005 ( 16, 16) [000004] -AC-----R---              *  ASG       ref    $180
N004 (  1,  1) [000003] D------N----              +--*  LCL_VAR   ref    V02 tmp1         d:1 $180
N003 ( 16, 16) [000002] --C---------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST $180
N002 (  2, 10) [000001] H----------- arg0 in rcx     \--*  CNS_INT(h) long   0xd1ffab1e token $100

---------

***** BB01, STMT00006(before)
N005 ( 16, 16) [000021] -AC-----R---              *  ASG       ref   
N004 (  1,  1) [000020] D------N----              +--*  LCL_VAR   ref    V04 tmp3         d:1
N003 ( 16, 16) [000019] --C---------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST
N002 (  2, 10) [000018] H----------- arg0 in rcx     \--*  CNS_INT(h) long   0xd1ffab1e token

N001 [000138]   ARGPLACE  => $c1 {c1}
N002 [000018]   CNS_INT(h) 0xd1ffab1e token => $101 {Hnd const: 0x00000000D1FFAB1E}
VN of ARGPLACE tree [000138] updated to $101 {Hnd const: 0x00000000D1FFAB1E}
N003 [000019]   CALL help => $181 {JitNew($101, $142)}
N004 [000020]   LCL_VAR   V04 tmp3         d:1 => $181 {JitNew($101, $142)}
N005 [000021]   ASG       => $181 {JitNew($101, $142)}

***** BB01, STMT00006(after)
N005 ( 16, 16) [000021] -AC-----R---              *  ASG       ref    $181
N004 (  1,  1) [000020] D------N----              +--*  LCL_VAR   ref    V04 tmp3         d:1 $181
N003 ( 16, 16) [000019] --C---------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST $181
N002 (  2, 10) [000018] H----------- arg0 in rcx     \--*  CNS_INT(h) long   0xd1ffab1e token $101

---------

***** BB01, STMT00013(before)
N013 ( 26, 35) [000039] -ACXG---R---              *  ASG       ref   
N012 (  4,  4) [000038] D--XG--N----              +--*  IND       ref   
N011 (  2,  2) [000140] -------N----              |  \--*  ADD       byref 
N009 (  1,  1) [000035] ------------              |     +--*  LCL_VAR   ref    V04 tmp3         u:1
N010 (  1,  1) [000139] ------------              |     \--*  CNS_INT   long   8 field offset Fseq[_array]
N008 ( 21, 30) [000047] --CXG-------              \--*  COMMA     ref   
N005 ( 17, 18) [000046] H-CXG-------                 +--*  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS
N003 (  2, 10) [000044] ------------ arg0 in rcx     |  +--*  CNS_INT   long   0x7ffa40fb0028
N004 (  1,  1) [000045] ------------ arg1 in rdx     |  \--*  CNS_INT   int    6
N007 (  4, 12) [000042] n---G-------                 \--*  IND       ref   
N006 (  2, 10) [000143] I-----------                    \--*  CNS_INT(h) long   0xd1ffab1e static Fseq[Value]

N001 [000141]   ARGPLACE  => $c2 {c2}
N002 [000142]   ARGPLACE  => $1c0 {1c0}
N003 [000044]   CNS_INT   0x7ffa40fb0028 => $200 {LngCns:  0x7ffa40fb0028}
N004 [000045]   CNS_INT   6 => $42 {IntCns 6}
VN of ARGPLACE tree [000141] updated to $200 {LngCns:  0x7ffa40fb0028}
VN of ARGPLACE tree [000142] updated to $42 {IntCns 6}
N005 [000046]   CALL help => $281 {norm=$280 {ClassinitSharedDynamicclass($200, $42)}, exc=$182 {HelperMultipleExc()}}
N006 [000143]   CNS_INT(h) 0xd1ffab1e static Fseq[Value] => $102 {Hnd const: 0x00000000D1FFAB1E}
N007 [000042]   IND       => <l:$2c0 {ByrefExposedLoad($43, $102, $81)}, c:$144 {144}>
N008 [000047]   COMMA     => <l:$184 {norm=$2c0 {ByrefExposedLoad($43, $102, $81)}, exc=$182 {HelperMultipleExc()}}, c:$183 {norm=$144 {144}, exc=$182 {HelperMultipleExc()}}>
N009 [000035]   LCL_VAR   V04 tmp3         u:1 => $181 {JitNew($101, $142)}
N010 [000139]   CNS_INT   8 field offset Fseq[_array] => $201 {LngCns:  8}
N011 [000140]   ADD       => $300 {ADD($181, $201)}
  VNApplySelectors:
    VNForHandle(_array) is $103, fieldType is ref
    VNForMapSelect($81, $103):ref returns $185 {$81[$103]}
    VNForMapSelect($185, $181):ref returns $186 {$185[$181]}
    VNForMapStore($185, $181, $2c0):ref returns $2c1 {$185[$181 := $2c0]}
  VNApplySelectorsAssign:
    VNForHandle(_array) is $103, fieldType is ref
    VNForMapStore($81, $103, $2c1):ref returns $2c2 {$81[$103 := $2c1]}
  fgCurMemoryVN[GcHeap] assigned for StoreField at [000039] to VN: $2c2.
N013 [000039]   ASG       => $VN.Void

***** BB01, STMT00013(after)
N013 ( 26, 35) [000039] -ACXG---R---              *  ASG       ref    $VN.Void
N012 (  4,  4) [000038] D--XG--N----              +--*  IND       ref    $2c0
N011 (  2,  2) [000140] -------N----              |  \--*  ADD       byref  $300
N009 (  1,  1) [000035] ------------              |     +--*  LCL_VAR   ref    V04 tmp3         u:1 $181
N010 (  1,  1) [000139] ------------              |     \--*  CNS_INT   long   8 field offset Fseq[_array] $201
N008 ( 21, 30) [000047] --CXG-------              \--*  COMMA     ref    <l:$184, c:$183>
N005 ( 17, 18) [000046] H-CXG-------                 +--*  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS $281
N003 (  2, 10) [000044] ------------ arg0 in rcx     |  +--*  CNS_INT   long   0x7ffa40fb0028 $200
N004 (  1,  1) [000045] ------------ arg1 in rdx     |  \--*  CNS_INT   int    6 $42
N007 (  4, 12) [000042] n---G-------                 \--*  IND       ref    <l:$2c0, c:$144>
N006 (  2, 10) [000143] I-----------                    \--*  CNS_INT(h) long   0xd1ffab1e static Fseq[Value] $102

---------

***** BB01, STMT00008(before)
N006 (  6,  6) [000026] -A-XG-------              *  ASG       ref   
N004 (  4,  4) [000025] D--XG--N----              +--*  IND       ref   
N003 (  2,  2) [000145] -------N----              |  \--*  ADD       byref 
N001 (  1,  1) [000005] ------------              |     +--*  LCL_VAR   ref    V02 tmp1         u:1
N002 (  1,  1) [000144] ------------              |     \--*  CNS_INT   long   16 field offset Fseq[_tokensBuffer]
N005 (  1,  1) [000024] ------------              \--*  LCL_VAR   ref    V04 tmp3         u:1 (last use)

N001 [000005]   LCL_VAR   V02 tmp1         u:1 => $180 {JitNew($100, $140)}
N002 [000144]   CNS_INT   16 field offset Fseq[_tokensBuffer] => $202 {LngCns:  16}
N003 [000145]   ADD       => $301 {ADD($180, $202)}
N005 [000024]   LCL_VAR   V04 tmp3         u:1 (last use) => $181 {JitNew($101, $142)}
  VNApplySelectors:
    VNForHandle(_tokensBuffer) is $104, fieldType is ref
      AX2: $104 != $103 ==> select([$2c2]store($81, $103, $2c1), $104) ==> select($81, $104).
    VNForMapSelect($2c2, $104):ref returns $187 {$81[$104]}
    VNForMapSelect($187, $180):ref returns $188 {$187[$180]}
    VNForMapStore($187, $180, $181):ref returns $2c3 {$187[$180 := $181]}
  VNApplySelectorsAssign:
    VNForHandle(_tokensBuffer) is $104, fieldType is ref
    VNForMapStore($2c2, $104, $2c3):ref returns $2c4 {$2c2[$104 := $2c3]}
  fgCurMemoryVN[GcHeap] assigned for StoreField at [000026] to VN: $2c4.
N006 [000026]   ASG       => $VN.Void

***** BB01, STMT00008(after)
N006 (  6,  6) [000026] -A-XG-------              *  ASG       ref    $VN.Void
N004 (  4,  4) [000025] D--XG--N----              +--*  IND       ref    $181
N003 (  2,  2) [000145] -------N----              |  \--*  ADD       byref  $301
N001 (  1,  1) [000005] ------------              |     +--*  LCL_VAR   ref    V02 tmp1         u:1 $180
N002 (  1,  1) [000144] ------------              |     \--*  CNS_INT   long   16 field offset Fseq[_tokensBuffer] $202
N005 (  1,  1) [000024] ------------              \--*  LCL_VAR   ref    V04 tmp3         u:1 (last use) $181

---------

***** BB01, STMT00010(before)
N006 (  6,  6) [000032] -A-XG-------              *  ASG       ref   
N004 (  4,  4) [000031] D--XG--N----              +--*  IND       ref   
N003 (  2,  2) [000147] -------N----              |  \--*  ADD       byref 
N001 (  1,  1) [000029] ------------              |     +--*  LCL_VAR   ref    V02 tmp1         u:1
N002 (  1,  1) [000146] ------------              |     \--*  CNS_INT   long   8 field offset Fseq[_reader]
N005 (  1,  1) [000030] ------------              \--*  CNS_INT   ref    null

N001 [000029]   LCL_VAR   V02 tmp1         u:1 => $180 {JitNew($100, $140)}
N002 [000146]   CNS_INT   8 field offset Fseq[_reader] => $201 {LngCns:  8}
N003 [000147]   ADD       => $302 {ADD($180, $201)}
N005 [000030]   CNS_INT   null => $VN.Null
  VNApplySelectors:
    VNForHandle(_reader) is $105, fieldType is ref
      AX2: $105 != $104 ==> select([$2c4]store($2c2, $104, $2c3), $105) ==> select($2c2, $105).
      AX2: $105 != $103 ==> select([$2c2]store($81, $103, $2c1), $105) ==> select($81, $105).
    VNForMapSelect($2c4, $105):ref returns $189 {$81[$105]}
    VNForMapSelect($189, $180):ref returns $18a {$189[$180]}
    VNForMapStore($189, $180, $0):ref returns $2c5 {$189[$180 := $VN.Null]}
  VNApplySelectorsAssign:
    VNForHandle(_reader) is $105, fieldType is ref
    VNForMapStore($2c4, $105, $2c5):ref returns $2c6 {$2c4[$105 := $2c5]}
  fgCurMemoryVN[GcHeap] assigned for StoreField at [000032] to VN: $2c6.
N006 [000032]   ASG       => $VN.Void

***** BB01, STMT00010(after)
N006 (  6,  6) [000032] -A-XG-------              *  ASG       ref    $VN.Void
N004 (  4,  4) [000031] D--XG--N----              +--*  IND       ref    $VN.Null
N003 (  2,  2) [000147] -------N----              |  \--*  ADD       byref  $302
N001 (  1,  1) [000029] ------------              |     +--*  LCL_VAR   ref    V02 tmp1         u:1 $180
N002 (  1,  1) [000146] ------------              |     \--*  CNS_INT   long   8 field offset Fseq[_reader] $201
N005 (  1,  1) [000030] ------------              \--*  CNS_INT   ref    null $VN.Null

---------

***** BB01, STMT00014(before)
N004 (  5,  5) [000052] ------------              *  JTRUE     void  
N003 (  3,  3) [000051] J------N----              \--*  NE        int   
N001 (  1,  1) [000008] ------------                 +--*  LCL_VAR   ref    V00 arg0         u:1
N002 (  1,  1) [000050] ------------                 \--*  CNS_INT   ref    null

N001 [000008]   LCL_VAR   V00 arg0         u:1 => $80 {InitVal($40)}
N002 [000050]   CNS_INT   null => $VN.Null
N003 [000051]   NE        => $340 {NE($80, $0)}

***** BB01, STMT00014(after)
N004 (  5,  5) [000052] ------------              *  JTRUE     void  
N003 (  3,  3) [000051] J------N----              \--*  NE        int    $340
N001 (  1,  1) [000008] ------------                 +--*  LCL_VAR   ref    V00 arg0         u:1 $80
N002 (  1,  1) [000050] ------------                 \--*  CNS_INT   ref    null $VN.Null

finish(BB01).
   Succ(BB02).
     Not yet completed.
     All preds complete, adding to allDone.
   Succ(BB03).
     Not yet completed.
     All preds complete, adding to allDone.
The SSA definition for ByrefExposed (#2) at start of BB03 is $2c6 {$2c4[$105 := $2c5]}
The SSA definition for GcHeap (#2) at start of BB03 is $2c6 {$2c4[$105 := $2c5]}

***** BB03, STMT00016(before)
N003 (  0,  0) [000168] ------------              *  COMMA     void  
N001 (  0,  0) [000164] ------------              +--*  NOP       void  
N002 (  0,  0) [000167] ------------              \--*  NOP       void  

N001 [000164]   NOP       => $380 {380}
N002 [000167]   NOP       => $381 {381}
N003 [000168]   COMMA     => $381 {381}

***** BB03, STMT00016(after)
N003 (  0,  0) [000168] ------------              *  COMMA     void   $381
N001 (  0,  0) [000164] ------------              +--*  NOP       void   $380
N002 (  0,  0) [000167] ------------              \--*  NOP       void   $381

---------

***** BB03, STMT00026(before)
N005 (  7,  6) [000112] -A--G---R---              *  ASG       byref 
N004 (  3,  2) [000111] D------N----              +--*  LCL_VAR   byref  V09 tmp8         d:1
N003 (  3,  3) [000173] ------------              \--*  ADD       byref 
N001 (  1,  1) [000171] ------------                 +--*  LCL_VAR   ref    V00 arg0         u:1
N002 (  1,  1) [000172] ------------                 \--*  CNS_INT   long   12 field offset Fseq[_firstChar]

N001 [000171]   LCL_VAR   V00 arg0         u:1 => $80 {InitVal($40)}
N002 [000172]   CNS_INT   12 field offset Fseq[_firstChar] => $203 {LngCns:  12}
N003 [000173]   ADD       => $303 {ADD($80, $203)}
N004 [000111]   LCL_VAR   V09 tmp8         d:1 => $303 {ADD($80, $203)}
N005 [000112]   ASG       => $303 {ADD($80, $203)}

***** BB03, STMT00026(after)
N005 (  7,  6) [000112] -A--G---R---              *  ASG       byref  $303
N004 (  3,  2) [000111] D------N----              +--*  LCL_VAR   byref  V09 tmp8         d:1 $303
N003 (  3,  3) [000173] ------------              \--*  ADD       byref  $303
N001 (  1,  1) [000171] ------------                 +--*  LCL_VAR   ref    V00 arg0         u:1 $80
N002 (  1,  1) [000172] ------------                 \--*  CNS_INT   long   12 field offset Fseq[_firstChar] $203

---------

***** BB03, STMT00027(before)
N004 (  3,  3) [000114] -A-X----R---              *  ASG       int   
N003 (  1,  1) [000113] D------N----              +--*  LCL_VAR   int    V08 tmp7         d:1
N002 (  3,  3) [000057] ---X--------              \--*  ARR_LENGTH int   
N001 (  1,  1) [000056] ------------                 \--*  LCL_VAR   ref    V00 arg0         u:1 (last use)

N001 [000056]   LCL_VAR   V00 arg0         u:1 (last use) => $80 {InitVal($40)}
N002 [000057]   ARR_LENGTH => $341 {norm=$400 {ARR_LENGTH($80)}, exc=$18b {NullPtrExc($80)}}
N003 [000113]   LCL_VAR   V08 tmp7         d:1 => $400 {ARR_LENGTH($80)}
N004 [000114]   ASG       => $341 {norm=$400 {ARR_LENGTH($80)}, exc=$18b {NullPtrExc($80)}}

***** BB03, STMT00027(after)
N004 (  3,  3) [000114] -A-X----R---              *  ASG       int    $341
N003 (  1,  1) [000113] D------N----              +--*  LCL_VAR   int    V08 tmp7         d:1 $400
N002 (  3,  3) [000057] ---X--------              \--*  ARR_LENGTH int    $341
N001 (  1,  1) [000056] ------------                 \--*  LCL_VAR   ref    V00 arg0         u:1 (last use) $80

---------

***** BB03, STMT00031(before)
N004 (  8, 15) [000133] -A--G---R---              *  ASG       ref   
N003 (  3,  2) [000132] D------N----              +--*  LCL_VAR   ref    V13 tmp12        d:1
N002 (  4, 12) [000119] #---G-------              \--*  IND       ref   
N001 (  2, 10) [000118] H-----------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]

N001 [000118]   CNS_INT(h) 0xD1FFAB1E [ICON_STR_HDL] => $106 {Hnd const: 0x00000000D1FFAB1E}
    VNForMapSelect($2, $106):ref returns $18c {$VN.ReadOnlyHeap[$106]}
    VNForMapSelect($2, $106):ref returns $18c {$VN.ReadOnlyHeap[$106]}
N002 [000119]   IND       => $18c {$VN.ReadOnlyHeap[$106]}
N003 [000132]   LCL_VAR   V13 tmp12        d:1 => $18c {$VN.ReadOnlyHeap[$106]}
N004 [000133]   ASG       => $18c {$VN.ReadOnlyHeap[$106]}

***** BB03, STMT00031(after)
N004 (  8, 15) [000133] -A--G---R---              *  ASG       ref    $18c
N003 (  3,  2) [000132] D------N----              +--*  LCL_VAR   ref    V13 tmp12        d:1 $18c
N002 (  4, 12) [000119] #---G-------              \--*  IND       ref    $18c
N001 (  2, 10) [000118] H-----------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL] $106

---------

***** BB03, STMT00032(before)
N004 (  8, 15) [000135] -A--G---R---              *  ASG       ref   
N003 (  3,  2) [000134] D------N----              +--*  LCL_VAR   ref    V14 tmp13        d:1
N002 (  4, 12) [000121] #---G-------              \--*  IND       ref   
N001 (  2, 10) [000120] H-----------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL]

N001 [000120]   CNS_INT(h) 0xD1FFAB1E [ICON_STR_HDL] => $106 {Hnd const: 0x00000000D1FFAB1E}
    VNForMapSelect($2, $106):ref returns $18c {$VN.ReadOnlyHeap[$106]}
    VNForMapSelect($2, $106):ref returns $18c {$VN.ReadOnlyHeap[$106]}
N002 [000121]   IND       => $18c {$VN.ReadOnlyHeap[$106]}
N003 [000134]   LCL_VAR   V14 tmp13        d:1 => $18c {$VN.ReadOnlyHeap[$106]}
N004 [000135]   ASG       => $18c {$VN.ReadOnlyHeap[$106]}

***** BB03, STMT00032(after)
N004 (  8, 15) [000135] -A--G---R---              *  ASG       ref    $18c
N003 (  3,  2) [000134] D------N----              +--*  LCL_VAR   ref    V14 tmp13        d:1 $18c
N002 (  4, 12) [000121] #---G-------              \--*  IND       ref    $18c
N001 (  2, 10) [000120] H-----------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL] $106

---------

***** BB03, STMT00029(before)
N004 (  5,  5) [000128] ------------              *  JTRUE     void  
N003 (  3,  3) [000090] J------N----              \--*  GE        int   
N001 (  1,  1) [000088] ------------                 +--*  LCL_VAR   int    V08 tmp7         u:1
N002 (  1,  1) [000089] ------------                 \--*  CNS_INT   int    0

N001 [000088]   LCL_VAR   V08 tmp7         u:1 => $400 {ARR_LENGTH($80)}
N002 [000089]   CNS_INT   0 => $40 {IntCns 0}
N003 [000090]   GE        => $342 { {IntCns 0} LE  {ARR_LENGTH($80)}}

***** BB03, STMT00029(after)
N004 (  5,  5) [000128] ------------              *  JTRUE     void  
N003 (  3,  3) [000090] J------N----              \--*  GE        int    $342
N001 (  1,  1) [000088] ------------                 +--*  LCL_VAR   int    V08 tmp7         u:1 $400
N002 (  1,  1) [000089] ------------                 \--*  CNS_INT   int    0 $40

finish(BB03).
   Succ(BB04).
     Not yet completed.
     All preds complete, adding to allDone.
   Succ(BB05).
     Not yet completed.
     Not all preds complete  Adding to notallDone, if necessary...
       Was necessary.
The SSA definition for ByrefExposed (#2) at start of BB04 is $2c6 {$2c4[$105 := $2c5]}
The SSA definition for GcHeap (#2) at start of BB04 is $2c6 {$2c4[$105 := $2c5]}

***** BB04, STMT00030(before)
N005 ( 20, 11) [000131] --CXG-------              *  CALL      void   System.Diagnostics.Debug.Fail
N003 (  3,  2) [000129] ------------ arg0 in rcx  +--*  LCL_VAR   ref    V13 tmp12        u:1 (last use)
N004 (  3,  2) [000130] ------------ arg1 in rdx  \--*  LCL_VAR   ref    V14 tmp13        u:1 (last use)

N001 [000175]   ARGPLACE  => $147 {147}
N002 [000176]   ARGPLACE  => $148 {148}
N003 [000129]   LCL_VAR   V13 tmp12        u:1 (last use) => $18c {$VN.ReadOnlyHeap[$106]}
N004 [000130]   LCL_VAR   V14 tmp13        u:1 (last use) => $18c {$VN.ReadOnlyHeap[$106]}
VN of ARGPLACE tree [000175] updated to $18c {$VN.ReadOnlyHeap[$106]}
VN of ARGPLACE tree [000176] updated to $18c {$VN.ReadOnlyHeap[$106]}
  fgCurMemoryVN[GcHeap] assigned for CALL at [000131] to VN: $149.
N005 [000131]   CALL      => $VN.Void

***** BB04, STMT00030(after)
N005 ( 20, 11) [000131] --CXG-------              *  CALL      void   System.Diagnostics.Debug.Fail $VN.Void
N003 (  3,  2) [000129] ------------ arg0 in rcx  +--*  LCL_VAR   ref    V13 tmp12        u:1 (last use) $18c
N004 (  3,  2) [000130] ------------ arg1 in rdx  \--*  LCL_VAR   ref    V14 tmp13        u:1 (last use) $18c

finish(BB04).
   Succ(BB05).
     Not yet completed.
     All preds complete, adding to allDone.
  Building phi application: $42 = SSA# 6.
  Building phi application: $44 = SSA# 2.
  Building phi application: $18d = phi($44, $42).
The SSA definition for GcHeap (#5) at start of BB05 is $18e {PhiMemoryDef($107, $18d)}

***** BB05, STMT00023(before)
N003 (  7,  5) [000100] -A------R---              *  ASG       byref 
N002 (  3,  2) [000099] D------N----              +--*  LCL_VAR   byref  V23 tmp22        d:1
N001 (  3,  2) [000096] ------------              \--*  LCL_VAR   byref  V09 tmp8         u:1 (last use)

N001 [000096]   LCL_VAR   V09 tmp8         u:1 (last use) => $303 {ADD($80, $203)}
N002 [000099]   LCL_VAR   V23 tmp22        d:1 => $303 {ADD($80, $203)}
N003 [000100]   ASG       => $303 {ADD($80, $203)}

***** BB05, STMT00023(after)
N003 (  7,  5) [000100] -A------R---              *  ASG       byref  $303
N002 (  3,  2) [000099] D------N----              +--*  LCL_VAR   byref  V23 tmp22        d:1 $303
N001 (  3,  2) [000096] ------------              \--*  LCL_VAR   byref  V09 tmp8         u:1 (last use) $303

---------

***** BB05, STMT00024(before)
N003 (  7,  5) [000179] -A------R---              *  ASG       byref 
N002 (  3,  2) [000177] D------N----              +--*  LCL_VAR   byref  V19 tmp18        d:1
N001 (  3,  2) [000178] -------N----              \--*  LCL_VAR   byref  V23 tmp22        u:1 (last use)

N001 [000178]   LCL_VAR   V23 tmp22        u:1 (last use) => $303 {ADD($80, $203)}
N002 [000177]   LCL_VAR   V19 tmp18        d:1 => $303 {ADD($80, $203)}
N003 [000179]   ASG       => $303 {ADD($80, $203)}

***** BB05, STMT00024(after)
N003 (  7,  5) [000179] -A------R---              *  ASG       byref  $303
N002 (  3,  2) [000177] D------N----              +--*  LCL_VAR   byref  V19 tmp18        d:1 $303
N001 (  3,  2) [000178] -------N----              \--*  LCL_VAR   byref  V23 tmp22        u:1 (last use) $303

---------

***** BB05, STMT00025(before)
N003 (  5,  4) [000110] -A------R---              *  ASG       int   
N002 (  3,  2) [000109] D------N----              +--*  LCL_VAR   int    V20 tmp19        d:1
N001 (  1,  1) [000108] ------------              \--*  LCL_VAR   int    V08 tmp7         u:1 (last use)

N001 [000108]   LCL_VAR   V08 tmp7         u:1 (last use) => $400 {ARR_LENGTH($80)}
N002 [000109]   LCL_VAR   V20 tmp19        d:1 => $400 {ARR_LENGTH($80)}
N003 [000110]   ASG       => $400 {ARR_LENGTH($80)}

***** BB05, STMT00025(after)
N003 (  5,  4) [000110] -A------R---              *  ASG       int    $400
N002 (  3,  2) [000109] D------N----              +--*  LCL_VAR   int    V20 tmp19        d:1 $400
N001 (  1,  1) [000108] ------------              \--*  LCL_VAR   int    V08 tmp7         u:1 (last use) $400

---------

***** BB05, STMT00018(before)
N007 ( 14, 10) [000186] -A----------              *  COMMA     void  
N003 (  7,  5) [000182] -A------R---              +--*  ASG       byref 
N002 (  3,  2) [000180] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        d:2
N001 (  3,  2) [000181] ------------              |  \--*  LCL_VAR   byref  V19 tmp18        u:1 (last use)
N006 (  7,  5) [000185] -A------R---              \--*  ASG       int   
N005 (  3,  2) [000183] D------N----                 +--*  LCL_VAR   int    V18 tmp17        d:2
N004 (  3,  2) [000184] ------------                 \--*  LCL_VAR   int    V20 tmp19        u:1 (last use)

N001 [000181]   LCL_VAR   V19 tmp18        u:1 (last use) => $303 {ADD($80, $203)}
N002 [000180]   LCL_VAR   V17 tmp16        d:2 => $303 {ADD($80, $203)}
N003 [000182]   ASG       => $303 {ADD($80, $203)}
N004 [000184]   LCL_VAR   V20 tmp19        u:1 (last use) => $400 {ARR_LENGTH($80)}
N005 [000183]   LCL_VAR   V18 tmp17        d:2 => $400 {ARR_LENGTH($80)}
N006 [000185]   ASG       => $400 {ARR_LENGTH($80)}
N007 [000186]   COMMA     => $400 {ARR_LENGTH($80)}

***** BB05, STMT00018(after)
N007 ( 14, 10) [000186] -A----------              *  COMMA     void   $400
N003 (  7,  5) [000182] -A------R---              +--*  ASG       byref  $303
N002 (  3,  2) [000180] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        d:2 $303
N001 (  3,  2) [000181] ------------              |  \--*  LCL_VAR   byref  V19 tmp18        u:1 (last use) $303
N006 (  7,  5) [000185] -A------R---              \--*  ASG       int    $400
N005 (  3,  2) [000183] D------N----                 +--*  LCL_VAR   int    V18 tmp17        d:2 $400
N004 (  3,  2) [000184] ------------                 \--*  LCL_VAR   int    V20 tmp19        u:1 (last use) $400

finish(BB05).
   Succ(BB06).
     Not yet completed.
     Not all preds complete  Adding to notallDone, if necessary...
       Was necessary.
The SSA definition for ByrefExposed (#2) at start of BB02 is $2c6 {$2c4[$105 := $2c5]}
The SSA definition for GcHeap (#2) at start of BB02 is $2c6 {$2c4[$105 := $2c5]}

***** BB02, STMT00019(before)
N007 ( 10,  8) [000154] -A----------              *  COMMA     void  
N003 (  5,  4) [000150] -A------R---              +--*  ASG       byref 
N002 (  3,  2) [000148] D------N----              |  +--*  LCL_VAR   byref  V21 tmp20        d:1
N001 (  1,  1) [000149] ------------              |  \--*  CNS_INT   byref  0
N006 (  5,  4) [000153] -A------R---              \--*  ASG       int   
N005 (  3,  2) [000151] D------N----                 +--*  LCL_VAR   int    V22 tmp21        d:1
N004 (  1,  1) [000152] ------------                 \--*  CNS_INT   int    0

N001 [000149]   CNS_INT   0 => $VN.Null
N002 [000148]   LCL_VAR   V21 tmp20        d:1 => $VN.Null
N003 [000150]   ASG       => $VN.Null
N004 [000152]   CNS_INT   0 => $40 {IntCns 0}
N005 [000151]   LCL_VAR   V22 tmp21        d:1 => $40 {IntCns 0}
N006 [000153]   ASG       => $40 {IntCns 0}
N007 [000154]   COMMA     => $40 {IntCns 0}

***** BB02, STMT00019(after)
N007 ( 10,  8) [000154] -A----------              *  COMMA     void   $40
N003 (  5,  4) [000150] -A------R---              +--*  ASG       byref  $VN.Null
N002 (  3,  2) [000148] D------N----              |  +--*  LCL_VAR   byref  V21 tmp20        d:1 $VN.Null
N001 (  1,  1) [000149] ------------              |  \--*  CNS_INT   byref  0 $VN.Null
N006 (  5,  4) [000153] -A------R---              \--*  ASG       int    $40
N005 (  3,  2) [000151] D------N----                 +--*  LCL_VAR   int    V22 tmp21        d:1 $40
N004 (  1,  1) [000152] ------------                 \--*  CNS_INT   int    0 $40

---------

***** BB02, STMT00020(before)
N007 ( 14, 10) [000161] -A----------              *  COMMA     void  
N003 (  7,  5) [000157] -A------R---              +--*  ASG       byref 
N002 (  3,  2) [000155] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        d:3
N001 (  3,  2) [000156] ------------              |  \--*  LCL_VAR   byref  V21 tmp20        u:1 (last use)
N006 (  7,  5) [000160] -A------R---              \--*  ASG       int   
N005 (  3,  2) [000158] D------N----                 +--*  LCL_VAR   int    V18 tmp17        d:3
N004 (  3,  2) [000159] ------------                 \--*  LCL_VAR   int    V22 tmp21        u:1 (last use)

N001 [000156]   LCL_VAR   V21 tmp20        u:1 (last use) => $VN.Null
N002 [000155]   LCL_VAR   V17 tmp16        d:3 => $VN.Null
N003 [000157]   ASG       => $VN.Null
N004 [000159]   LCL_VAR   V22 tmp21        u:1 (last use) => $40 {IntCns 0}
N005 [000158]   LCL_VAR   V18 tmp17        d:3 => $40 {IntCns 0}
N006 [000160]   ASG       => $40 {IntCns 0}
N007 [000161]   COMMA     => $40 {IntCns 0}

***** BB02, STMT00020(after)
N007 ( 14, 10) [000161] -A----------              *  COMMA     void   $40
N003 (  7,  5) [000157] -A------R---              +--*  ASG       byref  $VN.Null
N002 (  3,  2) [000155] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        d:3 $VN.Null
N001 (  3,  2) [000156] ------------              |  \--*  LCL_VAR   byref  V21 tmp20        u:1 (last use) $VN.Null
N006 (  7,  5) [000160] -A------R---              \--*  ASG       int    $40
N005 (  3,  2) [000158] D------N----                 +--*  LCL_VAR   int    V18 tmp17        d:3 $40
N004 (  3,  2) [000159] ------------                 \--*  LCL_VAR   int    V22 tmp21        u:1 (last use) $40

finish(BB02).
   Succ(BB06).
     Not yet completed.
     All preds complete, adding to allDone.
SSA PHI definition: set VN of local 18/1 to $440 {PhiDef($12, $1, $343)} .
SSA PHI definition: set VN of local 17/1 to $480 {PhiDef($11, $1, $343)} .
  Building phi application: $44 = SSA# 2.
  Building phi application: $46 = SSA# 5.
  Building phi application: $18f = phi($46, $44).
The SSA definition for GcHeap (#3) at start of BB06 is $190 {PhiMemoryDef($108, $18f)}

***** BB06, STMT00003(before)
N007 ( 14, 10) [000193] -A----------              *  COMMA     void  
N003 (  7,  5) [000189] -A------R---              +--*  ASG       byref 
N002 (  3,  2) [000187] D------N----              |  +--*  LCL_VAR   byref  V15 tmp14        d:1
N001 (  3,  2) [000188] ------------              |  \--*  LCL_VAR   byref  V17 tmp16        u:1 (last use)
N006 (  7,  5) [000192] -A------R---              \--*  ASG       int   
N005 (  3,  2) [000190] D------N----                 +--*  LCL_VAR   int    V16 tmp15        d:1
N004 (  3,  2) [000191] ------------                 \--*  LCL_VAR   int    V18 tmp17        u:1 (last use)

N001 [000188]   LCL_VAR   V17 tmp16        u:1 (last use) => $480 {PhiDef($11, $1, $343)}
N002 [000187]   LCL_VAR   V15 tmp14        d:1 => $480 {PhiDef($11, $1, $343)}
N003 [000189]   ASG       => $480 {PhiDef($11, $1, $343)}
N004 [000191]   LCL_VAR   V18 tmp17        u:1 (last use) => $440 {PhiDef($12, $1, $343)}
N005 [000190]   LCL_VAR   V16 tmp15        d:1 => $440 {PhiDef($12, $1, $343)}
N006 [000192]   ASG       => $440 {PhiDef($12, $1, $343)}
N007 [000193]   COMMA     => $440 {PhiDef($12, $1, $343)}

***** BB06, STMT00003(after)
N007 ( 14, 10) [000193] -A----------              *  COMMA     void   $440
N003 (  7,  5) [000189] -A------R---              +--*  ASG       byref  $480
N002 (  3,  2) [000187] D------N----              |  +--*  LCL_VAR   byref  V15 tmp14        d:1 $480
N001 (  3,  2) [000188] ------------              |  \--*  LCL_VAR   byref  V17 tmp16        u:1 (last use) $480
N006 (  7,  5) [000192] -A------R---              \--*  ASG       int    $440
N005 (  3,  2) [000190] D------N----                 +--*  LCL_VAR   int    V16 tmp15        d:1 $440
N004 (  3,  2) [000191] ------------                 \--*  LCL_VAR   int    V18 tmp17        u:1 (last use) $440

---------

***** BB06, STMT00004(before)
N023 ( 40, 30) [000011] -ACXG-------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer.TokenizeLine
N003 (  1,  3) [000214] -A------R-L- this SETUP   +--*  ASG       ref   
N002 (  1,  1) [000213] D------N----              |  +--*  LCL_VAR   ref    V26 tmp25        d:1
N001 (  1,  1) [000007] ------------              |  \--*  LCL_VAR   ref    V02 tmp1         u:1 (last use)
N019 ( 18, 15) [000212] -A--------L- arg1 SETUP   +--*  COMMA     void  
N012 ( 10,  8) [000205] -A----------              |  +--*  COMMA     void  
N007 (  3,  3) [000200] -A------R---              |  |  +--*  ASG       byref 
N006 (  1,  1) [000199] D------N----              |  |  |  +--*  LCL_VAR   byref  V25 tmp24        d:1
N005 (  3,  3) [000197] ------------              |  |  |  \--*  ADDR      byref 
N004 (  3,  2) [000198] -------N----              |  |  |     \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(AX) V24 tmp23        
N011 (  7,  5) [000204] -A----------              |  |  \--*  ASG       byref 
N009 (  3,  2) [000202] *------N----              |  |     +--*  IND       byref 
N008 (  1,  1) [000201] ------------              |  |     |  \--*  LCL_VAR   byref  V25 tmp24        u:1 Zero Fseq[_pointer]
N010 (  3,  2) [000203] -------N----              |  |     \--*  LCL_VAR   byref  V15 tmp14        u:1 (last use)
N018 (  8,  7) [000211] -A----------              |  \--*  ASG       int   
N016 (  4,  4) [000209] *------N----              |     +--*  IND       int   
N015 (  2,  2) [000208] -------N----              |     |  \--*  ADD       byref 
N013 (  1,  1) [000206] ------------              |     |     +--*  LCL_VAR   byref  V25 tmp24        u:1 (last use)
N014 (  1,  1) [000207] ------------              |     |     \--*  CNS_INT   long   8 Fseq[_length]
N017 (  3,  2) [000210] -------N----              |     \--*  LCL_VAR   int    V16 tmp15        u:1 (last use)
N020 (  1,  1) [000215] ------------ this in rcx  +--*  LCL_VAR   ref    V26 tmp25        u:1 (last use)
N022 (  3,  3) [000217] ------------ arg1 in rdx  \--*  ADDR      byref 
N021 (  3,  2) [000216] -------N----                 \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(AX) V24 tmp23        

N001 [000007]   LCL_VAR   V02 tmp1         u:1 (last use) => $180 {JitNew($100, $140)}
N002 [000213]   LCL_VAR   V26 tmp25        d:1 => $180 {JitNew($100, $140)}
N003 [000214]   ASG       => $180 {JitNew($100, $140)}
N004 [000198]   LCL_VAR   V24 tmp23         => $4c0 {4c0}
N005 [000197]   ADDR      => $3c7 {3c7}
N006 [000199]   LCL_VAR   V25 tmp24        d:1 => $3c7 {3c7}
N007 [000200]   ASG       => $3c7 {3c7}
N008 [000201]   LCL_VAR   V25 tmp24        u:1 => $3c7 {3c7}
N010 [000203]   LCL_VAR   V15 tmp14        u:1 (last use) => $480 {PhiDef($11, $1, $343)}
  fgCurMemoryVN[GcHeap] assigned for assign-of-IND at [000204] to VN: $14b.
N011 [000204]   ASG       => $VN.Void
N012 [000205]   COMMA     => $VN.Void
N013 [000206]   LCL_VAR   V25 tmp24        u:1 (last use) => $3c7 {3c7}
N014 [000207]   CNS_INT   8 Fseq[_length] => $201 {LngCns:  8}
N015 [000208]   ADD       => $305 {ADD($201, $3c7)}
N017 [000210]   LCL_VAR   V16 tmp15        u:1 (last use) => $440 {PhiDef($12, $1, $343)}
  fgCurMemoryVN[GcHeap] assigned for assign-of-IND at [000211] to VN: $14c.
N018 [000211]   ASG       => $VN.Void
N019 [000212]   COMMA     => $VN.Void
N020 [000215]   LCL_VAR   V26 tmp25        u:1 (last use) => $180 {JitNew($100, $140)}
N021 [000216]   LCL_VAR   V24 tmp23         => $4c1 {4c1}
N022 [000217]   ADDR      => $3c9 {3c9}
  fgCurMemoryVN[GcHeap] assigned for CALL at [000011] to VN: $14d.
N023 [000011]   CALL      => $VN.Void

***** BB06, STMT00004(after)
N023 ( 40, 30) [000011] -ACXG-------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer.TokenizeLine $VN.Void
N003 (  1,  3) [000214] -A------R-L- this SETUP   +--*  ASG       ref    $180
N002 (  1,  1) [000213] D------N----              |  +--*  LCL_VAR   ref    V26 tmp25        d:1 $180
N001 (  1,  1) [000007] ------------              |  \--*  LCL_VAR   ref    V02 tmp1         u:1 (last use) $180
N019 ( 18, 15) [000212] -A--------L- arg1 SETUP   +--*  COMMA     void   $VN.Void
N012 ( 10,  8) [000205] -A----------              |  +--*  COMMA     void   $VN.Void
N007 (  3,  3) [000200] -A------R---              |  |  +--*  ASG       byref  $3c7
N006 (  1,  1) [000199] D------N----              |  |  |  +--*  LCL_VAR   byref  V25 tmp24        d:1 $3c7
N005 (  3,  3) [000197] ------------              |  |  |  \--*  ADDR      byref  $3c7
N004 (  3,  2) [000198] -------N----              |  |  |     \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(AX) V24 tmp23         $4c0
N011 (  7,  5) [000204] -A----------              |  |  \--*  ASG       byref  $VN.Void
N009 (  3,  2) [000202] *------N----              |  |     +--*  IND       byref  $480
N008 (  1,  1) [000201] ------------              |  |     |  \--*  LCL_VAR   byref  V25 tmp24        u:1 Zero Fseq[_pointer] $3c7
N010 (  3,  2) [000203] -------N----              |  |     \--*  LCL_VAR   byref  V15 tmp14        u:1 (last use) $480
N018 (  8,  7) [000211] -A----------              |  \--*  ASG       int    $VN.Void
N016 (  4,  4) [000209] *------N----              |     +--*  IND       int    $440
N015 (  2,  2) [000208] -------N----              |     |  \--*  ADD       byref  $305
N013 (  1,  1) [000206] ------------              |     |     +--*  LCL_VAR   byref  V25 tmp24        u:1 (last use) $3c7
N014 (  1,  1) [000207] ------------              |     |     \--*  CNS_INT   long   8 Fseq[_length] $201
N017 (  3,  2) [000210] -------N----              |     \--*  LCL_VAR   int    V16 tmp15        u:1 (last use) $440
N020 (  1,  1) [000215] ------------ this in rcx  +--*  LCL_VAR   ref    V26 tmp25        u:1 (last use) $180
N022 (  3,  3) [000217] ------------ arg1 in rdx  \--*  ADDR      byref  $3c9
N021 (  3,  2) [000216] -------N----                 \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(AX) V24 tmp23         $4c1

---------

***** BB06, STMT00005(before)
N001 (  0,  0) [000017] ------------              *  RETURN    void  

N001 [000017]   RETURN    => $382 {382}

***** BB06, STMT00005(after)
N001 (  0,  0) [000017] ------------              *  RETURN    void   $382

finish(BB06).

*************** Finishing PHASE Do value numbering

*************** Starting PHASE Hoist loop code

*************** Finishing PHASE Hoist loop code

*************** Starting PHASE VN based copy prop
*************** In optVnCopyProp()
Copy Assertion for BB01
  curSsaName stack: { }

							Live vars: {V00} => {V00 V02}
							Live vars: {V00 V02} => {V00 V02 V04}
							Live vars: {V00 V02 V04} => {V00 V02}
Copy Assertion for BB06
  curSsaName stack: { 0-[000008]:V00 2-[000003]:V02 4-[000020]:V04 }

							Live vars: {V02 V17 V18} => {V02 V18}
							Live vars: {V02 V18} => {V02 V15 V18}
							Live vars: {V02 V15 V18} => {V02 V15}
							Live vars: {V02 V15} => {V02 V15 V16}
							Live vars: {V02 V15 V16} => {V15 V16}
							Live vars: {V15 V16} => {V15 V16 V26}
							Live vars: {V15 V16 V26} => {V15 V16 V25 V26}
							Live vars: {V15 V16 V25 V26} => {V16 V25 V26}
							Live vars: {V16 V25 V26} => {V16 V26}
							Live vars: {V16 V26} => {V26}
							Live vars: {V26} => {}
Copy Assertion for BB03
  curSsaName stack: { 0-[000008]:V00 2-[000003]:V02 4-[000020]:V04 }

							Live vars: {V00 V02} => {V00 V02 V09}
							Live vars: {V00 V02 V09} => {V02 V09}
							Live vars: {V02 V09} => {V02 V08 V09}
							Live vars: {V02 V08 V09} => {V02 V08 V09 V13}
							Live vars: {V02 V08 V09 V13} => {V02 V08 V09 V13 V14}
Copy Assertion for BB05
  curSsaName stack: { 0-[000008]:V00 2-[000003]:V02 4-[000020]:V04 8-[000113]:V08 9-[000111]:V09 13-[000132]:V13 14-[000134]:V14 }

							Live vars: {V02 V08 V09} => {V02 V08}
							Live vars: {V02 V08} => {V02 V08 V23}
							Live vars: {V02 V08 V23} => {V02 V08}
							Live vars: {V02 V08} => {V02 V08 V19}
							Live vars: {V02 V08 V19} => {V02 V19}
							Live vars: {V02 V19} => {V02 V19 V20}
							Live vars: {V02 V19 V20} => {V02 V20}
							Live vars: {V02 V20} => {V02 V17 V20}
							Live vars: {V02 V17 V20} => {V02 V17}
							Live vars: {V02 V17} => {V02 V17 V18}
Copy Assertion for BB04
  curSsaName stack: { 0-[000008]:V00 2-[000003]:V02 4-[000020]:V04 8-[000113]:V08 9-[000111]:V09 13-[000132]:V13 14-[000134]:V14 }

							Live vars: {V02 V08 V09 V13 V14} => {V02 V08 V09 V14}
VN based copy assertion for [000129] V13 @0000018C by [000134] V14 @0000018C.
N003 (  3,  2) [000129] ------------              *  LCL_VAR   ref    V13 tmp12        u:1 (last use) $18c
copy propagated to:
N003 (  3,  2) [000129] ------------              *  LCL_VAR   ref    V14 tmp13        u:1 (last use) $18c
							Live vars: {V02 V08 V09 V14} => {V02 V08 V09}
Copy Assertion for BB02
  curSsaName stack: { 0-[000008]:V00 2-[000003]:V02 4-[000020]:V04 }

							Live vars: {V02} => {V02 V21}
							Live vars: {V02 V21} => {V02 V21 V22}
							Live vars: {V02 V21 V22} => {V02 V22}
							Live vars: {V02 V22} => {V02 V17 V22}
							Live vars: {V02 V17 V22} => {V02 V17}
							Live vars: {V02 V17} => {V02 V17 V18}

*************** Finishing PHASE VN based copy prop

*************** Starting PHASE Optimize Valnum CSEs

*************** In optOptimizeCSEs()
Blocks/Trees at start of optOptimizeCSE phase

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)-> BB03 ( cond )                     i label target hascall newobj 
BB02 [0007]  1       BB01                  0.50     [006..007)-> BB06 (always)                     i 
BB03 [0008]  1       BB01                  0.50     [006..007)-> BB05 ( cond )                     i label target idxlen nullcheck 
BB04 [0014]  1       BB03                  0.25     [006..007)                                     i hascall gcsafe 
BB05 [0015]  2       BB03,BB04             0.50     [006..007)                                     i label target idxlen nullcheck 
BB06 [0009]  2       BB02,BB05             1        [???..???)        (return)                     internal label target hascall gcsafe newobj 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..012) -> BB03 (cond), preds={} succs={BB02,BB03}

***** BB01
STMT00000 (IL 0x000...0x011)
N005 ( 16, 16) [000004] -AC-----R---              *  ASG       ref    $180
N004 (  1,  1) [000003] D------N----              +--*  LCL_VAR   ref    V02 tmp1         d:1 $180
N003 ( 16, 16) [000002] --C---------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST $180
N002 (  2, 10) [000001] H----------- arg0 in rcx     \--*  CNS_INT(h) long   0xd1ffab1e token $100

***** BB01
STMT00006 (IL   ???...  ???)
N005 ( 16, 16) [000021] -AC-----R---              *  ASG       ref    $181
N004 (  1,  1) [000020] D------N----              +--*  LCL_VAR   ref    V04 tmp3         d:1 $181
N003 ( 16, 16) [000019] --C---------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST $181
N002 (  2, 10) [000018] H----------- arg0 in rcx     \--*  CNS_INT(h) long   0xd1ffab1e token $101

***** BB01
STMT00013 (IL   ???...  ???)
N013 ( 26, 35) [000039] -ACXG---R---              *  ASG       ref    $VN.Void
N012 (  4,  4) [000038] D--XG--N----              +--*  IND       ref    $2c0
N011 (  2,  2) [000140] -------N----              |  \--*  ADD       byref  $300
N009 (  1,  1) [000035] ------------              |     +--*  LCL_VAR   ref    V04 tmp3         u:1 $181
N010 (  1,  1) [000139] ------------              |     \--*  CNS_INT   long   8 field offset Fseq[_array] $201
N008 ( 21, 30) [000047] --CXG-------              \--*  COMMA     ref    <l:$184, c:$183>
N005 ( 17, 18) [000046] H-CXG-------                 +--*  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS $281
N003 (  2, 10) [000044] ------------ arg0 in rcx     |  +--*  CNS_INT   long   0x7ffa40fb0028 $200
N004 (  1,  1) [000045] ------------ arg1 in rdx     |  \--*  CNS_INT   int    6 $42
N007 (  4, 12) [000042] n---G-------                 \--*  IND       ref    <l:$2c0, c:$144>
N006 (  2, 10) [000143] I-----------                    \--*  CNS_INT(h) long   0xd1ffab1e static Fseq[Value] $102

***** BB01
STMT00008 (IL   ???...  ???)
N006 (  6,  6) [000026] -A-XG-------              *  ASG       ref    $VN.Void
N004 (  4,  4) [000025] D--XG--N----              +--*  IND       ref    $181
N003 (  2,  2) [000145] -------N----              |  \--*  ADD       byref  $301
N001 (  1,  1) [000005] ------------              |     +--*  LCL_VAR   ref    V02 tmp1         u:1 $180
N002 (  1,  1) [000144] ------------              |     \--*  CNS_INT   long   16 field offset Fseq[_tokensBuffer] $202
N005 (  1,  1) [000024] ------------              \--*  LCL_VAR   ref    V04 tmp3         u:1 (last use) $181

***** BB01
STMT00010 (IL   ???...  ???)
N006 (  6,  6) [000032] -A-XG-------              *  ASG       ref    $VN.Void
N004 (  4,  4) [000031] D--XG--N----              +--*  IND       ref    $VN.Null
N003 (  2,  2) [000147] -------N----              |  \--*  ADD       byref  $302
N001 (  1,  1) [000029] ------------              |     +--*  LCL_VAR   ref    V02 tmp1         u:1 $180
N002 (  1,  1) [000146] ------------              |     \--*  CNS_INT   long   8 field offset Fseq[_reader] $201
N005 (  1,  1) [000030] ------------              \--*  CNS_INT   ref    null $VN.Null

***** BB01
STMT00014 (IL 0x006...  ???)
N004 (  5,  5) [000052] ------------              *  JTRUE     void  
N003 (  3,  3) [000051] J------N----              \--*  NE        int    $340
N001 (  1,  1) [000008] ------------                 +--*  LCL_VAR   ref    V00 arg0         u:1 $80
N002 (  1,  1) [000050] ------------                 \--*  CNS_INT   ref    null $VN.Null

------------ BB02 [006..007) -> BB06 (always), preds={BB01} succs={BB06}

***** BB02
STMT00019 (IL 0x006...  ???)
N007 ( 10,  8) [000154] -A----------              *  COMMA     void   $40
N003 (  5,  4) [000150] -A------R---              +--*  ASG       byref  $VN.Null
N002 (  3,  2) [000148] D------N----              |  +--*  LCL_VAR   byref  V21 tmp20        d:1 $VN.Null
N001 (  1,  1) [000149] ------------              |  \--*  CNS_INT   byref  0 $VN.Null
N006 (  5,  4) [000153] -A------R---              \--*  ASG       int    $40
N005 (  3,  2) [000151] D------N----                 +--*  LCL_VAR   int    V22 tmp21        d:1 $40
N004 (  1,  1) [000152] ------------                 \--*  CNS_INT   int    0 $40

***** BB02
STMT00020 (IL 0x006...  ???)
N007 ( 14, 10) [000161] -A----------              *  COMMA     void   $40
N003 (  7,  5) [000157] -A------R---              +--*  ASG       byref  $VN.Null
N002 (  3,  2) [000155] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        d:3 $VN.Null
N001 (  3,  2) [000156] ------------              |  \--*  LCL_VAR   byref  V21 tmp20        u:1 (last use) $VN.Null
N006 (  7,  5) [000160] -A------R---              \--*  ASG       int    $40
N005 (  3,  2) [000158] D------N----                 +--*  LCL_VAR   int    V18 tmp17        d:3 $40
N004 (  3,  2) [000159] ------------                 \--*  LCL_VAR   int    V22 tmp21        u:1 (last use) $40

------------ BB03 [006..007) -> BB05 (cond), preds={BB01} succs={BB04,BB05}

***** BB03
STMT00016 (IL 0x006...  ???)
N003 (  0,  0) [000168] ------------              *  COMMA     void   $381
N001 (  0,  0) [000164] ------------              +--*  NOP       void   $380
N002 (  0,  0) [000167] ------------              \--*  NOP       void   $381

***** BB03
STMT00026 (IL 0x006...  ???)
N005 (  7,  6) [000112] -A--G---R---              *  ASG       byref  $303
N004 (  3,  2) [000111] D------N----              +--*  LCL_VAR   byref  V09 tmp8         d:1 $303
N003 (  3,  3) [000173] ------------              \--*  ADD       byref  $303
N001 (  1,  1) [000171] ------------                 +--*  LCL_VAR   ref    V00 arg0         u:1 $80
N002 (  1,  1) [000172] ------------                 \--*  CNS_INT   long   12 field offset Fseq[_firstChar] $203

***** BB03
STMT00027 (IL 0x006...  ???)
N004 (  3,  3) [000114] -A-X----R---              *  ASG       int    $341
N003 (  1,  1) [000113] D------N----              +--*  LCL_VAR   int    V08 tmp7         d:1 $400
N002 (  3,  3) [000057] ---X--------              \--*  ARR_LENGTH int    $341
N001 (  1,  1) [000056] ------------                 \--*  LCL_VAR   ref    V00 arg0         u:1 (last use) $80

***** BB03
STMT00031 (IL 0x006...  ???)
N004 (  8, 15) [000133] -A--G---R---              *  ASG       ref    $18c
N003 (  3,  2) [000132] D------N----              +--*  LCL_VAR   ref    V13 tmp12        d:1 $18c
N002 (  4, 12) [000119] #---G-------              \--*  IND       ref    $18c
N001 (  2, 10) [000118] H-----------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL] $106

***** BB03
STMT00032 (IL 0x006...  ???)
N004 (  8, 15) [000135] -A--G---R---              *  ASG       ref    $18c
N003 (  3,  2) [000134] D------N----              +--*  LCL_VAR   ref    V14 tmp13        d:1 $18c
N002 (  4, 12) [000121] #---G-------              \--*  IND       ref    $18c
N001 (  2, 10) [000120] H-----------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL] $106

***** BB03
STMT00029 (IL 0x006...  ???)
N004 (  5,  5) [000128] ------------              *  JTRUE     void  
N003 (  3,  3) [000090] J------N----              \--*  GE        int    $342
N001 (  1,  1) [000088] ------------                 +--*  LCL_VAR   int    V08 tmp7         u:1 $400
N002 (  1,  1) [000089] ------------                 \--*  CNS_INT   int    0 $40

------------ BB04 [006..007), preds={BB03} succs={BB05}

***** BB04
STMT00030 (IL 0x006...  ???)
N005 ( 20, 11) [000131] --CXG-------              *  CALL      void   System.Diagnostics.Debug.Fail $VN.Void
N003 (  3,  2) [000129] ------------ arg0 in rcx  +--*  LCL_VAR   ref    V14 tmp13        u:1 (last use) $18c
N004 (  3,  2) [000130] ------------ arg1 in rdx  \--*  LCL_VAR   ref    V14 tmp13        u:1 (last use) $18c

------------ BB05 [006..007), preds={BB03,BB04} succs={BB06}

***** BB05
STMT00023 (IL 0x006...  ???)
N003 (  7,  5) [000100] -A------R---              *  ASG       byref  $303
N002 (  3,  2) [000099] D------N----              +--*  LCL_VAR   byref  V23 tmp22        d:1 $303
N001 (  3,  2) [000096] ------------              \--*  LCL_VAR   byref  V09 tmp8         u:1 (last use) $303

***** BB05
STMT00024 (IL 0x006...  ???)
N003 (  7,  5) [000179] -A------R---              *  ASG       byref  $303
N002 (  3,  2) [000177] D------N----              +--*  LCL_VAR   byref  V19 tmp18        d:1 $303
N001 (  3,  2) [000178] -------N----              \--*  LCL_VAR   byref  V23 tmp22        u:1 (last use) $303

***** BB05
STMT00025 (IL 0x006...  ???)
N003 (  5,  4) [000110] -A------R---              *  ASG       int    $400
N002 (  3,  2) [000109] D------N----              +--*  LCL_VAR   int    V20 tmp19        d:1 $400
N001 (  1,  1) [000108] ------------              \--*  LCL_VAR   int    V08 tmp7         u:1 (last use) $400

***** BB05
STMT00018 (IL 0x006...  ???)
N007 ( 14, 10) [000186] -A----------              *  COMMA     void   $400
N003 (  7,  5) [000182] -A------R---              +--*  ASG       byref  $303
N002 (  3,  2) [000180] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        d:2 $303
N001 (  3,  2) [000181] ------------              |  \--*  LCL_VAR   byref  V19 tmp18        u:1 (last use) $303
N006 (  7,  5) [000185] -A------R---              \--*  ASG       int    $400
N005 (  3,  2) [000183] D------N----                 +--*  LCL_VAR   int    V18 tmp17        d:2 $400
N004 (  3,  2) [000184] ------------                 \--*  LCL_VAR   int    V20 tmp19        u:1 (last use) $400

------------ BB06 [???..???) (return), preds={BB02,BB05} succs={}

***** BB06
STMT00034 (IL   ???...  ???)
N005 (  0,  0) [000223] -A------R---              *  ASG       int   
N004 (  0,  0) [000221] D------N----              +--*  LCL_VAR   int    V18 tmp17        d:1
N003 (  0,  0) [000222] ------------              \--*  PHI       int   
N001 (  0,  0) [000226] ------------ pred BB02       +--*  PHI_ARG   int    V18 tmp17        u:3 $40
N002 (  0,  0) [000224] ------------ pred BB05       \--*  PHI_ARG   int    V18 tmp17        u:2 $400

***** BB06
STMT00033 (IL   ???...  ???)
N005 (  0,  0) [000220] -A------R---              *  ASG       byref 
N004 (  0,  0) [000218] D------N----              +--*  LCL_VAR   byref  V17 tmp16        d:1
N003 (  0,  0) [000219] ------------              \--*  PHI       byref 
N001 (  0,  0) [000227] ------------ pred BB02       +--*  PHI_ARG   byref  V17 tmp16        u:3 $VN.Null
N002 (  0,  0) [000225] ------------ pred BB05       \--*  PHI_ARG   byref  V17 tmp16        u:2 $303

***** BB06
STMT00003 (IL   ???...  ???)
N007 ( 14, 10) [000193] -A----------              *  COMMA     void   $440
N003 (  7,  5) [000189] -A------R---              +--*  ASG       byref  $480
N002 (  3,  2) [000187] D------N----              |  +--*  LCL_VAR   byref  V15 tmp14        d:1 $480
N001 (  3,  2) [000188] ------------              |  \--*  LCL_VAR   byref  V17 tmp16        u:1 (last use) $480
N006 (  7,  5) [000192] -A------R---              \--*  ASG       int    $440
N005 (  3,  2) [000190] D------N----                 +--*  LCL_VAR   int    V16 tmp15        d:1 $440
N004 (  3,  2) [000191] ------------                 \--*  LCL_VAR   int    V18 tmp17        u:1 (last use) $440

***** BB06
STMT00004 (IL   ???...  ???)
N023 ( 40, 30) [000011] -ACXG-------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer.TokenizeLine $VN.Void
N003 (  1,  3) [000214] -A------R-L- this SETUP   +--*  ASG       ref    $180
N002 (  1,  1) [000213] D------N----              |  +--*  LCL_VAR   ref    V26 tmp25        d:1 $180
N001 (  1,  1) [000007] ------------              |  \--*  LCL_VAR   ref    V02 tmp1         u:1 (last use) $180
N019 ( 18, 15) [000212] -A--------L- arg1 SETUP   +--*  COMMA     void   $VN.Void
N012 ( 10,  8) [000205] -A----------              |  +--*  COMMA     void   $VN.Void
N007 (  3,  3) [000200] -A------R---              |  |  +--*  ASG       byref  $3c7
N006 (  1,  1) [000199] D------N----              |  |  |  +--*  LCL_VAR   byref  V25 tmp24        d:1 $3c7
N005 (  3,  3) [000197] ------------              |  |  |  \--*  ADDR      byref  $3c7
N004 (  3,  2) [000198] -------N----              |  |  |     \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(AX) V24 tmp23         $4c0
N011 (  7,  5) [000204] -A----------              |  |  \--*  ASG       byref  $VN.Void
N009 (  3,  2) [000202] *------N----              |  |     +--*  IND       byref  $480
N008 (  1,  1) [000201] ------------              |  |     |  \--*  LCL_VAR   byref  V25 tmp24        u:1 Zero Fseq[_pointer] $3c7
N010 (  3,  2) [000203] -------N----              |  |     \--*  LCL_VAR   byref  V15 tmp14        u:1 (last use) $480
N018 (  8,  7) [000211] -A----------              |  \--*  ASG       int    $VN.Void
N016 (  4,  4) [000209] *------N----              |     +--*  IND       int    $440
N015 (  2,  2) [000208] -------N----              |     |  \--*  ADD       byref  $305
N013 (  1,  1) [000206] ------------              |     |     +--*  LCL_VAR   byref  V25 tmp24        u:1 (last use) $3c7
N014 (  1,  1) [000207] ------------              |     |     \--*  CNS_INT   long   8 Fseq[_length] $201
N017 (  3,  2) [000210] -------N----              |     \--*  LCL_VAR   int    V16 tmp15        u:1 (last use) $440
N020 (  1,  1) [000215] ------------ this in rcx  +--*  LCL_VAR   ref    V26 tmp25        u:1 (last use) $180
N022 (  3,  3) [000217] ------------ arg1 in rdx  \--*  ADDR      byref  $3c9
N021 (  3,  2) [000216] -------N----                 \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(AX) V24 tmp23         $4c1

***** BB06
STMT00005 (IL 0x011...  ???)
N001 (  0,  0) [000017] ------------              *  RETURN    void   $382

-------------------------------------------------------------------------------------------------------------------

*************** In optOptimizeValnumCSEs()

CSE candidate #01, key=$18c in BB03, [cost= 4, size=12]: 
N002 (  4, 12) CSE #01 (use)[000121] #---G-------              *  IND       ref    $18c
N001 (  2, 10)              [000120] H-----------              \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL] $106

Blocks that generate CSE def/uses
BB03 cseGen = 0000000000000003

Performing DataFlow for ValnumCSE's
StartMerge BB01
  :: cseOut    = 0000000000000007
EndMerge BB01
  :: cseIn     = 0000000000000000
  :: cseGen    = 0000000000000000
  => cseOut    = 0000000000000000
  != preMerge  = 0000000000000007, => true
StartMerge BB02
  :: cseOut    = 0000000000000007
Merge BB02 and BB01
  :: cseIn     = 0000000000000007
  :: cseOut    = 0000000000000007
  => cseIn     = 0000000000000000
EndMerge BB02
  :: cseIn     = 0000000000000000
  :: cseGen    = 0000000000000000
  => cseOut    = 0000000000000000
  != preMerge  = 0000000000000007, => true
StartMerge BB03
  :: cseOut    = 0000000000000007
Merge BB03 and BB01
  :: cseIn     = 0000000000000007
  :: cseOut    = 0000000000000007
  => cseIn     = 0000000000000000
EndMerge BB03
  :: cseIn     = 0000000000000000
  :: cseGen    = 0000000000000003
  => cseOut    = 0000000000000003
  != preMerge  = 0000000000000007, => true
StartMerge BB06
  :: cseOut    = 0000000000000007
Merge BB06 and BB02
  :: cseIn     = 0000000000000007
  :: cseOut    = 0000000000000007
  => cseIn     = 0000000000000000
Merge BB06 and BB05
  :: cseIn     = 0000000000000000
  :: cseOut    = 0000000000000007
  => cseIn     = 0000000000000000
EndMerge BB06
  :: cseIn     = 0000000000000000
  :: cseGen    = 0000000000000000
  => cseOut    = 0000000000000000
  != preMerge  = 0000000000000007, => true
StartMerge BB04
  :: cseOut    = 0000000000000007
Merge BB04 and BB03
  :: cseIn     = 0000000000000007
  :: cseOut    = 0000000000000007
  => cseIn     = 0000000000000003
EndMerge BB04
  :: cseIn     = 0000000000000003
  -- cseKill   = 0000000000000001
  :: cseGen    = 0000000000000000
  => cseOut    = 0000000000000001
  != preMerge  = 0000000000000007, => true
StartMerge BB05
  :: cseOut    = 0000000000000007
Merge BB05 and BB03
  :: cseIn     = 0000000000000007
  :: cseOut    = 0000000000000007
  => cseIn     = 0000000000000003
Merge BB05 and BB04
  :: cseIn     = 0000000000000003
  :: cseOut    = 0000000000000007
  => cseIn     = 0000000000000001
EndMerge BB05
  :: cseIn     = 0000000000000001
  :: cseGen    = 0000000000000000
  => cseOut    = 0000000000000001
  != preMerge  = 0000000000000007, => true
StartMerge BB05
  :: cseOut    = 0000000000000001
Merge BB05 and BB03
  :: cseIn     = 0000000000000001
  :: cseOut    = 0000000000000001
  => cseIn     = 0000000000000001
Merge BB05 and BB04
  :: cseIn     = 0000000000000001
  :: cseOut    = 0000000000000001
  => cseIn     = 0000000000000001
EndMerge BB05
  :: cseIn     = 0000000000000001
  :: cseGen    = 0000000000000000
  => cseOut    = 0000000000000001
  != preMerge  = 0000000000000001, => false
StartMerge BB06
  :: cseOut    = 0000000000000000
Merge BB06 and BB02
  :: cseIn     = 0000000000000000
  :: cseOut    = 0000000000000000
  => cseIn     = 0000000000000000
Merge BB06 and BB05
  :: cseIn     = 0000000000000000
  :: cseOut    = 0000000000000000
  => cseIn     = 0000000000000000
EndMerge BB06
  :: cseIn     = 0000000000000000
  :: cseGen    = 0000000000000000
  => cseOut    = 0000000000000000
  != preMerge  = 0000000000000000, => false

After performing DataFlow for ValnumCSE's
BB01 cseIn  = 0000000000000000, cseGen = 0000000000000000, cseOut = 0000000000000000
BB02 cseIn  = 0000000000000000, cseGen = 0000000000000000, cseOut = 0000000000000000
BB03 cseIn  = 0000000000000000, cseGen = 0000000000000003, cseOut = 0000000000000003
BB04 cseIn  = 0000000000000003, cseGen = 0000000000000000, cseOut = 0000000000000001
BB05 cseIn  = 0000000000000001, cseGen = 0000000000000000, cseOut = 0000000000000001
BB06 cseIn  = 0000000000000000, cseGen = 0000000000000000, cseOut = 0000000000000000

Labeling the CSEs with Use/Def information
BB03 [000119] Def of CSE #01 [weight=0.50]
BB03 [000121] Use of CSE #01 [weight=0.50]

************ Trees at start of optValnumCSE_Heuristic()

------------ BB01 [000..012) -> BB03 (cond), preds={} succs={BB02,BB03}

***** BB01
STMT00000 (IL 0x000...0x011)
N005 ( 16, 16)              [000004] -AC-----R---              *  ASG       ref    $180
N004 (  1,  1)              [000003] D------N----              +--*  LCL_VAR   ref    V02 tmp1         d:1 $180
N003 ( 16, 16)              [000002] --C---------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST $180
N002 (  2, 10)              [000001] H----------- arg0 in rcx     \--*  CNS_INT(h) long   0xd1ffab1e token $100

***** BB01
STMT00006 (IL   ???...  ???)
N005 ( 16, 16)              [000021] -AC-----R---              *  ASG       ref    $181
N004 (  1,  1)              [000020] D------N----              +--*  LCL_VAR   ref    V04 tmp3         d:1 $181
N003 ( 16, 16)              [000019] --C---------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST $181
N002 (  2, 10)              [000018] H----------- arg0 in rcx     \--*  CNS_INT(h) long   0xd1ffab1e token $101

***** BB01
STMT00013 (IL   ???...  ???)
N013 ( 26, 35)              [000039] -ACXG---R---              *  ASG       ref    $VN.Void
N012 (  4,  4)              [000038] D--XG--N----              +--*  IND       ref    $2c0
N011 (  2,  2)              [000140] -------N----              |  \--*  ADD       byref  $300
N009 (  1,  1)              [000035] ------------              |     +--*  LCL_VAR   ref    V04 tmp3         u:1 $181
N010 (  1,  1)              [000139] ------------              |     \--*  CNS_INT   long   8 field offset Fseq[_array] $201
N008 ( 21, 30)              [000047] --CXG-------              \--*  COMMA     ref    <l:$184, c:$183>
N005 ( 17, 18)              [000046] H-CXG-------                 +--*  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS $281
N003 (  2, 10)              [000044] ------------ arg0 in rcx     |  +--*  CNS_INT   long   0x7ffa40fb0028 $200
N004 (  1,  1)              [000045] ------------ arg1 in rdx     |  \--*  CNS_INT   int    6 $42
N007 (  4, 12)              [000042] n---G-------                 \--*  IND       ref    <l:$2c0, c:$144>
N006 (  2, 10)              [000143] I-----------                    \--*  CNS_INT(h) long   0xd1ffab1e static Fseq[Value] $102

***** BB01
STMT00008 (IL   ???...  ???)
N006 (  6,  6)              [000026] -A-XG-------              *  ASG       ref    $VN.Void
N004 (  4,  4)              [000025] D--XG--N----              +--*  IND       ref    $181
N003 (  2,  2)              [000145] -------N----              |  \--*  ADD       byref  $301
N001 (  1,  1)              [000005] ------------              |     +--*  LCL_VAR   ref    V02 tmp1         u:1 $180
N002 (  1,  1)              [000144] ------------              |     \--*  CNS_INT   long   16 field offset Fseq[_tokensBuffer] $202
N005 (  1,  1)              [000024] ------------              \--*  LCL_VAR   ref    V04 tmp3         u:1 (last use) $181

***** BB01
STMT00010 (IL   ???...  ???)
N006 (  6,  6)              [000032] -A-XG-------              *  ASG       ref    $VN.Void
N004 (  4,  4)              [000031] D--XG--N----              +--*  IND       ref    $VN.Null
N003 (  2,  2)              [000147] -------N----              |  \--*  ADD       byref  $302
N001 (  1,  1)              [000029] ------------              |     +--*  LCL_VAR   ref    V02 tmp1         u:1 $180
N002 (  1,  1)              [000146] ------------              |     \--*  CNS_INT   long   8 field offset Fseq[_reader] $201
N005 (  1,  1)              [000030] ------------              \--*  CNS_INT   ref    null $VN.Null

***** BB01
STMT00014 (IL 0x006...  ???)
N004 (  5,  5)              [000052] ------------              *  JTRUE     void  
N003 (  3,  3)              [000051] J------N----              \--*  NE        int    $340
N001 (  1,  1)              [000008] ------------                 +--*  LCL_VAR   ref    V00 arg0         u:1 $80
N002 (  1,  1)              [000050] ------------                 \--*  CNS_INT   ref    null $VN.Null

------------ BB02 [006..007) -> BB06 (always), preds={BB01} succs={BB06}

***** BB02
STMT00019 (IL 0x006...  ???)
N007 ( 10,  8)              [000154] -A----------              *  COMMA     void   $40
N003 (  5,  4)              [000150] -A------R---              +--*  ASG       byref  $VN.Null
N002 (  3,  2)              [000148] D------N----              |  +--*  LCL_VAR   byref  V21 tmp20        d:1 $VN.Null
N001 (  1,  1)              [000149] ------------              |  \--*  CNS_INT   byref  0 $VN.Null
N006 (  5,  4)              [000153] -A------R---              \--*  ASG       int    $40
N005 (  3,  2)              [000151] D------N----                 +--*  LCL_VAR   int    V22 tmp21        d:1 $40
N004 (  1,  1)              [000152] ------------                 \--*  CNS_INT   int    0 $40

***** BB02
STMT00020 (IL 0x006...  ???)
N007 ( 14, 10)              [000161] -A----------              *  COMMA     void   $40
N003 (  7,  5)              [000157] -A------R---              +--*  ASG       byref  $VN.Null
N002 (  3,  2)              [000155] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        d:3 $VN.Null
N001 (  3,  2)              [000156] ------------              |  \--*  LCL_VAR   byref  V21 tmp20        u:1 (last use) $VN.Null
N006 (  7,  5)              [000160] -A------R---              \--*  ASG       int    $40
N005 (  3,  2)              [000158] D------N----                 +--*  LCL_VAR   int    V18 tmp17        d:3 $40
N004 (  3,  2)              [000159] ------------                 \--*  LCL_VAR   int    V22 tmp21        u:1 (last use) $40

------------ BB03 [006..007) -> BB05 (cond), preds={BB01} succs={BB04,BB05}

***** BB03
STMT00016 (IL 0x006...  ???)
N003 (  0,  0)              [000168] ------------              *  COMMA     void   $381
N001 (  0,  0)              [000164] ------------              +--*  NOP       void   $380
N002 (  0,  0)              [000167] ------------              \--*  NOP       void   $381

***** BB03
STMT00026 (IL 0x006...  ???)
N005 (  7,  6)              [000112] -A--G---R---              *  ASG       byref  $303
N004 (  3,  2)              [000111] D------N----              +--*  LCL_VAR   byref  V09 tmp8         d:1 $303
N003 (  3,  3)              [000173] ------------              \--*  ADD       byref  $303
N001 (  1,  1)              [000171] ------------                 +--*  LCL_VAR   ref    V00 arg0         u:1 $80
N002 (  1,  1)              [000172] ------------                 \--*  CNS_INT   long   12 field offset Fseq[_firstChar] $203

***** BB03
STMT00027 (IL 0x006...  ???)
N004 (  3,  3)              [000114] -A-X----R---              *  ASG       int    $341
N003 (  1,  1)              [000113] D------N----              +--*  LCL_VAR   int    V08 tmp7         d:1 $400
N002 (  3,  3)              [000057] ---X--------              \--*  ARR_LENGTH int    $341
N001 (  1,  1)              [000056] ------------                 \--*  LCL_VAR   ref    V00 arg0         u:1 (last use) $80

***** BB03
STMT00031 (IL 0x006...  ???)
N004 (  8, 15)              [000133] -A--G---R---              *  ASG       ref    $18c
N003 (  3,  2)              [000132] D------N----              +--*  LCL_VAR   ref    V13 tmp12        d:1 $18c
N002 (  4, 12) CSE #01 (def)[000119] #---G-------              \--*  IND       ref    $18c
N001 (  2, 10)              [000118] H-----------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL] $106

***** BB03
STMT00032 (IL 0x006...  ???)
N004 (  8, 15)              [000135] -A--G---R---              *  ASG       ref    $18c
N003 (  3,  2)              [000134] D------N----              +--*  LCL_VAR   ref    V14 tmp13        d:1 $18c
N002 (  4, 12) CSE #01 (use)[000121] #---G-------              \--*  IND       ref    $18c
N001 (  2, 10)              [000120] H-----------                 \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL] $106

***** BB03
STMT00029 (IL 0x006...  ???)
N004 (  5,  5)              [000128] ------------              *  JTRUE     void  
N003 (  3,  3)              [000090] J------N----              \--*  GE        int    $342
N001 (  1,  1)              [000088] ------------                 +--*  LCL_VAR   int    V08 tmp7         u:1 $400
N002 (  1,  1)              [000089] ------------                 \--*  CNS_INT   int    0 $40

------------ BB04 [006..007), preds={BB03} succs={BB05}

***** BB04
STMT00030 (IL 0x006...  ???)
N005 ( 20, 11)              [000131] --CXG-------              *  CALL      void   System.Diagnostics.Debug.Fail $VN.Void
N003 (  3,  2)              [000129] ------------ arg0 in rcx  +--*  LCL_VAR   ref    V14 tmp13        u:1 (last use) $18c
N004 (  3,  2)              [000130] ------------ arg1 in rdx  \--*  LCL_VAR   ref    V14 tmp13        u:1 (last use) $18c

------------ BB05 [006..007), preds={BB03,BB04} succs={BB06}

***** BB05
STMT00023 (IL 0x006...  ???)
N003 (  7,  5)              [000100] -A------R---              *  ASG       byref  $303
N002 (  3,  2)              [000099] D------N----              +--*  LCL_VAR   byref  V23 tmp22        d:1 $303
N001 (  3,  2)              [000096] ------------              \--*  LCL_VAR   byref  V09 tmp8         u:1 (last use) $303

***** BB05
STMT00024 (IL 0x006...  ???)
N003 (  7,  5)              [000179] -A------R---              *  ASG       byref  $303
N002 (  3,  2)              [000177] D------N----              +--*  LCL_VAR   byref  V19 tmp18        d:1 $303
N001 (  3,  2)              [000178] -------N----              \--*  LCL_VAR   byref  V23 tmp22        u:1 (last use) $303

***** BB05
STMT00025 (IL 0x006...  ???)
N003 (  5,  4)              [000110] -A------R---              *  ASG       int    $400
N002 (  3,  2)              [000109] D------N----              +--*  LCL_VAR   int    V20 tmp19        d:1 $400
N001 (  1,  1)              [000108] ------------              \--*  LCL_VAR   int    V08 tmp7         u:1 (last use) $400

***** BB05
STMT00018 (IL 0x006...  ???)
N007 ( 14, 10)              [000186] -A----------              *  COMMA     void   $400
N003 (  7,  5)              [000182] -A------R---              +--*  ASG       byref  $303
N002 (  3,  2)              [000180] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        d:2 $303
N001 (  3,  2)              [000181] ------------              |  \--*  LCL_VAR   byref  V19 tmp18        u:1 (last use) $303
N006 (  7,  5)              [000185] -A------R---              \--*  ASG       int    $400
N005 (  3,  2)              [000183] D------N----                 +--*  LCL_VAR   int    V18 tmp17        d:2 $400
N004 (  3,  2)              [000184] ------------                 \--*  LCL_VAR   int    V20 tmp19        u:1 (last use) $400

------------ BB06 [???..???) (return), preds={BB02,BB05} succs={}

***** BB06
STMT00034 (IL   ???...  ???)
N005 (  0,  0)              [000223] -A------R---              *  ASG       int   
N004 (  0,  0)              [000221] D------N----              +--*  LCL_VAR   int    V18 tmp17        d:1
N003 (  0,  0)              [000222] ------------              \--*  PHI       int   
N001 (  0,  0)              [000226] ------------ pred BB02       +--*  PHI_ARG   int    V18 tmp17        u:3 $40
N002 (  0,  0)              [000224] ------------ pred BB05       \--*  PHI_ARG   int    V18 tmp17        u:2 $400

***** BB06
STMT00033 (IL   ???...  ???)
N005 (  0,  0)              [000220] -A------R---              *  ASG       byref 
N004 (  0,  0)              [000218] D------N----              +--*  LCL_VAR   byref  V17 tmp16        d:1
N003 (  0,  0)              [000219] ------------              \--*  PHI       byref 
N001 (  0,  0)              [000227] ------------ pred BB02       +--*  PHI_ARG   byref  V17 tmp16        u:3 $VN.Null
N002 (  0,  0)              [000225] ------------ pred BB05       \--*  PHI_ARG   byref  V17 tmp16        u:2 $303

***** BB06
STMT00003 (IL   ???...  ???)
N007 ( 14, 10)              [000193] -A----------              *  COMMA     void   $440
N003 (  7,  5)              [000189] -A------R---              +--*  ASG       byref  $480
N002 (  3,  2)              [000187] D------N----              |  +--*  LCL_VAR   byref  V15 tmp14        d:1 $480
N001 (  3,  2)              [000188] ------------              |  \--*  LCL_VAR   byref  V17 tmp16        u:1 (last use) $480
N006 (  7,  5)              [000192] -A------R---              \--*  ASG       int    $440
N005 (  3,  2)              [000190] D------N----                 +--*  LCL_VAR   int    V16 tmp15        d:1 $440
N004 (  3,  2)              [000191] ------------                 \--*  LCL_VAR   int    V18 tmp17        u:1 (last use) $440

***** BB06
STMT00004 (IL   ???...  ???)
N023 ( 40, 30)              [000011] -ACXG-------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer.TokenizeLine $VN.Void
N003 (  1,  3)              [000214] -A------R-L- this SETUP   +--*  ASG       ref    $180
N002 (  1,  1)              [000213] D------N----              |  +--*  LCL_VAR   ref    V26 tmp25        d:1 $180
N001 (  1,  1)              [000007] ------------              |  \--*  LCL_VAR   ref    V02 tmp1         u:1 (last use) $180
N019 ( 18, 15)              [000212] -A--------L- arg1 SETUP   +--*  COMMA     void   $VN.Void
N012 ( 10,  8)              [000205] -A----------              |  +--*  COMMA     void   $VN.Void
N007 (  3,  3)              [000200] -A------R---              |  |  +--*  ASG       byref  $3c7
N006 (  1,  1)              [000199] D------N----              |  |  |  +--*  LCL_VAR   byref  V25 tmp24        d:1 $3c7
N005 (  3,  3)              [000197] ------------              |  |  |  \--*  ADDR      byref  $3c7
N004 (  3,  2)              [000198] -------N----              |  |  |     \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(AX) V24 tmp23         $4c0
N011 (  7,  5)              [000204] -A----------              |  |  \--*  ASG       byref  $VN.Void
N009 (  3,  2)              [000202] *------N----              |  |     +--*  IND       byref  $480
N008 (  1,  1)              [000201] ------------              |  |     |  \--*  LCL_VAR   byref  V25 tmp24        u:1 Zero Fseq[_pointer] $3c7
N010 (  3,  2)              [000203] -------N----              |  |     \--*  LCL_VAR   byref  V15 tmp14        u:1 (last use) $480
N018 (  8,  7)              [000211] -A----------              |  \--*  ASG       int    $VN.Void
N016 (  4,  4)              [000209] *------N----              |     +--*  IND       int    $440
N015 (  2,  2)              [000208] -------N----              |     |  \--*  ADD       byref  $305
N013 (  1,  1)              [000206] ------------              |     |     +--*  LCL_VAR   byref  V25 tmp24        u:1 (last use) $3c7
N014 (  1,  1)              [000207] ------------              |     |     \--*  CNS_INT   long   8 Fseq[_length] $201
N017 (  3,  2)              [000210] -------N----              |     \--*  LCL_VAR   int    V16 tmp15        u:1 (last use) $440
N020 (  1,  1)              [000215] ------------ this in rcx  +--*  LCL_VAR   ref    V26 tmp25        u:1 (last use) $180
N022 (  3,  3)              [000217] ------------ arg1 in rdx  \--*  ADDR      byref  $3c9
N021 (  3,  2)              [000216] -------N----                 \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(AX) V24 tmp23         $4c1

***** BB06
STMT00005 (IL 0x011...  ???)
N001 (  0,  0)              [000017] ------------              *  RETURN    void   $382

-------------------------------------------------------------------------------------------------------------------


Aggressive CSE Promotion cutoff is 250
Moderate CSE Promotion cutoff is 100
enregCount is 18
Framesize estimate is 0x0010
We have a small frame

Sorted CSE candidates:
CSE #01, {$18c, $4  } useCnt=1: [def= 50, use= 50, cost=  4      ]
        :: N002 (  4, 12) CSE #01 (def)[000119] #---G-------              *  IND       ref    $18c


Considering CSE #01 {$18c, $4  } [def= 50, use= 50, cost=  4      ]
CSE Expression : 
N002 (  4, 12) CSE #01 (def)[000119] #---G-------              *  IND       ref    $18c
N001 (  2, 10)              [000118] H-----------              \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL] $106

Moderate CSE Promotion (CSE never live at call) (150 >= 100)
cseRefCnt=150, aggressiveRefCnt=250, moderateRefCnt=100
defCnt=50, useCnt=50, cost=4, size=12
def_cost=2, use_cost=1, extra_no_cost=22, extra_yes_cost=0
CSE cost savings check (222 >= 150) passes

Promoting CSE:

lvaGrabTemp returning 27 (V27 rat0) (a long lifetime temp) called for CSE - moderate.
CSE #01 is single-def, so associated CSE temp V27 will be in SSA
New refCnts for V27: refCnt =  2, refCntWtd = 1   
New refCnts for V27: refCnt =  3, refCntWtd = 1.50

CSE #01 def at [000119] replaced in BB03 with def of V27
optValnumCSE morphed tree:
N008 ( 15, 20)              [000133] -A--G---R---              *  ASG       ref    $18c
N007 (  3,  2)              [000132] D------N----              +--*  LCL_VAR   ref    V13 tmp12        d:1 $18c
N006 ( 11, 17)              [000231] -A--G-------              \--*  COMMA     ref    $18c
N004 (  8, 15)              [000229] -A--G---R---                 +--*  ASG       ref    $VN.Void
N003 (  3,  2)              [000228] D------N----                 |  +--*  LCL_VAR   ref    V27 cse0         d:1 $18c
N002 (  4, 12)              [000119] #---G-------                 |  \--*  IND       ref    $18c
N001 (  2, 10)              [000118] H-----------                 |     \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL] $106
N005 (  3,  2)              [000230] ------------                 \--*  LCL_VAR   ref    V27 cse0         u:1 $18c


Working on the replacement of the CSE #01 use at [000121] in BB03
optValnumCSE morphed tree:
N003 (  7,  5)              [000135] -A--G---R---              *  ASG       ref    $18c
N002 (  3,  2)              [000134] D------N----              +--*  LCL_VAR   ref    V14 tmp13        d:1 $18c
N001 (  3,  2)              [000232] ------------              \--*  LCL_VAR   ref    V27 cse0         u:1 $18c


*************** Finishing PHASE Optimize Valnum CSEs

*************** Starting PHASE Assertion prop
*************** In optAssertionPropMain()
Blocks/Trees at start of phase

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)-> BB03 ( cond )                     i label target hascall newobj 
BB02 [0007]  1       BB01                  0.50     [006..007)-> BB06 (always)                     i 
BB03 [0008]  1       BB01                  0.50     [006..007)-> BB05 ( cond )                     i label target idxlen nullcheck 
BB04 [0014]  1       BB03                  0.25     [006..007)                                     i hascall gcsafe 
BB05 [0015]  2       BB03,BB04             0.50     [006..007)                                     i label target idxlen nullcheck 
BB06 [0009]  2       BB02,BB05             1        [???..???)        (return)                     internal label target hascall gcsafe newobj 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..012) -> BB03 (cond), preds={} succs={BB02,BB03}

***** BB01
STMT00000 (IL 0x000...0x011)
N005 ( 16, 16) [000004] -AC-----R---              *  ASG       ref    $180
N004 (  1,  1) [000003] D------N----              +--*  LCL_VAR   ref    V02 tmp1         d:1 $180
N003 ( 16, 16) [000002] --C---------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST $180
N002 (  2, 10) [000001] H----------- arg0 in rcx     \--*  CNS_INT(h) long   0xd1ffab1e token $100

***** BB01
STMT00006 (IL   ???...  ???)
N005 ( 16, 16) [000021] -AC-----R---              *  ASG       ref    $181
N004 (  1,  1) [000020] D------N----              +--*  LCL_VAR   ref    V04 tmp3         d:1 $181
N003 ( 16, 16) [000019] --C---------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST $181
N002 (  2, 10) [000018] H----------- arg0 in rcx     \--*  CNS_INT(h) long   0xd1ffab1e token $101

***** BB01
STMT00013 (IL   ???...  ???)
N013 ( 26, 35) [000039] -ACXG---R---              *  ASG       ref    $VN.Void
N012 (  4,  4) [000038] D--XG--N----              +--*  IND       ref    $2c0
N011 (  2,  2) [000140] -------N----              |  \--*  ADD       byref  $300
N009 (  1,  1) [000035] ------------              |     +--*  LCL_VAR   ref    V04 tmp3         u:1 $181
N010 (  1,  1) [000139] ------------              |     \--*  CNS_INT   long   8 field offset Fseq[_array] $201
N008 ( 21, 30) [000047] --CXG-------              \--*  COMMA     ref    <l:$184, c:$183>
N005 ( 17, 18) [000046] H-CXG-------                 +--*  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS $281
N003 (  2, 10) [000044] ------------ arg0 in rcx     |  +--*  CNS_INT   long   0x7ffa40fb0028 $200
N004 (  1,  1) [000045] ------------ arg1 in rdx     |  \--*  CNS_INT   int    6 $42
N007 (  4, 12) [000042] n---G-------                 \--*  IND       ref    <l:$2c0, c:$144>
N006 (  2, 10) [000143] I-----------                    \--*  CNS_INT(h) long   0xd1ffab1e static Fseq[Value] $102

***** BB01
STMT00008 (IL   ???...  ???)
N006 (  6,  6) [000026] -A-XG-------              *  ASG       ref    $VN.Void
N004 (  4,  4) [000025] D--XG--N----              +--*  IND       ref    $181
N003 (  2,  2) [000145] -------N----              |  \--*  ADD       byref  $301
N001 (  1,  1) [000005] ------------              |     +--*  LCL_VAR   ref    V02 tmp1         u:1 $180
N002 (  1,  1) [000144] ------------              |     \--*  CNS_INT   long   16 field offset Fseq[_tokensBuffer] $202
N005 (  1,  1) [000024] ------------              \--*  LCL_VAR   ref    V04 tmp3         u:1 (last use) $181

***** BB01
STMT00010 (IL   ???...  ???)
N006 (  6,  6) [000032] -A-XG-------              *  ASG       ref    $VN.Void
N004 (  4,  4) [000031] D--XG--N----              +--*  IND       ref    $VN.Null
N003 (  2,  2) [000147] -------N----              |  \--*  ADD       byref  $302
N001 (  1,  1) [000029] ------------              |     +--*  LCL_VAR   ref    V02 tmp1         u:1 $180
N002 (  1,  1) [000146] ------------              |     \--*  CNS_INT   long   8 field offset Fseq[_reader] $201
N005 (  1,  1) [000030] ------------              \--*  CNS_INT   ref    null $VN.Null

***** BB01
STMT00014 (IL 0x006...  ???)
N004 (  5,  5) [000052] ------------              *  JTRUE     void  
N003 (  3,  3) [000051] J------N----              \--*  NE        int    $340
N001 (  1,  1) [000008] ------------                 +--*  LCL_VAR   ref    V00 arg0         u:1 $80
N002 (  1,  1) [000050] ------------                 \--*  CNS_INT   ref    null $VN.Null

------------ BB02 [006..007) -> BB06 (always), preds={BB01} succs={BB06}

***** BB02
STMT00019 (IL 0x006...  ???)
N007 ( 10,  8) [000154] -A----------              *  COMMA     void   $40
N003 (  5,  4) [000150] -A------R---              +--*  ASG       byref  $VN.Null
N002 (  3,  2) [000148] D------N----              |  +--*  LCL_VAR   byref  V21 tmp20        d:1 $VN.Null
N001 (  1,  1) [000149] ------------              |  \--*  CNS_INT   byref  0 $VN.Null
N006 (  5,  4) [000153] -A------R---              \--*  ASG       int    $40
N005 (  3,  2) [000151] D------N----                 +--*  LCL_VAR   int    V22 tmp21        d:1 $40
N004 (  1,  1) [000152] ------------                 \--*  CNS_INT   int    0 $40

***** BB02
STMT00020 (IL 0x006...  ???)
N007 ( 14, 10) [000161] -A----------              *  COMMA     void   $40
N003 (  7,  5) [000157] -A------R---              +--*  ASG       byref  $VN.Null
N002 (  3,  2) [000155] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        d:3 $VN.Null
N001 (  3,  2) [000156] ------------              |  \--*  LCL_VAR   byref  V21 tmp20        u:1 (last use) $VN.Null
N006 (  7,  5) [000160] -A------R---              \--*  ASG       int    $40
N005 (  3,  2) [000158] D------N----                 +--*  LCL_VAR   int    V18 tmp17        d:3 $40
N004 (  3,  2) [000159] ------------                 \--*  LCL_VAR   int    V22 tmp21        u:1 (last use) $40

------------ BB03 [006..007) -> BB05 (cond), preds={BB01} succs={BB04,BB05}

***** BB03
STMT00016 (IL 0x006...  ???)
N003 (  0,  0) [000168] ------------              *  COMMA     void   $381
N001 (  0,  0) [000164] ------------              +--*  NOP       void   $380
N002 (  0,  0) [000167] ------------              \--*  NOP       void   $381

***** BB03
STMT00026 (IL 0x006...  ???)
N005 (  7,  6) [000112] -A--G---R---              *  ASG       byref  $303
N004 (  3,  2) [000111] D------N----              +--*  LCL_VAR   byref  V09 tmp8         d:1 $303
N003 (  3,  3) [000173] ------------              \--*  ADD       byref  $303
N001 (  1,  1) [000171] ------------                 +--*  LCL_VAR   ref    V00 arg0         u:1 $80
N002 (  1,  1) [000172] ------------                 \--*  CNS_INT   long   12 field offset Fseq[_firstChar] $203

***** BB03
STMT00027 (IL 0x006...  ???)
N004 (  3,  3) [000114] -A-X----R---              *  ASG       int    $341
N003 (  1,  1) [000113] D------N----              +--*  LCL_VAR   int    V08 tmp7         d:1 $400
N002 (  3,  3) [000057] ---X--------              \--*  ARR_LENGTH int    $341
N001 (  1,  1) [000056] ------------                 \--*  LCL_VAR   ref    V00 arg0         u:1 (last use) $80

***** BB03
STMT00031 (IL 0x006...  ???)
N008 ( 15, 20) [000133] -A--G---R---              *  ASG       ref    $18c
N007 (  3,  2) [000132] D------N----              +--*  LCL_VAR   ref    V13 tmp12        d:1 $18c
N006 ( 11, 17) [000231] -A--G-------              \--*  COMMA     ref    $18c
N004 (  8, 15) [000229] -A--G---R---                 +--*  ASG       ref    $VN.Void
N003 (  3,  2) [000228] D------N----                 |  +--*  LCL_VAR   ref    V27 cse0         d:1 $18c
N002 (  4, 12) [000119] #---G-------                 |  \--*  IND       ref    $18c
N001 (  2, 10) [000118] H-----------                 |     \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL] $106
N005 (  3,  2) [000230] ------------                 \--*  LCL_VAR   ref    V27 cse0         u:1 $18c

***** BB03
STMT00032 (IL 0x006...  ???)
N003 (  7,  5) [000135] -A--G---R---              *  ASG       ref    $18c
N002 (  3,  2) [000134] D------N----              +--*  LCL_VAR   ref    V14 tmp13        d:1 $18c
N001 (  3,  2) [000232] ------------              \--*  LCL_VAR   ref    V27 cse0         u:1 $18c

***** BB03
STMT00029 (IL 0x006...  ???)
N004 (  5,  5) [000128] ------------              *  JTRUE     void  
N003 (  3,  3) [000090] J------N----              \--*  GE        int    $342
N001 (  1,  1) [000088] ------------                 +--*  LCL_VAR   int    V08 tmp7         u:1 $400
N002 (  1,  1) [000089] ------------                 \--*  CNS_INT   int    0 $40

------------ BB04 [006..007), preds={BB03} succs={BB05}

***** BB04
STMT00030 (IL 0x006...  ???)
N005 ( 20, 11) [000131] --CXG-------              *  CALL      void   System.Diagnostics.Debug.Fail $VN.Void
N003 (  3,  2) [000129] ------------ arg0 in rcx  +--*  LCL_VAR   ref    V14 tmp13        u:1 (last use) $18c
N004 (  3,  2) [000130] ------------ arg1 in rdx  \--*  LCL_VAR   ref    V14 tmp13        u:1 (last use) $18c

------------ BB05 [006..007), preds={BB03,BB04} succs={BB06}

***** BB05
STMT00023 (IL 0x006...  ???)
N003 (  7,  5) [000100] -A------R---              *  ASG       byref  $303
N002 (  3,  2) [000099] D------N----              +--*  LCL_VAR   byref  V23 tmp22        d:1 $303
N001 (  3,  2) [000096] ------------              \--*  LCL_VAR   byref  V09 tmp8         u:1 (last use) $303

***** BB05
STMT00024 (IL 0x006...  ???)
N003 (  7,  5) [000179] -A------R---              *  ASG       byref  $303
N002 (  3,  2) [000177] D------N----              +--*  LCL_VAR   byref  V19 tmp18        d:1 $303
N001 (  3,  2) [000178] -------N----              \--*  LCL_VAR   byref  V23 tmp22        u:1 (last use) $303

***** BB05
STMT00025 (IL 0x006...  ???)
N003 (  5,  4) [000110] -A------R---              *  ASG       int    $400
N002 (  3,  2) [000109] D------N----              +--*  LCL_VAR   int    V20 tmp19        d:1 $400
N001 (  1,  1) [000108] ------------              \--*  LCL_VAR   int    V08 tmp7         u:1 (last use) $400

***** BB05
STMT00018 (IL 0x006...  ???)
N007 ( 14, 10) [000186] -A----------              *  COMMA     void   $400
N003 (  7,  5) [000182] -A------R---              +--*  ASG       byref  $303
N002 (  3,  2) [000180] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        d:2 $303
N001 (  3,  2) [000181] ------------              |  \--*  LCL_VAR   byref  V19 tmp18        u:1 (last use) $303
N006 (  7,  5) [000185] -A------R---              \--*  ASG       int    $400
N005 (  3,  2) [000183] D------N----                 +--*  LCL_VAR   int    V18 tmp17        d:2 $400
N004 (  3,  2) [000184] ------------                 \--*  LCL_VAR   int    V20 tmp19        u:1 (last use) $400

------------ BB06 [???..???) (return), preds={BB02,BB05} succs={}

***** BB06
STMT00034 (IL   ???...  ???)
N005 (  0,  0) [000223] -A------R---              *  ASG       int   
N004 (  0,  0) [000221] D------N----              +--*  LCL_VAR   int    V18 tmp17        d:1
N003 (  0,  0) [000222] ------------              \--*  PHI       int   
N001 (  0,  0) [000226] ------------ pred BB02       +--*  PHI_ARG   int    V18 tmp17        u:3 $40
N002 (  0,  0) [000224] ------------ pred BB05       \--*  PHI_ARG   int    V18 tmp17        u:2 $400

***** BB06
STMT00033 (IL   ???...  ???)
N005 (  0,  0) [000220] -A------R---              *  ASG       byref 
N004 (  0,  0) [000218] D------N----              +--*  LCL_VAR   byref  V17 tmp16        d:1
N003 (  0,  0) [000219] ------------              \--*  PHI       byref 
N001 (  0,  0) [000227] ------------ pred BB02       +--*  PHI_ARG   byref  V17 tmp16        u:3 $VN.Null
N002 (  0,  0) [000225] ------------ pred BB05       \--*  PHI_ARG   byref  V17 tmp16        u:2 $303

***** BB06
STMT00003 (IL   ???...  ???)
N007 ( 14, 10) [000193] -A----------              *  COMMA     void   $440
N003 (  7,  5) [000189] -A------R---              +--*  ASG       byref  $480
N002 (  3,  2) [000187] D------N----              |  +--*  LCL_VAR   byref  V15 tmp14        d:1 $480
N001 (  3,  2) [000188] ------------              |  \--*  LCL_VAR   byref  V17 tmp16        u:1 (last use) $480
N006 (  7,  5) [000192] -A------R---              \--*  ASG       int    $440
N005 (  3,  2) [000190] D------N----                 +--*  LCL_VAR   int    V16 tmp15        d:1 $440
N004 (  3,  2) [000191] ------------                 \--*  LCL_VAR   int    V18 tmp17        u:1 (last use) $440

***** BB06
STMT00004 (IL   ???...  ???)
N023 ( 40, 30) [000011] -ACXG-------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer.TokenizeLine $VN.Void
N003 (  1,  3) [000214] -A------R-L- this SETUP   +--*  ASG       ref    $180
N002 (  1,  1) [000213] D------N----              |  +--*  LCL_VAR   ref    V26 tmp25        d:1 $180
N001 (  1,  1) [000007] ------------              |  \--*  LCL_VAR   ref    V02 tmp1         u:1 (last use) $180
N019 ( 18, 15) [000212] -A--------L- arg1 SETUP   +--*  COMMA     void   $VN.Void
N012 ( 10,  8) [000205] -A----------              |  +--*  COMMA     void   $VN.Void
N007 (  3,  3) [000200] -A------R---              |  |  +--*  ASG       byref  $3c7
N006 (  1,  1) [000199] D------N----              |  |  |  +--*  LCL_VAR   byref  V25 tmp24        d:1 $3c7
N005 (  3,  3) [000197] ------------              |  |  |  \--*  ADDR      byref  $3c7
N004 (  3,  2) [000198] -------N----              |  |  |     \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(AX) V24 tmp23         $4c0
N011 (  7,  5) [000204] -A----------              |  |  \--*  ASG       byref  $VN.Void
N009 (  3,  2) [000202] *------N----              |  |     +--*  IND       byref  $480
N008 (  1,  1) [000201] ------------              |  |     |  \--*  LCL_VAR   byref  V25 tmp24        u:1 Zero Fseq[_pointer] $3c7
N010 (  3,  2) [000203] -------N----              |  |     \--*  LCL_VAR   byref  V15 tmp14        u:1 (last use) $480
N018 (  8,  7) [000211] -A----------              |  \--*  ASG       int    $VN.Void
N016 (  4,  4) [000209] *------N----              |     +--*  IND       int    $440
N015 (  2,  2) [000208] -------N----              |     |  \--*  ADD       byref  $305
N013 (  1,  1) [000206] ------------              |     |     +--*  LCL_VAR   byref  V25 tmp24        u:1 (last use) $3c7
N014 (  1,  1) [000207] ------------              |     |     \--*  CNS_INT   long   8 Fseq[_length] $201
N017 (  3,  2) [000210] -------N----              |     \--*  LCL_VAR   int    V16 tmp15        u:1 (last use) $440
N020 (  1,  1) [000215] ------------ this in rcx  +--*  LCL_VAR   ref    V26 tmp25        u:1 (last use) $180
N022 (  3,  3) [000217] ------------ arg1 in rdx  \--*  ADDR      byref  $3c9
N021 (  3,  2) [000216] -------N----                 \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(AX) V24 tmp23         $4c1

***** BB06
STMT00005 (IL 0x011...  ???)
N001 (  0,  0) [000017] ------------              *  RETURN    void   $382

-------------------------------------------------------------------------------------------------------------------

VN based non-null prop in BB01:
N012 (  4,  4) [000038] D--XG--N----              *  IND       ref    $2c0
ReMorphing args for 46.CALL:
argSlots=2, preallocatedArgCount=4, nextSlotNum=4, nextSlotByteOffset=32, outgoingArgSpaceSize=32
ArgTable for 46.CALL after fgMorphArgs:
fgArgTabEntry[arg 0 44.CNS_INT long (By ref), 1 reg: rcx, byteAlignment=8, lateArgInx=0, processed]
fgArgTabEntry[arg 1 45.CNS_INT int (By ref), 1 reg: rdx, byteAlignment=8, lateArgInx=1, processed]

optVNAssertionPropCurStmt morphed tree:
N013 ( 26, 35) [000039] -ACXGO--R---              *  ASG       ref    $VN.Void
N012 (  4,  4) [000038] n---GO-N----              +--*  IND       ref    $2c0
N011 (  2,  2) [000140] -------N----              |  \--*  ADD       byref  $300
N009 (  1,  1) [000035] ------------              |     +--*  LCL_VAR   ref    V04 tmp3         u:1 $181
N010 (  1,  1) [000139] ------------              |     \--*  CNS_INT   long   8 field offset Fseq[_array] $201
N008 ( 21, 30) [000047] --CXG-------              \--*  COMMA     ref    <l:$184, c:$183>
N005 ( 17, 18) [000046] H-CXG-------                 +--*  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS $281
N003 (  2, 10) [000044] ------------ arg0 in rcx     |  +--*  CNS_INT   long   0x7ffa40fb0028 $200
N004 (  1,  1) [000045] ------------ arg1 in rdx     |  \--*  CNS_INT   int    6 $42
N007 (  4, 12) [000042] n---G-------                 \--*  IND       ref    <l:$2c0, c:$144>
N006 (  2, 10) [000143] I-----------                    \--*  CNS_INT(h) long   0xd1ffab1e static Fseq[Value] $102

GenTreeNode creates assertion:
N012 (  4,  4) [000038] n---GO-N----              *  IND       ref    $2c0
In BB01 New Global Constant Assertion: (385, 0) ($181,$0) V04.01 != null index=#01, mask=0000000000000001

VN based non-null prop in BB01:
N004 (  4,  4) [000025] D--XG--N----              *  IND       ref    $181
optVNAssertionPropCurStmt morphed tree:
N006 (  6,  6) [000026] -A--GO------              *  ASG       ref    $VN.Void
N004 (  4,  4) [000025] n---GO-N----              +--*  IND       ref    $181
N003 (  2,  2) [000145] -------N----              |  \--*  ADD       byref  $301
N001 (  1,  1) [000005] ------------              |     +--*  LCL_VAR   ref    V02 tmp1         u:1 $180
N002 (  1,  1) [000144] ------------              |     \--*  CNS_INT   long   16 field offset Fseq[_tokensBuffer] $202
N005 (  1,  1) [000024] ------------              \--*  LCL_VAR   ref    V04 tmp3         u:1 (last use) $181

GenTreeNode creates assertion:
N004 (  4,  4) [000025] n---GO-N----              *  IND       ref    $181
In BB01 New Global Constant Assertion: (384, 0) ($180,$0) V02.01 != null index=#02, mask=0000000000000002

VN based non-null prop in BB01:
N004 (  4,  4) [000031] D--XG--N----              *  IND       ref    $VN.Null
optVNAssertionPropCurStmt morphed tree:
N006 (  6,  6) [000032] -A--GO------              *  ASG       ref    $VN.Void
N004 (  4,  4) [000031] n---GO-N----              +--*  IND       ref    $VN.Null
N003 (  2,  2) [000147] -------N----              |  \--*  ADD       byref  $302
N001 (  1,  1) [000029] ------------              |     +--*  LCL_VAR   ref    V02 tmp1         u:1 $180
N002 (  1,  1) [000146] ------------              |     \--*  CNS_INT   long   8 field offset Fseq[_reader] $201
N005 (  1,  1) [000030] ------------              \--*  CNS_INT   ref    null $VN.Null

GenTreeNode creates assertion:
N004 (  5,  5) [000052] ------------              *  JTRUE     void  
In BB01 New Global Constant Assertion: (128, 0) ($80,$0) V00.01 != null index=#03, mask=0000000000000004
GenTreeNode creates assertion:
N004 (  5,  5) [000052] ------------              *  JTRUE     void  
In BB01 New Global Constant Assertion: (128, 0) ($80,$0) V00.01 == null index=#04, mask=0000000000000008
After constant propagation on [000159]:
STMT00020 (IL 0x006...  ???)
N007 ( 14, 10) [000161] -A----------              *  COMMA     void   $40
N003 (  7,  5) [000157] -A------R---              +--*  ASG       byref  $VN.Null
N002 (  3,  2) [000155] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        d:3 $VN.Null
N001 (  3,  2) [000156] ------------              |  \--*  LCL_VAR   byref  V21 tmp20        u:1 (last use) $VN.Null
N006 (  7,  5) [000160] -A------R---              \--*  ASG       int    $40
N005 (  3,  2) [000158] D------N----                 +--*  LCL_VAR   int    V18 tmp17        d:3 $40
               [000233] ------------                 \--*  CNS_INT   int    0 $40
optVNAssertionPropCurStmt morphed tree:
N007 ( 12,  9) [000161] -A----------              *  COMMA     void   $40
N003 (  7,  5) [000157] -A------R---              +--*  ASG       byref  $VN.Null
N002 (  3,  2) [000155] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        d:3 $VN.Null
N001 (  3,  2) [000156] ------------              |  \--*  LCL_VAR   byref  V21 tmp20        u:1 (last use) $VN.Null
N006 (  5,  4) [000160] -A------R---              \--*  ASG       int    $40
N005 (  3,  2) [000158] D------N----                 +--*  LCL_VAR   int    V18 tmp17        d:3 $40
N004 (  1,  1) [000233] ------------                 \--*  CNS_INT   int    0 $40

GenTreeNode creates assertion:
N002 (  3,  3) [000057] ---X--------              *  ARR_LENGTH int    $341
In BB03 New Global Constant Assertion: (128, 0) ($80,$0) V00.01 != null index=#05, mask=0000000000000010
GenTreeNode creates assertion:
N004 (  5,  5) [000128] ------------              *  JTRUE     void  
In BB03 New Global Constant Assertion: (834, 64) ($342,$40) Loop_Bnd { {IntCns 0} LE  {ARR_LENGTH($80)}} is not  {IntCns 0} index=#06, mask=0000000000000020
GenTreeNode creates assertion:
N004 (  5,  5) [000128] ------------              *  JTRUE     void  
In BB03 New Global Constant Assertion: (834, 64) ($342,$40) Loop_Bnd { {IntCns 0} LE  {ARR_LENGTH($80)}} is  {IntCns 0} index=#07, mask=0000000000000040
GenTreeNode creates assertion:
N009 (  3,  2) [000202] *------N----              *  IND       byref  $480
In BB06 New Global Constant Assertion: (967, 0) ($3c7,$0) Value_Number {3c7} is not 0 index=#08, mask=0000000000000080
BB01 valueGen = 000000000000000B => BB03 valueGen = 0000000000000007,
BB02 valueGen = 0000000000000000
BB03 valueGen = 0000000000000050 => BB05 valueGen = 0000000000000030,
BB04 valueGen = 0000000000000000
BB05 valueGen = 0000000000000000
BB06 valueGen = 0000000000000080
AssertionPropCallback::StartMerge: BB01 in -> 0000000000000000
AssertionPropCallback::EndMerge  : BB01 in -> 0000000000000000

AssertionPropCallback::Changed   : BB01 before out -> 00000000000000FF; after out -> 000000000000000B;
		jumpDest before out -> 00000000000000FF; jumpDest after out -> 0000000000000007;

AssertionPropCallback::StartMerge: BB02 in -> 00000000000000FF
AssertionPropCallback::Merge     : BB02 in -> 00000000000000FF, predBlock BB01 out -> 000000000000000B
AssertionPropCallback::EndMerge  : BB02 in -> 000000000000000B

AssertionPropCallback::Changed   : BB02 before out -> 00000000000000FF; after out -> 000000000000000B;
		jumpDest before out -> 00000000000000FF; jumpDest after out -> 000000000000000B;

AssertionPropCallback::StartMerge: BB03 in -> 00000000000000FF
AssertionPropCallback::Merge     : BB03 in -> 00000000000000FF, predBlock BB01 out -> 000000000000000B
AssertionPropCallback::EndMerge  : BB03 in -> 0000000000000007

AssertionPropCallback::Changed   : BB03 before out -> 00000000000000FF; after out -> 0000000000000057;
		jumpDest before out -> 00000000000000FF; jumpDest after out -> 0000000000000037;

AssertionPropCallback::StartMerge: BB06 in -> 00000000000000FF
AssertionPropCallback::Merge     : BB06 in -> 00000000000000FF, predBlock BB02 out -> 000000000000000B
AssertionPropCallback::Merge     : BB06 in -> 000000000000000B, predBlock BB05 out -> 00000000000000FF
AssertionPropCallback::EndMerge  : BB06 in -> 000000000000000B

AssertionPropCallback::Changed   : BB06 before out -> 00000000000000FF; after out -> 000000000000008B;
		jumpDest before out -> 00000000000000FF; jumpDest after out -> 000000000000000B;

AssertionPropCallback::StartMerge: BB04 in -> 00000000000000FF
AssertionPropCallback::Merge     : BB04 in -> 00000000000000FF, predBlock BB03 out -> 0000000000000057
AssertionPropCallback::EndMerge  : BB04 in -> 0000000000000057

AssertionPropCallback::Changed   : BB04 before out -> 00000000000000FF; after out -> 0000000000000057;
		jumpDest before out -> 00000000000000FF; jumpDest after out -> 0000000000000057;

AssertionPropCallback::StartMerge: BB05 in -> 00000000000000FF
AssertionPropCallback::Merge     : BB05 in -> 00000000000000FF, predBlock BB03 out -> 0000000000000057
AssertionPropCallback::Merge     : BB05 in -> 0000000000000037, predBlock BB04 out -> 0000000000000057
AssertionPropCallback::EndMerge  : BB05 in -> 0000000000000017

AssertionPropCallback::Changed   : BB05 before out -> 00000000000000FF; after out -> 0000000000000017;
		jumpDest before out -> 00000000000000FF; jumpDest after out -> 0000000000000017;

AssertionPropCallback::StartMerge: BB05 in -> 0000000000000017
AssertionPropCallback::Merge     : BB05 in -> 0000000000000017, predBlock BB03 out -> 0000000000000057
AssertionPropCallback::Merge     : BB05 in -> 0000000000000017, predBlock BB04 out -> 0000000000000057
AssertionPropCallback::EndMerge  : BB05 in -> 0000000000000017

AssertionPropCallback::Unchanged  : BB05 out -> 0000000000000017; 		jumpDest out -> 0000000000000017

AssertionPropCallback::StartMerge: BB06 in -> 000000000000000B
AssertionPropCallback::Merge     : BB06 in -> 000000000000000B, predBlock BB02 out -> 000000000000000B
AssertionPropCallback::Merge     : BB06 in -> 000000000000000B, predBlock BB05 out -> 0000000000000017
AssertionPropCallback::EndMerge  : BB06 in -> 0000000000000003

AssertionPropCallback::Changed   : BB06 before out -> 000000000000008B; after out -> 0000000000000083;
		jumpDest before out -> 000000000000000B; jumpDest after out -> 0000000000000003;



BB01 valueIn  = 0000000000000000 valueOut = 000000000000000B => BB03 valueOut= 0000000000000007
BB02 valueIn  = 000000000000000B valueOut = 000000000000000B
BB03 valueIn  = 0000000000000007 valueOut = 0000000000000057 => BB05 valueOut= 0000000000000037
BB04 valueIn  = 0000000000000057 valueOut = 0000000000000057
BB05 valueIn  = 0000000000000017 valueOut = 0000000000000017
BB06 valueIn  = 0000000000000003 valueOut = 0000000000000083
Propagating 0000000000000000 assertions for BB01, stmt STMT00000, tree [000137], tree -> 0
Propagating 0000000000000000 assertions for BB01, stmt STMT00000, tree [000001], tree -> 0
Propagating 0000000000000000 assertions for BB01, stmt STMT00000, tree [000002], tree -> 0
Propagating 0000000000000000 assertions for BB01, stmt STMT00000, tree [000003], tree -> 0
Propagating 0000000000000000 assertions for BB01, stmt STMT00000, tree [000004], tree -> 0
Propagating 0000000000000000 assertions for BB01, stmt STMT00006, tree [000138], tree -> 0
Propagating 0000000000000000 assertions for BB01, stmt STMT00006, tree [000018], tree -> 0
Propagating 0000000000000000 assertions for BB01, stmt STMT00006, tree [000019], tree -> 0
Propagating 0000000000000000 assertions for BB01, stmt STMT00006, tree [000020], tree -> 0
Propagating 0000000000000000 assertions for BB01, stmt STMT00006, tree [000021], tree -> 0
Propagating 0000000000000000 assertions for BB01, stmt STMT00013, tree [000141], tree -> 0
Propagating 0000000000000000 assertions for BB01, stmt STMT00013, tree [000142], tree -> 0
Propagating 0000000000000000 assertions for BB01, stmt STMT00013, tree [000044], tree -> 0
Propagating 0000000000000000 assertions for BB01, stmt STMT00013, tree [000045], tree -> 0
Propagating 0000000000000000 assertions for BB01, stmt STMT00013, tree [000046], tree -> 0
Propagating 0000000000000000 assertions for BB01, stmt STMT00013, tree [000143], tree -> 0
Propagating 0000000000000000 assertions for BB01, stmt STMT00013, tree [000042], tree -> 0
Propagating 0000000000000000 assertions for BB01, stmt STMT00013, tree [000047], tree -> 0
Propagating 0000000000000000 assertions for BB01, stmt STMT00013, tree [000035], tree -> 0
Propagating 0000000000000000 assertions for BB01, stmt STMT00013, tree [000139], tree -> 0
Propagating 0000000000000000 assertions for BB01, stmt STMT00013, tree [000140], tree -> 0
Propagating 0000000000000000 assertions for BB01, stmt STMT00013, tree [000038], tree -> 1
Propagating 0000000000000001 assertions for BB01, stmt STMT00013, tree [000039], tree -> 0
Propagating 0000000000000001 assertions for BB01, stmt STMT00008, tree [000005], tree -> 0
Propagating 0000000000000001 assertions for BB01, stmt STMT00008, tree [000144], tree -> 0
Propagating 0000000000000001 assertions for BB01, stmt STMT00008, tree [000145], tree -> 0
Propagating 0000000000000001 assertions for BB01, stmt STMT00008, tree [000025], tree -> 2
Propagating 0000000000000003 assertions for BB01, stmt STMT00008, tree [000024], tree -> 0
Propagating 0000000000000003 assertions for BB01, stmt STMT00008, tree [000026], tree -> 0
Propagating 0000000000000003 assertions for BB01, stmt STMT00010, tree [000029], tree -> 0
Propagating 0000000000000003 assertions for BB01, stmt STMT00010, tree [000146], tree -> 0
Propagating 0000000000000003 assertions for BB01, stmt STMT00010, tree [000147], tree -> 0
Propagating 0000000000000003 assertions for BB01, stmt STMT00010, tree [000031], tree -> 2
Propagating 0000000000000003 assertions for BB01, stmt STMT00010, tree [000030], tree -> 0
Propagating 0000000000000003 assertions for BB01, stmt STMT00010, tree [000032], tree -> 0
Propagating 0000000000000003 assertions for BB01, stmt STMT00014, tree [000008], tree -> 0
Propagating 0000000000000003 assertions for BB01, stmt STMT00014, tree [000050], tree -> 0
Propagating 0000000000000003 assertions for BB01, stmt STMT00014, tree [000051], tree -> 0
Failed to find a suitable dominating compare, so we won't optimize
Propagating 0000000000000003 assertions for BB01, stmt STMT00014, tree [000052], tree -> 3
Propagating 000000000000000B assertions for BB02, stmt STMT00019, tree [000149], tree -> 0
Propagating 000000000000000B assertions for BB02, stmt STMT00019, tree [000148], tree -> 0
Propagating 000000000000000B assertions for BB02, stmt STMT00019, tree [000150], tree -> 0
Propagating 000000000000000B assertions for BB02, stmt STMT00019, tree [000152], tree -> 0
Propagating 000000000000000B assertions for BB02, stmt STMT00019, tree [000151], tree -> 0
Propagating 000000000000000B assertions for BB02, stmt STMT00019, tree [000153], tree -> 0
Propagating 000000000000000B assertions for BB02, stmt STMT00019, tree [000154], tree -> 0
Propagating 000000000000000B assertions for BB02, stmt STMT00020, tree [000156], tree -> 0
Propagating 000000000000000B assertions for BB02, stmt STMT00020, tree [000155], tree -> 0
Propagating 000000000000000B assertions for BB02, stmt STMT00020, tree [000157], tree -> 0
Propagating 000000000000000B assertions for BB02, stmt STMT00020, tree [000233], tree -> 0
Propagating 000000000000000B assertions for BB02, stmt STMT00020, tree [000158], tree -> 0
Propagating 000000000000000B assertions for BB02, stmt STMT00020, tree [000160], tree -> 0
Propagating 000000000000000B assertions for BB02, stmt STMT00020, tree [000161], tree -> 0
Propagating 0000000000000007 assertions for BB03, stmt STMT00016, tree [000164], tree -> 0
Propagating 0000000000000007 assertions for BB03, stmt STMT00016, tree [000167], tree -> 0
Propagating 0000000000000007 assertions for BB03, stmt STMT00016, tree [000168], tree -> 0
Propagating 0000000000000007 assertions for BB03, stmt STMT00026, tree [000171], tree -> 0
Propagating 0000000000000007 assertions for BB03, stmt STMT00026, tree [000172], tree -> 0
Propagating 0000000000000007 assertions for BB03, stmt STMT00026, tree [000173], tree -> 0
Propagating 0000000000000007 assertions for BB03, stmt STMT00026, tree [000111], tree -> 0
Propagating 0000000000000007 assertions for BB03, stmt STMT00026, tree [000112], tree -> 0
Propagating 0000000000000007 assertions for BB03, stmt STMT00027, tree [000056], tree -> 0
Propagating 0000000000000007 assertions for BB03, stmt STMT00027, tree [000057], tree -> 5
Propagating 0000000000000017 assertions for BB03, stmt STMT00027, tree [000113], tree -> 0
Propagating 0000000000000017 assertions for BB03, stmt STMT00027, tree [000114], tree -> 0
Propagating 0000000000000017 assertions for BB03, stmt STMT00031, tree [000118], tree -> 0
Propagating 0000000000000017 assertions for BB03, stmt STMT00031, tree [000119], tree -> 0
Propagating 0000000000000017 assertions for BB03, stmt STMT00031, tree [000228], tree -> 0
Propagating 0000000000000017 assertions for BB03, stmt STMT00031, tree [000229], tree -> 0
Propagating 0000000000000017 assertions for BB03, stmt STMT00031, tree [000230], tree -> 0
Propagating 0000000000000017 assertions for BB03, stmt STMT00031, tree [000231], tree -> 0
Propagating 0000000000000017 assertions for BB03, stmt STMT00031, tree [000132], tree -> 0
Propagating 0000000000000017 assertions for BB03, stmt STMT00031, tree [000133], tree -> 0
Propagating 0000000000000017 assertions for BB03, stmt STMT00032, tree [000232], tree -> 0
Propagating 0000000000000017 assertions for BB03, stmt STMT00032, tree [000134], tree -> 0
Propagating 0000000000000017 assertions for BB03, stmt STMT00032, tree [000135], tree -> 0
Propagating 0000000000000017 assertions for BB03, stmt STMT00029, tree [000088], tree -> 0
Propagating 0000000000000017 assertions for BB03, stmt STMT00029, tree [000089], tree -> 0
Propagating 0000000000000017 assertions for BB03, stmt STMT00029, tree [000090], tree -> 0

VN relop, checking BB03 for redundancy
 ... checking dom BB01
Failed to find a suitable dominating compare, so we won't optimize
Propagating 0000000000000017 assertions for BB03, stmt STMT00029, tree [000128], tree -> 6
Propagating 0000000000000057 assertions for BB04, stmt STMT00030, tree [000175], tree -> 0
Propagating 0000000000000057 assertions for BB04, stmt STMT00030, tree [000176], tree -> 0
Propagating 0000000000000057 assertions for BB04, stmt STMT00030, tree [000129], tree -> 0
Propagating 0000000000000057 assertions for BB04, stmt STMT00030, tree [000130], tree -> 0
Propagating 0000000000000057 assertions for BB04, stmt STMT00030, tree [000131], tree -> 0
Propagating 0000000000000017 assertions for BB05, stmt STMT00023, tree [000096], tree -> 0
Propagating 0000000000000017 assertions for BB05, stmt STMT00023, tree [000099], tree -> 0
Propagating 0000000000000017 assertions for BB05, stmt STMT00023, tree [000100], tree -> 0
Propagating 0000000000000017 assertions for BB05, stmt STMT00024, tree [000178], tree -> 0
Propagating 0000000000000017 assertions for BB05, stmt STMT00024, tree [000177], tree -> 0
Propagating 0000000000000017 assertions for BB05, stmt STMT00024, tree [000179], tree -> 0
Propagating 0000000000000017 assertions for BB05, stmt STMT00025, tree [000108], tree -> 0
Propagating 0000000000000017 assertions for BB05, stmt STMT00025, tree [000109], tree -> 0
Propagating 0000000000000017 assertions for BB05, stmt STMT00025, tree [000110], tree -> 0
Propagating 0000000000000017 assertions for BB05, stmt STMT00018, tree [000181], tree -> 0
Propagating 0000000000000017 assertions for BB05, stmt STMT00018, tree [000180], tree -> 0
Propagating 0000000000000017 assertions for BB05, stmt STMT00018, tree [000182], tree -> 0
Propagating 0000000000000017 assertions for BB05, stmt STMT00018, tree [000184], tree -> 0
Propagating 0000000000000017 assertions for BB05, stmt STMT00018, tree [000183], tree -> 0
Propagating 0000000000000017 assertions for BB05, stmt STMT00018, tree [000185], tree -> 0
Propagating 0000000000000017 assertions for BB05, stmt STMT00018, tree [000186], tree -> 0
Propagating 0000000000000003 assertions for BB06, stmt STMT00003, tree [000188], tree -> 0
Propagating 0000000000000003 assertions for BB06, stmt STMT00003, tree [000187], tree -> 0
Propagating 0000000000000003 assertions for BB06, stmt STMT00003, tree [000189], tree -> 0
Propagating 0000000000000003 assertions for BB06, stmt STMT00003, tree [000191], tree -> 0
Propagating 0000000000000003 assertions for BB06, stmt STMT00003, tree [000190], tree -> 0
Propagating 0000000000000003 assertions for BB06, stmt STMT00003, tree [000192], tree -> 0
Propagating 0000000000000003 assertions for BB06, stmt STMT00003, tree [000193], tree -> 0
Propagating 0000000000000003 assertions for BB06, stmt STMT00004, tree [000007], tree -> 0
Propagating 0000000000000003 assertions for BB06, stmt STMT00004, tree [000213], tree -> 0
Propagating 0000000000000003 assertions for BB06, stmt STMT00004, tree [000214], tree -> 0
Propagating 0000000000000003 assertions for BB06, stmt STMT00004, tree [000198], tree -> 0
Propagating 0000000000000003 assertions for BB06, stmt STMT00004, tree [000197], tree -> 0
Propagating 0000000000000003 assertions for BB06, stmt STMT00004, tree [000199], tree -> 0
Propagating 0000000000000003 assertions for BB06, stmt STMT00004, tree [000200], tree -> 0
Propagating 0000000000000003 assertions for BB06, stmt STMT00004, tree [000201], tree -> 0
Propagating 0000000000000003 assertions for BB06, stmt STMT00004, tree [000202], tree -> 8
Propagating 0000000000000083 assertions for BB06, stmt STMT00004, tree [000203], tree -> 0
Propagating 0000000000000083 assertions for BB06, stmt STMT00004, tree [000204], tree -> 0
Propagating 0000000000000083 assertions for BB06, stmt STMT00004, tree [000205], tree -> 0
Propagating 0000000000000083 assertions for BB06, stmt STMT00004, tree [000206], tree -> 0
Propagating 0000000000000083 assertions for BB06, stmt STMT00004, tree [000207], tree -> 0
Propagating 0000000000000083 assertions for BB06, stmt STMT00004, tree [000208], tree -> 0
Propagating 0000000000000083 assertions for BB06, stmt STMT00004, tree [000209], tree -> 8
Propagating 0000000000000083 assertions for BB06, stmt STMT00004, tree [000210], tree -> 0
Propagating 0000000000000083 assertions for BB06, stmt STMT00004, tree [000211], tree -> 0
Propagating 0000000000000083 assertions for BB06, stmt STMT00004, tree [000212], tree -> 0
Propagating 0000000000000083 assertions for BB06, stmt STMT00004, tree [000215], tree -> 0
Propagating 0000000000000083 assertions for BB06, stmt STMT00004, tree [000216], tree -> 0
Propagating 0000000000000083 assertions for BB06, stmt STMT00004, tree [000217], tree -> 0
Propagating 0000000000000083 assertions for BB06, stmt STMT00004, tree [000011], tree -> 0
Propagating 0000000000000083 assertions for BB06, stmt STMT00005, tree [000017], tree -> 0
*************** In fgDebugCheckBBlist

*************** Finishing PHASE Assertion prop

*************** Starting PHASE Optimize index checks
*************** In OptimizeRangeChecks()
Blocks/trees before phase

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)-> BB03 ( cond )                     i label target hascall newobj 
BB02 [0007]  1       BB01                  0.50     [006..007)-> BB06 (always)                     i 
BB03 [0008]  1       BB01                  0.50     [006..007)-> BB05 ( cond )                     i label target idxlen nullcheck 
BB04 [0014]  1       BB03                  0.25     [006..007)                                     i hascall gcsafe 
BB05 [0015]  2       BB03,BB04             0.50     [006..007)                                     i label target idxlen nullcheck 
BB06 [0009]  2       BB02,BB05             1        [???..???)        (return)                     internal label target hascall gcsafe newobj 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..012) -> BB03 (cond), preds={} succs={BB02,BB03}

***** BB01
STMT00000 (IL 0x000...0x011)
N005 ( 16, 16) [000004] -AC-----R---              *  ASG       ref    $180
N004 (  1,  1) [000003] D------N----              +--*  LCL_VAR   ref    V02 tmp1         d:1 $180
N003 ( 16, 16) [000002] --C---------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST $180
N002 (  2, 10) [000001] H----------- arg0 in rcx     \--*  CNS_INT(h) long   0xd1ffab1e token $100

***** BB01
STMT00006 (IL   ???...  ???)
N005 ( 16, 16) [000021] -AC-----R---              *  ASG       ref    $181
N004 (  1,  1) [000020] D------N----              +--*  LCL_VAR   ref    V04 tmp3         d:1 $181
N003 ( 16, 16) [000019] --C---------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST $181
N002 (  2, 10) [000018] H----------- arg0 in rcx     \--*  CNS_INT(h) long   0xd1ffab1e token $101

***** BB01
STMT00013 (IL   ???...  ???)
N013 ( 26, 35) [000039] -ACXGO--R---              *  ASG       ref    $VN.Void
N012 (  4,  4) [000038] n---GO-N----              +--*  IND       ref    $2c0
N011 (  2,  2) [000140] -------N----              |  \--*  ADD       byref  $300
N009 (  1,  1) [000035] ------------              |     +--*  LCL_VAR   ref    V04 tmp3         u:1 $181
N010 (  1,  1) [000139] ------------              |     \--*  CNS_INT   long   8 field offset Fseq[_array] $201
N008 ( 21, 30) [000047] --CXG-------              \--*  COMMA     ref    <l:$184, c:$183>
N005 ( 17, 18) [000046] H-CXG-------                 +--*  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS $281
N003 (  2, 10) [000044] ------------ arg0 in rcx     |  +--*  CNS_INT   long   0x7ffa40fb0028 $200
N004 (  1,  1) [000045] ------------ arg1 in rdx     |  \--*  CNS_INT   int    6 $42
N007 (  4, 12) [000042] n---G-------                 \--*  IND       ref    <l:$2c0, c:$144>
N006 (  2, 10) [000143] I-----------                    \--*  CNS_INT(h) long   0xd1ffab1e static Fseq[Value] $102

***** BB01
STMT00008 (IL   ???...  ???)
N006 (  6,  6) [000026] -A--GO------              *  ASG       ref    $VN.Void
N004 (  4,  4) [000025] n---GO-N----              +--*  IND       ref    $181
N003 (  2,  2) [000145] -------N----              |  \--*  ADD       byref  $301
N001 (  1,  1) [000005] ------------              |     +--*  LCL_VAR   ref    V02 tmp1         u:1 $180
N002 (  1,  1) [000144] ------------              |     \--*  CNS_INT   long   16 field offset Fseq[_tokensBuffer] $202
N005 (  1,  1) [000024] ------------              \--*  LCL_VAR   ref    V04 tmp3         u:1 (last use) $181

***** BB01
STMT00010 (IL   ???...  ???)
N006 (  6,  6) [000032] -A--GO------              *  ASG       ref    $VN.Void
N004 (  4,  4) [000031] n---GO-N----              +--*  IND       ref    $VN.Null
N003 (  2,  2) [000147] -------N----              |  \--*  ADD       byref  $302
N001 (  1,  1) [000029] ------------              |     +--*  LCL_VAR   ref    V02 tmp1         u:1 $180
N002 (  1,  1) [000146] ------------              |     \--*  CNS_INT   long   8 field offset Fseq[_reader] $201
N005 (  1,  1) [000030] ------------              \--*  CNS_INT   ref    null $VN.Null

***** BB01
STMT00014 (IL 0x006...  ???)
N004 (  5,  5) [000052] ------------              *  JTRUE     void  
N003 (  3,  3) [000051] J------N----              \--*  NE        int    $340
N001 (  1,  1) [000008] ------------                 +--*  LCL_VAR   ref    V00 arg0         u:1 $80
N002 (  1,  1) [000050] ------------                 \--*  CNS_INT   ref    null $VN.Null

------------ BB02 [006..007) -> BB06 (always), preds={BB01} succs={BB06}

***** BB02
STMT00019 (IL 0x006...  ???)
N007 ( 10,  8) [000154] -A----------              *  COMMA     void   $40
N003 (  5,  4) [000150] -A------R---              +--*  ASG       byref  $VN.Null
N002 (  3,  2) [000148] D------N----              |  +--*  LCL_VAR   byref  V21 tmp20        d:1 $VN.Null
N001 (  1,  1) [000149] ------------              |  \--*  CNS_INT   byref  0 $VN.Null
N006 (  5,  4) [000153] -A------R---              \--*  ASG       int    $40
N005 (  3,  2) [000151] D------N----                 +--*  LCL_VAR   int    V22 tmp21        d:1 $40
N004 (  1,  1) [000152] ------------                 \--*  CNS_INT   int    0 $40

***** BB02
STMT00020 (IL 0x006...  ???)
N007 ( 12,  9) [000161] -A----------              *  COMMA     void   $40
N003 (  7,  5) [000157] -A------R---              +--*  ASG       byref  $VN.Null
N002 (  3,  2) [000155] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        d:3 $VN.Null
N001 (  3,  2) [000156] ------------              |  \--*  LCL_VAR   byref  V21 tmp20        u:1 (last use) $VN.Null
N006 (  5,  4) [000160] -A------R---              \--*  ASG       int    $40
N005 (  3,  2) [000158] D------N----                 +--*  LCL_VAR   int    V18 tmp17        d:3 $40
N004 (  1,  1) [000233] ------------                 \--*  CNS_INT   int    0 $40

------------ BB03 [006..007) -> BB05 (cond), preds={BB01} succs={BB04,BB05}

***** BB03
STMT00016 (IL 0x006...  ???)
N003 (  0,  0) [000168] ------------              *  COMMA     void   $381
N001 (  0,  0) [000164] ------------              +--*  NOP       void   $380
N002 (  0,  0) [000167] ------------              \--*  NOP       void   $381

***** BB03
STMT00026 (IL 0x006...  ???)
N005 (  7,  6) [000112] -A--G---R---              *  ASG       byref  $303
N004 (  3,  2) [000111] D------N----              +--*  LCL_VAR   byref  V09 tmp8         d:1 $303
N003 (  3,  3) [000173] ------------              \--*  ADD       byref  $303
N001 (  1,  1) [000171] ------------                 +--*  LCL_VAR   ref    V00 arg0         u:1 $80
N002 (  1,  1) [000172] ------------                 \--*  CNS_INT   long   12 field offset Fseq[_firstChar] $203

***** BB03
STMT00027 (IL 0x006...  ???)
N004 (  3,  3) [000114] -A-X----R---              *  ASG       int    $341
N003 (  1,  1) [000113] D------N----              +--*  LCL_VAR   int    V08 tmp7         d:1 $400
N002 (  3,  3) [000057] ---X--------              \--*  ARR_LENGTH int    $341
N001 (  1,  1) [000056] ------------                 \--*  LCL_VAR   ref    V00 arg0         u:1 (last use) $80

***** BB03
STMT00031 (IL 0x006...  ???)
N008 ( 15, 20) [000133] -A--G---R---              *  ASG       ref    $18c
N007 (  3,  2) [000132] D------N----              +--*  LCL_VAR   ref    V13 tmp12        d:1 $18c
N006 ( 11, 17) [000231] -A--G-------              \--*  COMMA     ref    $18c
N004 (  8, 15) [000229] -A--G---R---                 +--*  ASG       ref    $VN.Void
N003 (  3,  2) [000228] D------N----                 |  +--*  LCL_VAR   ref    V27 cse0         d:1 $18c
N002 (  4, 12) [000119] #---G-------                 |  \--*  IND       ref    $18c
N001 (  2, 10) [000118] H-----------                 |     \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL] $106
N005 (  3,  2) [000230] ------------                 \--*  LCL_VAR   ref    V27 cse0         u:1 $18c

***** BB03
STMT00032 (IL 0x006...  ???)
N003 (  7,  5) [000135] -A--G---R---              *  ASG       ref    $18c
N002 (  3,  2) [000134] D------N----              +--*  LCL_VAR   ref    V14 tmp13        d:1 $18c
N001 (  3,  2) [000232] ------------              \--*  LCL_VAR   ref    V27 cse0         u:1 $18c

***** BB03
STMT00029 (IL 0x006...  ???)
N004 (  5,  5) [000128] ------------              *  JTRUE     void  
N003 (  3,  3) [000090] J------N----              \--*  GE        int    $342
N001 (  1,  1) [000088] ------------                 +--*  LCL_VAR   int    V08 tmp7         u:1 $400
N002 (  1,  1) [000089] ------------                 \--*  CNS_INT   int    0 $40

------------ BB04 [006..007), preds={BB03} succs={BB05}

***** BB04
STMT00030 (IL 0x006...  ???)
N005 ( 20, 11) [000131] --CXG-------              *  CALL      void   System.Diagnostics.Debug.Fail $VN.Void
N003 (  3,  2) [000129] ------------ arg0 in rcx  +--*  LCL_VAR   ref    V14 tmp13        u:1 (last use) $18c
N004 (  3,  2) [000130] ------------ arg1 in rdx  \--*  LCL_VAR   ref    V14 tmp13        u:1 (last use) $18c

------------ BB05 [006..007), preds={BB03,BB04} succs={BB06}

***** BB05
STMT00023 (IL 0x006...  ???)
N003 (  7,  5) [000100] -A------R---              *  ASG       byref  $303
N002 (  3,  2) [000099] D------N----              +--*  LCL_VAR   byref  V23 tmp22        d:1 $303
N001 (  3,  2) [000096] ------------              \--*  LCL_VAR   byref  V09 tmp8         u:1 (last use) $303

***** BB05
STMT00024 (IL 0x006...  ???)
N003 (  7,  5) [000179] -A------R---              *  ASG       byref  $303
N002 (  3,  2) [000177] D------N----              +--*  LCL_VAR   byref  V19 tmp18        d:1 $303
N001 (  3,  2) [000178] -------N----              \--*  LCL_VAR   byref  V23 tmp22        u:1 (last use) $303

***** BB05
STMT00025 (IL 0x006...  ???)
N003 (  5,  4) [000110] -A------R---              *  ASG       int    $400
N002 (  3,  2) [000109] D------N----              +--*  LCL_VAR   int    V20 tmp19        d:1 $400
N001 (  1,  1) [000108] ------------              \--*  LCL_VAR   int    V08 tmp7         u:1 (last use) $400

***** BB05
STMT00018 (IL 0x006...  ???)
N007 ( 14, 10) [000186] -A----------              *  COMMA     void   $400
N003 (  7,  5) [000182] -A------R---              +--*  ASG       byref  $303
N002 (  3,  2) [000180] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        d:2 $303
N001 (  3,  2) [000181] ------------              |  \--*  LCL_VAR   byref  V19 tmp18        u:1 (last use) $303
N006 (  7,  5) [000185] -A------R---              \--*  ASG       int    $400
N005 (  3,  2) [000183] D------N----                 +--*  LCL_VAR   int    V18 tmp17        d:2 $400
N004 (  3,  2) [000184] ------------                 \--*  LCL_VAR   int    V20 tmp19        u:1 (last use) $400

------------ BB06 [???..???) (return), preds={BB02,BB05} succs={}

***** BB06
STMT00034 (IL   ???...  ???)
N005 (  0,  0) [000223] -A------R---              *  ASG       int   
N004 (  0,  0) [000221] D------N----              +--*  LCL_VAR   int    V18 tmp17        d:1
N003 (  0,  0) [000222] ------------              \--*  PHI       int   
N001 (  0,  0) [000226] ------------ pred BB02       +--*  PHI_ARG   int    V18 tmp17        u:3 $40
N002 (  0,  0) [000224] ------------ pred BB05       \--*  PHI_ARG   int    V18 tmp17        u:2 $400

***** BB06
STMT00033 (IL   ???...  ???)
N005 (  0,  0) [000220] -A------R---              *  ASG       byref 
N004 (  0,  0) [000218] D------N----              +--*  LCL_VAR   byref  V17 tmp16        d:1
N003 (  0,  0) [000219] ------------              \--*  PHI       byref 
N001 (  0,  0) [000227] ------------ pred BB02       +--*  PHI_ARG   byref  V17 tmp16        u:3 $VN.Null
N002 (  0,  0) [000225] ------------ pred BB05       \--*  PHI_ARG   byref  V17 tmp16        u:2 $303

***** BB06
STMT00003 (IL   ???...  ???)
N007 ( 14, 10) [000193] -A----------              *  COMMA     void   $440
N003 (  7,  5) [000189] -A------R---              +--*  ASG       byref  $480
N002 (  3,  2) [000187] D------N----              |  +--*  LCL_VAR   byref  V15 tmp14        d:1 $480
N001 (  3,  2) [000188] ------------              |  \--*  LCL_VAR   byref  V17 tmp16        u:1 (last use) $480
N006 (  7,  5) [000192] -A------R---              \--*  ASG       int    $440
N005 (  3,  2) [000190] D------N----                 +--*  LCL_VAR   int    V16 tmp15        d:1 $440
N004 (  3,  2) [000191] ------------                 \--*  LCL_VAR   int    V18 tmp17        u:1 (last use) $440

***** BB06
STMT00004 (IL   ???...  ???)
N023 ( 40, 30) [000011] -ACXG-------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer.TokenizeLine $VN.Void
N003 (  1,  3) [000214] -A------R-L- this SETUP   +--*  ASG       ref    $180
N002 (  1,  1) [000213] D------N----              |  +--*  LCL_VAR   ref    V26 tmp25        d:1 $180
N001 (  1,  1) [000007] ------------              |  \--*  LCL_VAR   ref    V02 tmp1         u:1 (last use) $180
N019 ( 18, 15) [000212] -A--------L- arg1 SETUP   +--*  COMMA     void   $VN.Void
N012 ( 10,  8) [000205] -A----------              |  +--*  COMMA     void   $VN.Void
N007 (  3,  3) [000200] -A------R---              |  |  +--*  ASG       byref  $3c7
N006 (  1,  1) [000199] D------N----              |  |  |  +--*  LCL_VAR   byref  V25 tmp24        d:1 $3c7
N005 (  3,  3) [000197] ------------              |  |  |  \--*  ADDR      byref  $3c7
N004 (  3,  2) [000198] -------N----              |  |  |     \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(AX) V24 tmp23         $4c0
N011 (  7,  5) [000204] -A----------              |  |  \--*  ASG       byref  $VN.Void
N009 (  3,  2) [000202] *------N----              |  |     +--*  IND       byref  $480
N008 (  1,  1) [000201] ------------              |  |     |  \--*  LCL_VAR   byref  V25 tmp24        u:1 Zero Fseq[_pointer] $3c7
N010 (  3,  2) [000203] -------N----              |  |     \--*  LCL_VAR   byref  V15 tmp14        u:1 (last use) $480
N018 (  8,  7) [000211] -A----------              |  \--*  ASG       int    $VN.Void
N016 (  4,  4) [000209] *------N----              |     +--*  IND       int    $440
N015 (  2,  2) [000208] -------N----              |     |  \--*  ADD       byref  $305
N013 (  1,  1) [000206] ------------              |     |     +--*  LCL_VAR   byref  V25 tmp24        u:1 (last use) $3c7
N014 (  1,  1) [000207] ------------              |     |     \--*  CNS_INT   long   8 Fseq[_length] $201
N017 (  3,  2) [000210] -------N----              |     \--*  LCL_VAR   int    V16 tmp15        u:1 (last use) $440
N020 (  1,  1) [000215] ------------ this in rcx  +--*  LCL_VAR   ref    V26 tmp25        u:1 (last use) $180
N022 (  3,  3) [000217] ------------ arg1 in rdx  \--*  ADDR      byref  $3c9
N021 (  3,  2) [000216] -------N----                 \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(AX) V24 tmp23         $4c1

***** BB06
STMT00005 (IL 0x011...  ???)
N001 (  0,  0) [000017] ------------              *  RETURN    void   $382

-------------------------------------------------------------------------------------------------------------------

*************** Finishing PHASE Optimize index checks

*************** Starting PHASE Insert GC Polls

*************** Finishing PHASE Insert GC Polls [no changes]

*************** Starting PHASE Determine first cold block

*************** In fgDetermineFirstColdBlock()
No procedure splitting will be done for this method

*************** Finishing PHASE Determine first cold block
Trees before Rationalize IR

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)-> BB03 ( cond )                     i label target hascall newobj 
BB02 [0007]  1       BB01                  0.50     [006..007)-> BB06 (always)                     i 
BB03 [0008]  1       BB01                  0.50     [006..007)-> BB05 ( cond )                     i label target idxlen nullcheck 
BB04 [0014]  1       BB03                  0.25     [006..007)                                     i hascall gcsafe 
BB05 [0015]  2       BB03,BB04             0.50     [006..007)                                     i label target idxlen nullcheck 
BB06 [0009]  2       BB02,BB05             1        [???..???)        (return)                     internal label target hascall gcsafe newobj 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..012) -> BB03 (cond), preds={} succs={BB02,BB03}

***** BB01
STMT00000 (IL 0x000...0x011)
N005 ( 16, 16) [000004] -AC-----R---              *  ASG       ref    $180
N004 (  1,  1) [000003] D------N----              +--*  LCL_VAR   ref    V02 tmp1         d:1 $180
N003 ( 16, 16) [000002] --C---------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST $180
N002 (  2, 10) [000001] H----------- arg0 in rcx     \--*  CNS_INT(h) long   0xd1ffab1e token $100

***** BB01
STMT00006 (IL   ???...  ???)
N005 ( 16, 16) [000021] -AC-----R---              *  ASG       ref    $181
N004 (  1,  1) [000020] D------N----              +--*  LCL_VAR   ref    V04 tmp3         d:1 $181
N003 ( 16, 16) [000019] --C---------              \--*  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST $181
N002 (  2, 10) [000018] H----------- arg0 in rcx     \--*  CNS_INT(h) long   0xd1ffab1e token $101

***** BB01
STMT00013 (IL   ???...  ???)
N013 ( 26, 35) [000039] -ACXGO--R---              *  ASG       ref    $VN.Void
N012 (  4,  4) [000038] n---GO-N----              +--*  IND       ref    $2c0
N011 (  2,  2) [000140] -------N----              |  \--*  ADD       byref  $300
N009 (  1,  1) [000035] ------------              |     +--*  LCL_VAR   ref    V04 tmp3         u:1 $181
N010 (  1,  1) [000139] ------------              |     \--*  CNS_INT   long   8 field offset Fseq[_array] $201
N008 ( 21, 30) [000047] --CXG-------              \--*  COMMA     ref    <l:$184, c:$183>
N005 ( 17, 18) [000046] H-CXG-------                 +--*  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS $281
N003 (  2, 10) [000044] ------------ arg0 in rcx     |  +--*  CNS_INT   long   0x7ffa40fb0028 $200
N004 (  1,  1) [000045] ------------ arg1 in rdx     |  \--*  CNS_INT   int    6 $42
N007 (  4, 12) [000042] n---G-------                 \--*  IND       ref    <l:$2c0, c:$144>
N006 (  2, 10) [000143] I-----------                    \--*  CNS_INT(h) long   0xd1ffab1e static Fseq[Value] $102

***** BB01
STMT00008 (IL   ???...  ???)
N006 (  6,  6) [000026] -A--GO------              *  ASG       ref    $VN.Void
N004 (  4,  4) [000025] n---GO-N----              +--*  IND       ref    $181
N003 (  2,  2) [000145] -------N----              |  \--*  ADD       byref  $301
N001 (  1,  1) [000005] ------------              |     +--*  LCL_VAR   ref    V02 tmp1         u:1 $180
N002 (  1,  1) [000144] ------------              |     \--*  CNS_INT   long   16 field offset Fseq[_tokensBuffer] $202
N005 (  1,  1) [000024] ------------              \--*  LCL_VAR   ref    V04 tmp3         u:1 (last use) $181

***** BB01
STMT00010 (IL   ???...  ???)
N006 (  6,  6) [000032] -A--GO------              *  ASG       ref    $VN.Void
N004 (  4,  4) [000031] n---GO-N----              +--*  IND       ref    $VN.Null
N003 (  2,  2) [000147] -------N----              |  \--*  ADD       byref  $302
N001 (  1,  1) [000029] ------------              |     +--*  LCL_VAR   ref    V02 tmp1         u:1 $180
N002 (  1,  1) [000146] ------------              |     \--*  CNS_INT   long   8 field offset Fseq[_reader] $201
N005 (  1,  1) [000030] ------------              \--*  CNS_INT   ref    null $VN.Null

***** BB01
STMT00014 (IL 0x006...  ???)
N004 (  5,  5) [000052] ------------              *  JTRUE     void  
N003 (  3,  3) [000051] J------N----              \--*  NE        int    $340
N001 (  1,  1) [000008] ------------                 +--*  LCL_VAR   ref    V00 arg0         u:1 $80
N002 (  1,  1) [000050] ------------                 \--*  CNS_INT   ref    null $VN.Null

------------ BB02 [006..007) -> BB06 (always), preds={BB01} succs={BB06}

***** BB02
STMT00019 (IL 0x006...  ???)
N007 ( 10,  8) [000154] -A----------              *  COMMA     void   $40
N003 (  5,  4) [000150] -A------R---              +--*  ASG       byref  $VN.Null
N002 (  3,  2) [000148] D------N----              |  +--*  LCL_VAR   byref  V21 tmp20        d:1 $VN.Null
N001 (  1,  1) [000149] ------------              |  \--*  CNS_INT   byref  0 $VN.Null
N006 (  5,  4) [000153] -A------R---              \--*  ASG       int    $40
N005 (  3,  2) [000151] D------N----                 +--*  LCL_VAR   int    V22 tmp21        d:1 $40
N004 (  1,  1) [000152] ------------                 \--*  CNS_INT   int    0 $40

***** BB02
STMT00020 (IL 0x006...  ???)
N007 ( 12,  9) [000161] -A----------              *  COMMA     void   $40
N003 (  7,  5) [000157] -A------R---              +--*  ASG       byref  $VN.Null
N002 (  3,  2) [000155] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        d:3 $VN.Null
N001 (  3,  2) [000156] ------------              |  \--*  LCL_VAR   byref  V21 tmp20        u:1 (last use) $VN.Null
N006 (  5,  4) [000160] -A------R---              \--*  ASG       int    $40
N005 (  3,  2) [000158] D------N----                 +--*  LCL_VAR   int    V18 tmp17        d:3 $40
N004 (  1,  1) [000233] ------------                 \--*  CNS_INT   int    0 $40

------------ BB03 [006..007) -> BB05 (cond), preds={BB01} succs={BB04,BB05}

***** BB03
STMT00016 (IL 0x006...  ???)
N003 (  0,  0) [000168] ------------              *  COMMA     void   $381
N001 (  0,  0) [000164] ------------              +--*  NOP       void   $380
N002 (  0,  0) [000167] ------------              \--*  NOP       void   $381

***** BB03
STMT00026 (IL 0x006...  ???)
N005 (  7,  6) [000112] -A--G---R---              *  ASG       byref  $303
N004 (  3,  2) [000111] D------N----              +--*  LCL_VAR   byref  V09 tmp8         d:1 $303
N003 (  3,  3) [000173] ------------              \--*  ADD       byref  $303
N001 (  1,  1) [000171] ------------                 +--*  LCL_VAR   ref    V00 arg0         u:1 $80
N002 (  1,  1) [000172] ------------                 \--*  CNS_INT   long   12 field offset Fseq[_firstChar] $203

***** BB03
STMT00027 (IL 0x006...  ???)
N004 (  3,  3) [000114] -A-X----R---              *  ASG       int    $341
N003 (  1,  1) [000113] D------N----              +--*  LCL_VAR   int    V08 tmp7         d:1 $400
N002 (  3,  3) [000057] ---X--------              \--*  ARR_LENGTH int    $341
N001 (  1,  1) [000056] ------------                 \--*  LCL_VAR   ref    V00 arg0         u:1 (last use) $80

***** BB03
STMT00031 (IL 0x006...  ???)
N008 ( 15, 20) [000133] -A--G---R---              *  ASG       ref    $18c
N007 (  3,  2) [000132] D------N----              +--*  LCL_VAR   ref    V13 tmp12        d:1 $18c
N006 ( 11, 17) [000231] -A--G-------              \--*  COMMA     ref    $18c
N004 (  8, 15) [000229] -A--G---R---                 +--*  ASG       ref    $VN.Void
N003 (  3,  2) [000228] D------N----                 |  +--*  LCL_VAR   ref    V27 cse0         d:1 $18c
N002 (  4, 12) [000119] #---G-------                 |  \--*  IND       ref    $18c
N001 (  2, 10) [000118] H-----------                 |     \--*  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL] $106
N005 (  3,  2) [000230] ------------                 \--*  LCL_VAR   ref    V27 cse0         u:1 $18c

***** BB03
STMT00032 (IL 0x006...  ???)
N003 (  7,  5) [000135] -A--G---R---              *  ASG       ref    $18c
N002 (  3,  2) [000134] D------N----              +--*  LCL_VAR   ref    V14 tmp13        d:1 $18c
N001 (  3,  2) [000232] ------------              \--*  LCL_VAR   ref    V27 cse0         u:1 $18c

***** BB03
STMT00029 (IL 0x006...  ???)
N004 (  5,  5) [000128] ------------              *  JTRUE     void  
N003 (  3,  3) [000090] J------N----              \--*  GE        int    $342
N001 (  1,  1) [000088] ------------                 +--*  LCL_VAR   int    V08 tmp7         u:1 $400
N002 (  1,  1) [000089] ------------                 \--*  CNS_INT   int    0 $40

------------ BB04 [006..007), preds={BB03} succs={BB05}

***** BB04
STMT00030 (IL 0x006...  ???)
N005 ( 20, 11) [000131] --CXG-------              *  CALL      void   System.Diagnostics.Debug.Fail $VN.Void
N003 (  3,  2) [000129] ------------ arg0 in rcx  +--*  LCL_VAR   ref    V14 tmp13        u:1 (last use) $18c
N004 (  3,  2) [000130] ------------ arg1 in rdx  \--*  LCL_VAR   ref    V14 tmp13        u:1 (last use) $18c

------------ BB05 [006..007), preds={BB03,BB04} succs={BB06}

***** BB05
STMT00023 (IL 0x006...  ???)
N003 (  7,  5) [000100] -A------R---              *  ASG       byref  $303
N002 (  3,  2) [000099] D------N----              +--*  LCL_VAR   byref  V23 tmp22        d:1 $303
N001 (  3,  2) [000096] ------------              \--*  LCL_VAR   byref  V09 tmp8         u:1 (last use) $303

***** BB05
STMT00024 (IL 0x006...  ???)
N003 (  7,  5) [000179] -A------R---              *  ASG       byref  $303
N002 (  3,  2) [000177] D------N----              +--*  LCL_VAR   byref  V19 tmp18        d:1 $303
N001 (  3,  2) [000178] -------N----              \--*  LCL_VAR   byref  V23 tmp22        u:1 (last use) $303

***** BB05
STMT00025 (IL 0x006...  ???)
N003 (  5,  4) [000110] -A------R---              *  ASG       int    $400
N002 (  3,  2) [000109] D------N----              +--*  LCL_VAR   int    V20 tmp19        d:1 $400
N001 (  1,  1) [000108] ------------              \--*  LCL_VAR   int    V08 tmp7         u:1 (last use) $400

***** BB05
STMT00018 (IL 0x006...  ???)
N007 ( 14, 10) [000186] -A----------              *  COMMA     void   $400
N003 (  7,  5) [000182] -A------R---              +--*  ASG       byref  $303
N002 (  3,  2) [000180] D------N----              |  +--*  LCL_VAR   byref  V17 tmp16        d:2 $303
N001 (  3,  2) [000181] ------------              |  \--*  LCL_VAR   byref  V19 tmp18        u:1 (last use) $303
N006 (  7,  5) [000185] -A------R---              \--*  ASG       int    $400
N005 (  3,  2) [000183] D------N----                 +--*  LCL_VAR   int    V18 tmp17        d:2 $400
N004 (  3,  2) [000184] ------------                 \--*  LCL_VAR   int    V20 tmp19        u:1 (last use) $400

------------ BB06 [???..???) (return), preds={BB02,BB05} succs={}

***** BB06
STMT00034 (IL   ???...  ???)
N005 (  0,  0) [000223] -A------R---              *  ASG       int   
N004 (  0,  0) [000221] D------N----              +--*  LCL_VAR   int    V18 tmp17        d:1
N003 (  0,  0) [000222] ------------              \--*  PHI       int   
N001 (  0,  0) [000226] ------------ pred BB02       +--*  PHI_ARG   int    V18 tmp17        u:3 $40
N002 (  0,  0) [000224] ------------ pred BB05       \--*  PHI_ARG   int    V18 tmp17        u:2 $400

***** BB06
STMT00033 (IL   ???...  ???)
N005 (  0,  0) [000220] -A------R---              *  ASG       byref 
N004 (  0,  0) [000218] D------N----              +--*  LCL_VAR   byref  V17 tmp16        d:1
N003 (  0,  0) [000219] ------------              \--*  PHI       byref 
N001 (  0,  0) [000227] ------------ pred BB02       +--*  PHI_ARG   byref  V17 tmp16        u:3 $VN.Null
N002 (  0,  0) [000225] ------------ pred BB05       \--*  PHI_ARG   byref  V17 tmp16        u:2 $303

***** BB06
STMT00003 (IL   ???...  ???)
N007 ( 14, 10) [000193] -A----------              *  COMMA     void   $440
N003 (  7,  5) [000189] -A------R---              +--*  ASG       byref  $480
N002 (  3,  2) [000187] D------N----              |  +--*  LCL_VAR   byref  V15 tmp14        d:1 $480
N001 (  3,  2) [000188] ------------              |  \--*  LCL_VAR   byref  V17 tmp16        u:1 (last use) $480
N006 (  7,  5) [000192] -A------R---              \--*  ASG       int    $440
N005 (  3,  2) [000190] D------N----                 +--*  LCL_VAR   int    V16 tmp15        d:1 $440
N004 (  3,  2) [000191] ------------                 \--*  LCL_VAR   int    V18 tmp17        u:1 (last use) $440

***** BB06
STMT00004 (IL   ???...  ???)
N023 ( 40, 30) [000011] -ACXG-------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer.TokenizeLine $VN.Void
N003 (  1,  3) [000214] -A------R-L- this SETUP   +--*  ASG       ref    $180
N002 (  1,  1) [000213] D------N----              |  +--*  LCL_VAR   ref    V26 tmp25        d:1 $180
N001 (  1,  1) [000007] ------------              |  \--*  LCL_VAR   ref    V02 tmp1         u:1 (last use) $180
N019 ( 18, 15) [000212] -A--------L- arg1 SETUP   +--*  COMMA     void   $VN.Void
N012 ( 10,  8) [000205] -A----------              |  +--*  COMMA     void   $VN.Void
N007 (  3,  3) [000200] -A------R---              |  |  +--*  ASG       byref  $3c7
N006 (  1,  1) [000199] D------N----              |  |  |  +--*  LCL_VAR   byref  V25 tmp24        d:1 $3c7
N005 (  3,  3) [000197] ------------              |  |  |  \--*  ADDR      byref  $3c7
N004 (  3,  2) [000198] -------N----              |  |  |     \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(AX) V24 tmp23         $4c0
N011 (  7,  5) [000204] -A----------              |  |  \--*  ASG       byref  $VN.Void
N009 (  3,  2) [000202] *------N----              |  |     +--*  IND       byref  $480
N008 (  1,  1) [000201] ------------              |  |     |  \--*  LCL_VAR   byref  V25 tmp24        u:1 Zero Fseq[_pointer] $3c7
N010 (  3,  2) [000203] -------N----              |  |     \--*  LCL_VAR   byref  V15 tmp14        u:1 (last use) $480
N018 (  8,  7) [000211] -A----------              |  \--*  ASG       int    $VN.Void
N016 (  4,  4) [000209] *------N----              |     +--*  IND       int    $440
N015 (  2,  2) [000208] -------N----              |     |  \--*  ADD       byref  $305
N013 (  1,  1) [000206] ------------              |     |     +--*  LCL_VAR   byref  V25 tmp24        u:1 (last use) $3c7
N014 (  1,  1) [000207] ------------              |     |     \--*  CNS_INT   long   8 Fseq[_length] $201
N017 (  3,  2) [000210] -------N----              |     \--*  LCL_VAR   int    V16 tmp15        u:1 (last use) $440
N020 (  1,  1) [000215] ------------ this in rcx  +--*  LCL_VAR   ref    V26 tmp25        u:1 (last use) $180
N022 (  3,  3) [000217] ------------ arg1 in rdx  \--*  ADDR      byref  $3c9
N021 (  3,  2) [000216] -------N----                 \--*  LCL_VAR   struct<System.ReadOnlySpan`1[Char], 16>(AX) V24 tmp23         $4c1

***** BB06
STMT00005 (IL 0x011...  ???)
N001 (  0,  0) [000017] ------------              *  RETURN    void   $382

-------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Rationalize IR
rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N005 ( 16, 16) [000004] DAC---------              *  STORE_LCL_VAR ref    V02 tmp1         d:1

rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N005 ( 16, 16) [000021] DAC---------              *  STORE_LCL_VAR ref    V04 tmp3         d:1

rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N003 (  5,  4) [000150] DA----------              *  STORE_LCL_VAR byref  V21 tmp20        d:1

rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N006 (  5,  4) [000153] DA----------              *  STORE_LCL_VAR int    V22 tmp21        d:1

rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N003 (  7,  5) [000157] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:3

rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N006 (  5,  4) [000160] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:3

rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N005 (  7,  6) [000112] DA--G-------              *  STORE_LCL_VAR byref  V09 tmp8         d:1

rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N004 (  3,  3) [000114] DA-X--------              *  STORE_LCL_VAR int    V08 tmp7         d:1

rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N004 (  8, 15) [000229] DA--G-------              *  STORE_LCL_VAR ref    V27 cse0         d:1

rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N008 ( 15, 20) [000133] DA--G-------              *  STORE_LCL_VAR ref    V13 tmp12        d:1

rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N003 (  7,  5) [000135] DA--G-------              *  STORE_LCL_VAR ref    V14 tmp13        d:1

rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N003 (  7,  5) [000100] DA----------              *  STORE_LCL_VAR byref  V23 tmp22        d:1

rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N003 (  7,  5) [000179] DA----------              *  STORE_LCL_VAR byref  V19 tmp18        d:1

rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N003 (  5,  4) [000110] DA----------              *  STORE_LCL_VAR int    V20 tmp19        d:1

rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N003 (  7,  5) [000182] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:2

rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N006 (  7,  5) [000185] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:2

rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N005 (  0,  0) [000223] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:1

rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N005 (  0,  0) [000220] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:1

rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N003 (  7,  5) [000189] DA----------              *  STORE_LCL_VAR byref  V15 tmp14        d:1

rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N006 (  7,  5) [000192] DA----------              *  STORE_LCL_VAR int    V16 tmp15        d:1

rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N003 (  1,  3) [000214] DA--------L-              *  STORE_LCL_VAR ref    V26 tmp25        d:1

Rewriting GT_ADDR(GT_LCL_VAR) to GT_LCL_VAR_ADDR:
N004 (  3,  2) [000198] -------N----       t198 =    LCL_VAR_ADDR byref  V24 tmp23        

rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N007 (  3,  3) [000200] DA----------              *  STORE_LCL_VAR byref  V25 tmp24        d:1

Rewriting GT_ADDR(GT_LCL_VAR) to GT_LCL_VAR_ADDR:
N021 (  3,  2) [000216] -------N----       t216 =    LCL_VAR_ADDR byref  V24 tmp23        


*************** Finishing PHASE Rationalize IR
Trees after Rationalize IR

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)-> BB03 ( cond )                     i label target hascall newobj LIR 
BB02 [0007]  1       BB01                  0.50     [006..007)-> BB06 (always)                     i LIR 
BB03 [0008]  1       BB01                  0.50     [006..007)-> BB05 ( cond )                     i label target idxlen nullcheck LIR 
BB04 [0014]  1       BB03                  0.25     [006..007)                                     i hascall gcsafe LIR 
BB05 [0015]  2       BB03,BB04             0.50     [006..007)                                     i label target idxlen nullcheck LIR 
BB06 [0009]  2       BB02,BB05             1        [???..???)        (return)                     internal label target hascall gcsafe newobj LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..012) -> BB03 (cond), preds={} succs={BB02,BB03}
               [000234] ------------                 IL_OFFSET void   IL offset: 0x0
N002 (  2, 10) [000001] H-----------         t1 =    CNS_INT(h) long   0xd1ffab1e token $100
                                                  /--*  t1     long   arg0 in rcx
N003 ( 16, 16) [000002] --C---------         t2 = *  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST $180
                                                  /--*  t2     ref    
N005 ( 16, 16) [000004] DA----------              *  STORE_LCL_VAR ref    V02 tmp1         d:1
N002 (  2, 10) [000018] H-----------        t18 =    CNS_INT(h) long   0xd1ffab1e token $101
                                                  /--*  t18    long   arg0 in rcx
N003 ( 16, 16) [000019] --C---------        t19 = *  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST $181
                                                  /--*  t19    ref    
N005 ( 16, 16) [000021] DA----------              *  STORE_LCL_VAR ref    V04 tmp3         d:1
N003 (  2, 10) [000044] ------------        t44 =    CNS_INT   long   0x7ffa40fb0028 $200
N004 (  1,  1) [000045] ------------        t45 =    CNS_INT   int    6 $42
                                                  /--*  t44    long   arg0 in rcx
                                                  +--*  t45    int    arg1 in rdx
N005 ( 17, 18) [000046] H-CXG-------        t46 = *  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS $281
N006 (  2, 10) [000143] I-----------       t143 =    CNS_INT(h) long   0xd1ffab1e static Fseq[Value] $102
                                                  /--*  t143   long   
N007 (  4, 12) [000042] n---G-------        t42 = *  IND       ref    <l:$2c0, c:$144>
N009 (  1,  1) [000035] ------------        t35 =    LCL_VAR   ref    V04 tmp3         u:1 $181
N010 (  1,  1) [000139] ------------       t139 =    CNS_INT   long   8 field offset Fseq[_array] $201
                                                  /--*  t35    ref    
                                                  +--*  t139   long   
N011 (  2,  2) [000140] -------N----       t140 = *  ADD       byref  $300
                                                  /--*  t140   byref  
                                                  +--*  t42    ref    
               [000235] -ACXGO------              *  STOREIND  ref   
N001 (  1,  1) [000005] ------------         t5 =    LCL_VAR   ref    V02 tmp1         u:1 $180
N002 (  1,  1) [000144] ------------       t144 =    CNS_INT   long   16 field offset Fseq[_tokensBuffer] $202
                                                  /--*  t5     ref    
                                                  +--*  t144   long   
N003 (  2,  2) [000145] -------N----       t145 = *  ADD       byref  $301
N005 (  1,  1) [000024] ------------        t24 =    LCL_VAR   ref    V04 tmp3         u:1 (last use) $181
                                                  /--*  t145   byref  
                                                  +--*  t24    ref    
               [000236] -A--GO------              *  STOREIND  ref   
N001 (  1,  1) [000029] ------------        t29 =    LCL_VAR   ref    V02 tmp1         u:1 $180
N002 (  1,  1) [000146] ------------       t146 =    CNS_INT   long   8 field offset Fseq[_reader] $201
                                                  /--*  t29    ref    
                                                  +--*  t146   long   
N003 (  2,  2) [000147] -------N----       t147 = *  ADD       byref  $302
N005 (  1,  1) [000030] ------------        t30 =    CNS_INT   ref    null $VN.Null
                                                  /--*  t147   byref  
                                                  +--*  t30    ref    
               [000237] -A--GO------              *  STOREIND  ref   
               [000238] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  1,  1) [000008] ------------         t8 =    LCL_VAR   ref    V00 arg0         u:1 $80
N002 (  1,  1) [000050] ------------        t50 =    CNS_INT   ref    null $VN.Null
                                                  /--*  t8     ref    
                                                  +--*  t50    ref    
N003 (  3,  3) [000051] J------N----        t51 = *  NE        int    $340
                                                  /--*  t51    int    
N004 (  5,  5) [000052] ------------              *  JTRUE     void  

------------ BB02 [006..007) -> BB06 (always), preds={BB01} succs={BB06}
               [000239] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  1,  1) [000149] ------------       t149 =    CNS_INT   byref  0 $VN.Null
                                                  /--*  t149   byref  
N003 (  5,  4) [000150] DA----------              *  STORE_LCL_VAR byref  V21 tmp20        d:1
N004 (  1,  1) [000152] ------------       t152 =    CNS_INT   int    0 $40
                                                  /--*  t152   int    
N006 (  5,  4) [000153] DA----------              *  STORE_LCL_VAR int    V22 tmp21        d:1
               [000240] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  3,  2) [000156] ------------       t156 =    LCL_VAR   byref  V21 tmp20        u:1 (last use) $VN.Null
                                                  /--*  t156   byref  
N003 (  7,  5) [000157] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:3
N004 (  1,  1) [000233] ------------       t233 =    CNS_INT   int    0 $40
                                                  /--*  t233   int    
N006 (  5,  4) [000160] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:3

------------ BB03 [006..007) -> BB05 (cond), preds={BB01} succs={BB04,BB05}
               [000241] ------------                 IL_OFFSET void   IL offset: 0x6
               [000242] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  1,  1) [000171] ------------       t171 =    LCL_VAR   ref    V00 arg0         u:1 $80
N002 (  1,  1) [000172] ------------       t172 =    CNS_INT   long   12 field offset Fseq[_firstChar] $203
                                                  /--*  t171   ref    
                                                  +--*  t172   long   
N003 (  3,  3) [000173] ------------       t173 = *  ADD       byref  $303
                                                  /--*  t173   byref  
N005 (  7,  6) [000112] DA--G-------              *  STORE_LCL_VAR byref  V09 tmp8         d:1
               [000243] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  1,  1) [000056] ------------        t56 =    LCL_VAR   ref    V00 arg0         u:1 (last use) $80
                                                  /--*  t56    ref    
N002 (  3,  3) [000057] ---X--------        t57 = *  ARR_LENGTH int    $341
                                                  /--*  t57    int    
N004 (  3,  3) [000114] DA-X--------              *  STORE_LCL_VAR int    V08 tmp7         d:1
               [000244] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  2, 10) [000118] H-----------       t118 =    CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL] $106
                                                  /--*  t118   long   
N002 (  4, 12) [000119] #---G-------       t119 = *  IND       ref    $18c
                                                  /--*  t119   ref    
N004 (  8, 15) [000229] DA--G-------              *  STORE_LCL_VAR ref    V27 cse0         d:1
N005 (  3,  2) [000230] ------------       t230 =    LCL_VAR   ref    V27 cse0         u:1 $18c
                                                  /--*  t230   ref    
N008 ( 15, 20) [000133] DA--G-------              *  STORE_LCL_VAR ref    V13 tmp12        d:1
               [000245] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  3,  2) [000232] ------------       t232 =    LCL_VAR   ref    V27 cse0         u:1 $18c
                                                  /--*  t232   ref    
N003 (  7,  5) [000135] DA--G-------              *  STORE_LCL_VAR ref    V14 tmp13        d:1
               [000246] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  1,  1) [000088] ------------        t88 =    LCL_VAR   int    V08 tmp7         u:1 $400
N002 (  1,  1) [000089] ------------        t89 =    CNS_INT   int    0 $40
                                                  /--*  t88    int    
                                                  +--*  t89    int    
N003 (  3,  3) [000090] J------N----        t90 = *  GE        int    $342
                                                  /--*  t90    int    
N004 (  5,  5) [000128] ------------              *  JTRUE     void  

------------ BB04 [006..007), preds={BB03} succs={BB05}
               [000247] ------------                 IL_OFFSET void   IL offset: 0x6
N003 (  3,  2) [000129] ------------       t129 =    LCL_VAR   ref    V14 tmp13        u:1 (last use) $18c
N004 (  3,  2) [000130] ------------       t130 =    LCL_VAR   ref    V14 tmp13        u:1 (last use) $18c
                                                  /--*  t129   ref    arg0 in rcx
                                                  +--*  t130   ref    arg1 in rdx
N005 ( 20, 11) [000131] --CXG-------              *  CALL      void   System.Diagnostics.Debug.Fail $VN.Void

------------ BB05 [006..007), preds={BB03,BB04} succs={BB06}
               [000248] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  3,  2) [000096] ------------        t96 =    LCL_VAR   byref  V09 tmp8         u:1 (last use) $303
                                                  /--*  t96    byref  
N003 (  7,  5) [000100] DA----------              *  STORE_LCL_VAR byref  V23 tmp22        d:1
               [000249] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  3,  2) [000178] -------N----       t178 =    LCL_VAR   byref  V23 tmp22        u:1 (last use) $303
                                                  /--*  t178   byref  
N003 (  7,  5) [000179] DA----------              *  STORE_LCL_VAR byref  V19 tmp18        d:1
               [000250] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  1,  1) [000108] ------------       t108 =    LCL_VAR   int    V08 tmp7         u:1 (last use) $400
                                                  /--*  t108   int    
N003 (  5,  4) [000110] DA----------              *  STORE_LCL_VAR int    V20 tmp19        d:1
               [000251] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  3,  2) [000181] ------------       t181 =    LCL_VAR   byref  V19 tmp18        u:1 (last use) $303
                                                  /--*  t181   byref  
N003 (  7,  5) [000182] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:2
N004 (  3,  2) [000184] ------------       t184 =    LCL_VAR   int    V20 tmp19        u:1 (last use) $400
                                                  /--*  t184   int    
N006 (  7,  5) [000185] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:2

------------ BB06 [???..???) (return), preds={BB02,BB05} succs={}
N001 (  0,  0) [000226] ------------       t226 =    PHI_ARG   int    V18 tmp17        u:3 $40
N002 (  0,  0) [000224] ------------       t224 =    PHI_ARG   int    V18 tmp17        u:2 $400
                                                  /--*  t226   int    
                                                  +--*  t224   int    
N003 (  0,  0) [000222] ------------       t222 = *  PHI       int   
                                                  /--*  t222   int    
N005 (  0,  0) [000223] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:1
N001 (  0,  0) [000227] ------------       t227 =    PHI_ARG   byref  V17 tmp16        u:3 $VN.Null
N002 (  0,  0) [000225] ------------       t225 =    PHI_ARG   byref  V17 tmp16        u:2 $303
                                                  /--*  t227   byref  
                                                  +--*  t225   byref  
N003 (  0,  0) [000219] ------------       t219 = *  PHI       byref 
                                                  /--*  t219   byref  
N005 (  0,  0) [000220] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:1
N001 (  3,  2) [000188] ------------       t188 =    LCL_VAR   byref  V17 tmp16        u:1 (last use) $480
                                                  /--*  t188   byref  
N003 (  7,  5) [000189] DA----------              *  STORE_LCL_VAR byref  V15 tmp14        d:1
N004 (  3,  2) [000191] ------------       t191 =    LCL_VAR   int    V18 tmp17        u:1 (last use) $440
                                                  /--*  t191   int    
N006 (  7,  5) [000192] DA----------              *  STORE_LCL_VAR int    V16 tmp15        d:1
N001 (  1,  1) [000007] ------------         t7 =    LCL_VAR   ref    V02 tmp1         u:1 (last use) $180
                                                  /--*  t7     ref    
N003 (  1,  3) [000214] DA--------L-              *  STORE_LCL_VAR ref    V26 tmp25        d:1
N004 (  3,  2) [000198] -------N----       t198 =    LCL_VAR_ADDR byref  V24 tmp23        
                                                  /--*  t198   byref  
N007 (  3,  3) [000200] DA----------              *  STORE_LCL_VAR byref  V25 tmp24        d:1
N008 (  1,  1) [000201] ------------       t201 =    LCL_VAR   byref  V25 tmp24        u:1 Zero Fseq[_pointer] $3c7
N010 (  3,  2) [000203] -------N----       t203 =    LCL_VAR   byref  V15 tmp14        u:1 (last use) $480
                                                  /--*  t201   byref  
                                                  +--*  t203   byref  
               [000252] -A----------              *  STOREIND  byref 
N013 (  1,  1) [000206] ------------       t206 =    LCL_VAR   byref  V25 tmp24        u:1 (last use) $3c7
N014 (  1,  1) [000207] ------------       t207 =    CNS_INT   long   8 Fseq[_length] $201
                                                  /--*  t206   byref  
                                                  +--*  t207   long   
N015 (  2,  2) [000208] -------N----       t208 = *  ADD       byref  $305
N017 (  3,  2) [000210] -------N----       t210 =    LCL_VAR   int    V16 tmp15        u:1 (last use) $440
                                                  /--*  t208   byref  
                                                  +--*  t210   int    
               [000253] -A--------L-              *  STOREIND  int   
N020 (  1,  1) [000215] ------------       t215 =    LCL_VAR   ref    V26 tmp25        u:1 (last use) $180
N021 (  3,  2) [000216] -------N----       t216 =    LCL_VAR_ADDR byref  V24 tmp23        
                                                  /--*  t215   ref    this in rcx
                                                  +--*  t216   byref  arg1 in rdx
N023 ( 40, 30) [000011] --CXG-------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer.TokenizeLine $VN.Void
               [000254] ------------                 IL_OFFSET void   IL offset: 0x11
N001 (  0,  0) [000017] ------------                 RETURN    void   $382

-------------------------------------------------------------------------------------------------------------------
*************** In fgDebugCheckBBlist

*************** Starting PHASE Do 'simple' lowering
Bumping outgoingArgSpaceSize to 32 for call [000002]
outgoingArgSpaceSize 32 sufficient for call [000019], which needs 32
outgoingArgSpaceSize 32 sufficient for call [000046], which needs 32
outgoingArgSpaceSize 32 sufficient for call [000131], which needs 32
outgoingArgSpaceSize 32 sufficient for call [000011], which needs 32

*************** Finishing PHASE Do 'simple' lowering
*************** In fgDebugCheckBBlist
Trees before Lowering nodeinfo

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)-> BB03 ( cond )                     i label target hascall newobj LIR 
BB02 [0007]  1       BB01                  0.50     [006..007)-> BB06 (always)                     i LIR 
BB03 [0008]  1       BB01                  0.50     [006..007)-> BB05 ( cond )                     i label target idxlen nullcheck LIR 
BB04 [0014]  1       BB03                  0.25     [006..007)                                     i hascall gcsafe LIR 
BB05 [0015]  2       BB03,BB04             0.50     [006..007)                                     i label target idxlen nullcheck LIR 
BB06 [0009]  2       BB02,BB05             1        [???..???)        (return)                     internal label target hascall gcsafe newobj LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..012) -> BB03 (cond), preds={} succs={BB02,BB03}
               [000234] ------------                 IL_OFFSET void   IL offset: 0x0
N002 (  2, 10) [000001] H-----------         t1 =    CNS_INT(h) long   0xd1ffab1e token $100
                                                  /--*  t1     long   arg0 in rcx
N003 ( 16, 16) [000002] --C---------         t2 = *  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST $180
                                                  /--*  t2     ref    
N005 ( 16, 16) [000004] DA----------              *  STORE_LCL_VAR ref    V02 tmp1         d:1
N002 (  2, 10) [000018] H-----------        t18 =    CNS_INT(h) long   0xd1ffab1e token $101
                                                  /--*  t18    long   arg0 in rcx
N003 ( 16, 16) [000019] --C---------        t19 = *  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST $181
                                                  /--*  t19    ref    
N005 ( 16, 16) [000021] DA----------              *  STORE_LCL_VAR ref    V04 tmp3         d:1
N003 (  2, 10) [000044] ------------        t44 =    CNS_INT   long   0x7ffa40fb0028 $200
N004 (  1,  1) [000045] ------------        t45 =    CNS_INT   int    6 $42
                                                  /--*  t44    long   arg0 in rcx
                                                  +--*  t45    int    arg1 in rdx
N005 ( 17, 18) [000046] H-CXG-------        t46 = *  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS $281
N006 (  2, 10) [000143] I-----------       t143 =    CNS_INT(h) long   0xd1ffab1e static Fseq[Value] $102
                                                  /--*  t143   long   
N007 (  4, 12) [000042] n---G-------        t42 = *  IND       ref    <l:$2c0, c:$144>
N009 (  1,  1) [000035] ------------        t35 =    LCL_VAR   ref    V04 tmp3         u:1 $181
N010 (  1,  1) [000139] ------------       t139 =    CNS_INT   long   8 field offset Fseq[_array] $201
                                                  /--*  t35    ref    
                                                  +--*  t139   long   
N011 (  2,  2) [000140] -------N----       t140 = *  ADD       byref  $300
                                                  /--*  t140   byref  
                                                  +--*  t42    ref    
               [000235] -ACXGO------              *  STOREIND  ref   
N001 (  1,  1) [000005] ------------         t5 =    LCL_VAR   ref    V02 tmp1         u:1 $180
N002 (  1,  1) [000144] ------------       t144 =    CNS_INT   long   16 field offset Fseq[_tokensBuffer] $202
                                                  /--*  t5     ref    
                                                  +--*  t144   long   
N003 (  2,  2) [000145] -------N----       t145 = *  ADD       byref  $301
N005 (  1,  1) [000024] ------------        t24 =    LCL_VAR   ref    V04 tmp3         u:1 (last use) $181
                                                  /--*  t145   byref  
                                                  +--*  t24    ref    
               [000236] -A--GO------              *  STOREIND  ref   
N001 (  1,  1) [000029] ------------        t29 =    LCL_VAR   ref    V02 tmp1         u:1 $180
N002 (  1,  1) [000146] ------------       t146 =    CNS_INT   long   8 field offset Fseq[_reader] $201
                                                  /--*  t29    ref    
                                                  +--*  t146   long   
N003 (  2,  2) [000147] -------N----       t147 = *  ADD       byref  $302
N005 (  1,  1) [000030] ------------        t30 =    CNS_INT   ref    null $VN.Null
                                                  /--*  t147   byref  
                                                  +--*  t30    ref    
               [000237] -A--GO------              *  STOREIND  ref   
               [000238] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  1,  1) [000008] ------------         t8 =    LCL_VAR   ref    V00 arg0         u:1 $80
N002 (  1,  1) [000050] ------------        t50 =    CNS_INT   ref    null $VN.Null
                                                  /--*  t8     ref    
                                                  +--*  t50    ref    
N003 (  3,  3) [000051] J------N----        t51 = *  NE        int    $340
                                                  /--*  t51    int    
N004 (  5,  5) [000052] ------------              *  JTRUE     void  

------------ BB02 [006..007) -> BB06 (always), preds={BB01} succs={BB06}
               [000239] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  1,  1) [000149] ------------       t149 =    CNS_INT   byref  0 $VN.Null
                                                  /--*  t149   byref  
N003 (  5,  4) [000150] DA----------              *  STORE_LCL_VAR byref  V21 tmp20        d:1
N004 (  1,  1) [000152] ------------       t152 =    CNS_INT   int    0 $40
                                                  /--*  t152   int    
N006 (  5,  4) [000153] DA----------              *  STORE_LCL_VAR int    V22 tmp21        d:1
               [000240] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  3,  2) [000156] ------------       t156 =    LCL_VAR   byref  V21 tmp20        u:1 (last use) $VN.Null
                                                  /--*  t156   byref  
N003 (  7,  5) [000157] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:3
N004 (  1,  1) [000233] ------------       t233 =    CNS_INT   int    0 $40
                                                  /--*  t233   int    
N006 (  5,  4) [000160] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:3

------------ BB03 [006..007) -> BB05 (cond), preds={BB01} succs={BB04,BB05}
               [000241] ------------                 IL_OFFSET void   IL offset: 0x6
               [000242] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  1,  1) [000171] ------------       t171 =    LCL_VAR   ref    V00 arg0         u:1 $80
N002 (  1,  1) [000172] ------------       t172 =    CNS_INT   long   12 field offset Fseq[_firstChar] $203
                                                  /--*  t171   ref    
                                                  +--*  t172   long   
N003 (  3,  3) [000173] ------------       t173 = *  ADD       byref  $303
                                                  /--*  t173   byref  
N005 (  7,  6) [000112] DA--G-------              *  STORE_LCL_VAR byref  V09 tmp8         d:1
               [000243] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  1,  1) [000056] ------------        t56 =    LCL_VAR   ref    V00 arg0         u:1 (last use) $80
               [000255] ------------       t255 =    CNS_INT   long   8
                                                  /--*  t56    ref    
                                                  +--*  t255   long   
               [000256] ------------       t256 = *  ADD       ref   
                                                  /--*  t256   ref    
N002 (  3,  3) [000057] ---X--------        t57 = *  IND       int    $341
                                                  /--*  t57    int    
N004 (  3,  3) [000114] DA-X--------              *  STORE_LCL_VAR int    V08 tmp7         d:1
               [000244] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  2, 10) [000118] H-----------       t118 =    CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL] $106
                                                  /--*  t118   long   
N002 (  4, 12) [000119] #---G-------       t119 = *  IND       ref    $18c
                                                  /--*  t119   ref    
N004 (  8, 15) [000229] DA--G-------              *  STORE_LCL_VAR ref    V27 cse0         d:1
N005 (  3,  2) [000230] ------------       t230 =    LCL_VAR   ref    V27 cse0         u:1 $18c
                                                  /--*  t230   ref    
N008 ( 15, 20) [000133] DA--G-------              *  STORE_LCL_VAR ref    V13 tmp12        d:1
               [000245] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  3,  2) [000232] ------------       t232 =    LCL_VAR   ref    V27 cse0         u:1 $18c
                                                  /--*  t232   ref    
N003 (  7,  5) [000135] DA--G-------              *  STORE_LCL_VAR ref    V14 tmp13        d:1
               [000246] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  1,  1) [000088] ------------        t88 =    LCL_VAR   int    V08 tmp7         u:1 $400
N002 (  1,  1) [000089] ------------        t89 =    CNS_INT   int    0 $40
                                                  /--*  t88    int    
                                                  +--*  t89    int    
N003 (  3,  3) [000090] J------N----        t90 = *  GE        int    $342
                                                  /--*  t90    int    
N004 (  5,  5) [000128] ------------              *  JTRUE     void  

------------ BB04 [006..007), preds={BB03} succs={BB05}
               [000247] ------------                 IL_OFFSET void   IL offset: 0x6
N003 (  3,  2) [000129] ------------       t129 =    LCL_VAR   ref    V14 tmp13        u:1 (last use) $18c
N004 (  3,  2) [000130] ------------       t130 =    LCL_VAR   ref    V14 tmp13        u:1 (last use) $18c
                                                  /--*  t129   ref    arg0 in rcx
                                                  +--*  t130   ref    arg1 in rdx
N005 ( 20, 11) [000131] --CXG-------              *  CALL      void   System.Diagnostics.Debug.Fail $VN.Void

------------ BB05 [006..007), preds={BB03,BB04} succs={BB06}
               [000248] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  3,  2) [000096] ------------        t96 =    LCL_VAR   byref  V09 tmp8         u:1 (last use) $303
                                                  /--*  t96    byref  
N003 (  7,  5) [000100] DA----------              *  STORE_LCL_VAR byref  V23 tmp22        d:1
               [000249] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  3,  2) [000178] -------N----       t178 =    LCL_VAR   byref  V23 tmp22        u:1 (last use) $303
                                                  /--*  t178   byref  
N003 (  7,  5) [000179] DA----------              *  STORE_LCL_VAR byref  V19 tmp18        d:1
               [000250] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  1,  1) [000108] ------------       t108 =    LCL_VAR   int    V08 tmp7         u:1 (last use) $400
                                                  /--*  t108   int    
N003 (  5,  4) [000110] DA----------              *  STORE_LCL_VAR int    V20 tmp19        d:1
               [000251] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  3,  2) [000181] ------------       t181 =    LCL_VAR   byref  V19 tmp18        u:1 (last use) $303
                                                  /--*  t181   byref  
N003 (  7,  5) [000182] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:2
N004 (  3,  2) [000184] ------------       t184 =    LCL_VAR   int    V20 tmp19        u:1 (last use) $400
                                                  /--*  t184   int    
N006 (  7,  5) [000185] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:2

------------ BB06 [???..???) (return), preds={BB02,BB05} succs={}
N001 (  0,  0) [000226] ------------       t226 =    PHI_ARG   int    V18 tmp17        u:3 $40
N002 (  0,  0) [000224] ------------       t224 =    PHI_ARG   int    V18 tmp17        u:2 $400
                                                  /--*  t226   int    
                                                  +--*  t224   int    
N003 (  0,  0) [000222] ------------       t222 = *  PHI       int   
                                                  /--*  t222   int    
N005 (  0,  0) [000223] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:1
N001 (  0,  0) [000227] ------------       t227 =    PHI_ARG   byref  V17 tmp16        u:3 $VN.Null
N002 (  0,  0) [000225] ------------       t225 =    PHI_ARG   byref  V17 tmp16        u:2 $303
                                                  /--*  t227   byref  
                                                  +--*  t225   byref  
N003 (  0,  0) [000219] ------------       t219 = *  PHI       byref 
                                                  /--*  t219   byref  
N005 (  0,  0) [000220] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:1
N001 (  3,  2) [000188] ------------       t188 =    LCL_VAR   byref  V17 tmp16        u:1 (last use) $480
                                                  /--*  t188   byref  
N003 (  7,  5) [000189] DA----------              *  STORE_LCL_VAR byref  V15 tmp14        d:1
N004 (  3,  2) [000191] ------------       t191 =    LCL_VAR   int    V18 tmp17        u:1 (last use) $440
                                                  /--*  t191   int    
N006 (  7,  5) [000192] DA----------              *  STORE_LCL_VAR int    V16 tmp15        d:1
N001 (  1,  1) [000007] ------------         t7 =    LCL_VAR   ref    V02 tmp1         u:1 (last use) $180
                                                  /--*  t7     ref    
N003 (  1,  3) [000214] DA--------L-              *  STORE_LCL_VAR ref    V26 tmp25        d:1
N004 (  3,  2) [000198] -------N----       t198 =    LCL_VAR_ADDR byref  V24 tmp23        
                                                  /--*  t198   byref  
N007 (  3,  3) [000200] DA----------              *  STORE_LCL_VAR byref  V25 tmp24        d:1
N008 (  1,  1) [000201] ------------       t201 =    LCL_VAR   byref  V25 tmp24        u:1 Zero Fseq[_pointer] $3c7
N010 (  3,  2) [000203] -------N----       t203 =    LCL_VAR   byref  V15 tmp14        u:1 (last use) $480
                                                  /--*  t201   byref  
                                                  +--*  t203   byref  
               [000252] -A----------              *  STOREIND  byref 
N013 (  1,  1) [000206] ------------       t206 =    LCL_VAR   byref  V25 tmp24        u:1 (last use) $3c7
N014 (  1,  1) [000207] ------------       t207 =    CNS_INT   long   8 Fseq[_length] $201
                                                  /--*  t206   byref  
                                                  +--*  t207   long   
N015 (  2,  2) [000208] -------N----       t208 = *  ADD       byref  $305
N017 (  3,  2) [000210] -------N----       t210 =    LCL_VAR   int    V16 tmp15        u:1 (last use) $440
                                                  /--*  t208   byref  
                                                  +--*  t210   int    
               [000253] -A--------L-              *  STOREIND  int   
N020 (  1,  1) [000215] ------------       t215 =    LCL_VAR   ref    V26 tmp25        u:1 (last use) $180
N021 (  3,  2) [000216] -------N----       t216 =    LCL_VAR_ADDR byref  V24 tmp23        
                                                  /--*  t215   ref    this in rcx
                                                  +--*  t216   byref  arg1 in rdx
N023 ( 40, 30) [000011] --CXG-------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer.TokenizeLine $VN.Void
               [000254] ------------                 IL_OFFSET void   IL offset: 0x11
N001 (  0,  0) [000017] ------------                 RETURN    void   $382

-------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Lowering nodeinfo
lowering call (before):
N002 (  2, 10) [000001] H-----------         t1 =    CNS_INT(h) long   0xd1ffab1e token $100
                                                  /--*  t1     long   arg0 in rcx
N003 ( 16, 16) [000002] --C---------         t2 = *  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST $180

objp:
======

args:
======
lowering arg : N001 (  0,  0) [000137] ----------L-              *  ARGPLACE  long   $100

late:
======
lowering arg : N002 (  2, 10) [000001] H-----------              *  CNS_INT(h) long   0xd1ffab1e token $100
new node is :                [000257] ------------              *  PUTARG_REG long   REG rcx

lowering call (after):
N002 (  2, 10) [000001] H-----------         t1 =    CNS_INT(h) long   0xd1ffab1e token $100
                                                  /--*  t1     long   
               [000257] ------------       t257 = *  PUTARG_REG long   REG rcx
                                                  /--*  t257   long   arg0 in rcx
N003 ( 16, 16) [000002] --C---------         t2 = *  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST $180

lowering store lcl var/field (before):
N002 (  2, 10) [000001] H-----------         t1 =    CNS_INT(h) long   0xd1ffab1e token $100
                                                  /--*  t1     long   
               [000257] ------------       t257 = *  PUTARG_REG long   REG rcx
                                                  /--*  t257   long   arg0 in rcx
N003 ( 16, 16) [000002] --C---------         t2 = *  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST $180
                                                  /--*  t2     ref    
N005 ( 16, 16) [000004] DA----------              *  STORE_LCL_VAR ref    V02 tmp1         d:1

lowering store lcl var/field (after):
N002 (  2, 10) [000001] H-----------         t1 =    CNS_INT(h) long   0xd1ffab1e token $100
                                                  /--*  t1     long   
               [000257] ------------       t257 = *  PUTARG_REG long   REG rcx
                                                  /--*  t257   long   arg0 in rcx
N003 ( 16, 16) [000002] --C---------         t2 = *  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST $180
                                                  /--*  t2     ref    
N005 ( 16, 16) [000004] DA----------              *  STORE_LCL_VAR ref    V02 tmp1         d:1

lowering call (before):
N002 (  2, 10) [000018] H-----------        t18 =    CNS_INT(h) long   0xd1ffab1e token $101
                                                  /--*  t18    long   arg0 in rcx
N003 ( 16, 16) [000019] --C---------        t19 = *  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST $181

objp:
======

args:
======
lowering arg : N001 (  0,  0) [000138] ----------L-              *  ARGPLACE  long   $101

late:
======
lowering arg : N002 (  2, 10) [000018] H-----------              *  CNS_INT(h) long   0xd1ffab1e token $101
new node is :                [000258] ------------              *  PUTARG_REG long   REG rcx

lowering call (after):
N002 (  2, 10) [000018] H-----------        t18 =    CNS_INT(h) long   0xd1ffab1e token $101
                                                  /--*  t18    long   
               [000258] ------------       t258 = *  PUTARG_REG long   REG rcx
                                                  /--*  t258   long   arg0 in rcx
N003 ( 16, 16) [000019] --C---------        t19 = *  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST $181

lowering store lcl var/field (before):
N002 (  2, 10) [000018] H-----------        t18 =    CNS_INT(h) long   0xd1ffab1e token $101
                                                  /--*  t18    long   
               [000258] ------------       t258 = *  PUTARG_REG long   REG rcx
                                                  /--*  t258   long   arg0 in rcx
N003 ( 16, 16) [000019] --C---------        t19 = *  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST $181
                                                  /--*  t19    ref    
N005 ( 16, 16) [000021] DA----------              *  STORE_LCL_VAR ref    V04 tmp3         d:1

lowering store lcl var/field (after):
N002 (  2, 10) [000018] H-----------        t18 =    CNS_INT(h) long   0xd1ffab1e token $101
                                                  /--*  t18    long   
               [000258] ------------       t258 = *  PUTARG_REG long   REG rcx
                                                  /--*  t258   long   arg0 in rcx
N003 ( 16, 16) [000019] --C---------        t19 = *  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST $181
                                                  /--*  t19    ref    
N005 ( 16, 16) [000021] DA----------              *  STORE_LCL_VAR ref    V04 tmp3         d:1

lowering call (before):
N003 (  2, 10) [000044] ------------        t44 =    CNS_INT   long   0x7ffa40fb0028 $200
N004 (  1,  1) [000045] ------------        t45 =    CNS_INT   int    6 $42
                                                  /--*  t44    long   arg0 in rcx
                                                  +--*  t45    int    arg1 in rdx
N005 ( 17, 18) [000046] H-CXG-------        t46 = *  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS $281

objp:
======

args:
======
lowering arg : N001 (  0,  0) [000141] ----------L-              *  ARGPLACE  long   $200
lowering arg : N002 (  0,  0) [000142] ----------L-              *  ARGPLACE  int    $42

late:
======
lowering arg : N003 (  2, 10) [000044] ------------              *  CNS_INT   long   0x7ffa40fb0028 $200
new node is :                [000259] ------------              *  PUTARG_REG long   REG rcx

lowering arg : N004 (  1,  1) [000045] ------------              *  CNS_INT   int    6 $42
new node is :                [000260] ------------              *  PUTARG_REG int    REG rdx

lowering call (after):
N003 (  2, 10) [000044] ------------        t44 =    CNS_INT   long   0x7ffa40fb0028 $200
                                                  /--*  t44    long   
               [000259] ------------       t259 = *  PUTARG_REG long   REG rcx
N004 (  1,  1) [000045] ------------        t45 =    CNS_INT   int    6 $42
                                                  /--*  t45    int    
               [000260] ------------       t260 = *  PUTARG_REG int    REG rdx
                                                  /--*  t259   long   arg0 in rcx
                                                  +--*  t260   int    arg1 in rdx
N005 ( 17, 18) [000046] H-CXG-------        t46 = *  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS $281

Addressing mode:
  Base
    N009 (  1,  1) [000035] ------------              *  LCL_VAR   ref    V04 tmp3         u:1 $181
  + 8
Removing unused node:
  N010 (  1,  1) [000139] -c----------              *  CNS_INT   long   8 field offset Fseq[_array] $201
New addressing mode node:
  N011 (  2,  2) [000140] ------------              *  LEA(b+8)  byref 

Addressing mode:
  Base
    N001 (  1,  1) [000005] ------------              *  LCL_VAR   ref    V02 tmp1         u:1 $180
  + 16
Removing unused node:
  N002 (  1,  1) [000144] -c----------              *  CNS_INT   long   16 field offset Fseq[_tokensBuffer] $202
New addressing mode node:
  N003 (  2,  2) [000145] ------------              *  LEA(b+16) byref 

Addressing mode:
  Base
    N001 (  1,  1) [000029] ------------              *  LCL_VAR   ref    V02 tmp1         u:1 $180
  + 8
Removing unused node:
  N002 (  1,  1) [000146] -c----------              *  CNS_INT   long   8 field offset Fseq[_reader] $201
New addressing mode node:
  N003 (  2,  2) [000147] ------------              *  LEA(b+8)  byref 

Lower of StoreInd didn't mark the node as self contained for reason: 4
N001 (  1,  1) [000029] ------------        t29 =    LCL_VAR   ref    V02 tmp1         u:1 $180
                                                  /--*  t29    ref    
N003 (  2,  2) [000147] ------------       t147 = *  LEA(b+8)  byref 
N005 (  1,  1) [000030] ------------        t30 =    CNS_INT   ref    null $VN.Null
                                                  /--*  t147   byref  
                                                  +--*  t30    ref    
               [000237] -A--GO------              *  STOREIND  ref   
lowering store lcl var/field (before):
N001 (  1,  1) [000149] ------------       t149 =    CNS_INT   byref  0 $VN.Null
                                                  /--*  t149   byref  
N003 (  5,  4) [000150] DA----------              *  STORE_LCL_VAR byref  V21 tmp20        d:1

lowering store lcl var/field (after):
N001 (  1,  1) [000149] ------------       t149 =    CNS_INT   byref  0 $VN.Null
                                                  /--*  t149   byref  
N003 (  5,  4) [000150] DA----------              *  STORE_LCL_VAR byref  V21 tmp20        d:1

lowering store lcl var/field (before):
N004 (  1,  1) [000152] ------------       t152 =    CNS_INT   int    0 $40
                                                  /--*  t152   int    
N006 (  5,  4) [000153] DA----------              *  STORE_LCL_VAR int    V22 tmp21        d:1

lowering store lcl var/field (after):
N004 (  1,  1) [000152] ------------       t152 =    CNS_INT   int    0 $40
                                                  /--*  t152   int    
N006 (  5,  4) [000153] DA----------              *  STORE_LCL_VAR int    V22 tmp21        d:1

lowering store lcl var/field (before):
N001 (  3,  2) [000156] ------------       t156 =    LCL_VAR   byref  V21 tmp20        u:1 (last use) $VN.Null
                                                  /--*  t156   byref  
N003 (  7,  5) [000157] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:3

lowering store lcl var/field (after):
N001 (  3,  2) [000156] ------------       t156 =    LCL_VAR   byref  V21 tmp20        u:1 (last use) $VN.Null
                                                  /--*  t156   byref  
N003 (  7,  5) [000157] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:3

lowering store lcl var/field (before):
N004 (  1,  1) [000233] ------------       t233 =    CNS_INT   int    0 $40
                                                  /--*  t233   int    
N006 (  5,  4) [000160] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:3

lowering store lcl var/field (after):
N004 (  1,  1) [000233] ------------       t233 =    CNS_INT   int    0 $40
                                                  /--*  t233   int    
N006 (  5,  4) [000160] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:3

lowering store lcl var/field (before):
N001 (  1,  1) [000171] ------------       t171 =    LCL_VAR   ref    V00 arg0         u:1 $80
N002 (  1,  1) [000172] -c----------       t172 =    CNS_INT   long   12 field offset Fseq[_firstChar] $203
                                                  /--*  t171   ref    
                                                  +--*  t172   long   
N003 (  3,  3) [000173] ------------       t173 = *  ADD       byref  $303
                                                  /--*  t173   byref  
N005 (  7,  6) [000112] DA--G-------              *  STORE_LCL_VAR byref  V09 tmp8         d:1

lowering store lcl var/field (after):
N001 (  1,  1) [000171] ------------       t171 =    LCL_VAR   ref    V00 arg0         u:1 $80
N002 (  1,  1) [000172] -c----------       t172 =    CNS_INT   long   12 field offset Fseq[_firstChar] $203
                                                  /--*  t171   ref    
                                                  +--*  t172   long   
N003 (  3,  3) [000173] ------------       t173 = *  ADD       byref  $303
                                                  /--*  t173   byref  
N005 (  7,  6) [000112] DA--G-------              *  STORE_LCL_VAR byref  V09 tmp8         d:1

Addressing mode:
  Base
    N001 (  1,  1) [000056] ------------              *  LCL_VAR   ref    V00 arg0         u:1 (last use) $80
  + 8
Removing unused node:
                 [000255] -c----------              *  CNS_INT   long   8
New addressing mode node:
                 [000256] ------------              *  LEA(b+8)  ref   

lowering store lcl var/field (before):
N001 (  1,  1) [000056] ------------        t56 =    LCL_VAR   ref    V00 arg0         u:1 (last use) $80
                                                  /--*  t56    ref    
               [000256] -c----------       t256 = *  LEA(b+8)  ref   
                                                  /--*  t256   ref    
N002 (  3,  3) [000057] ---X--------        t57 = *  IND       int    $341
                                                  /--*  t57    int    
N004 (  3,  3) [000114] DA-X--------              *  STORE_LCL_VAR int    V08 tmp7         d:1

lowering store lcl var/field (after):
N001 (  1,  1) [000056] ------------        t56 =    LCL_VAR   ref    V00 arg0         u:1 (last use) $80
                                                  /--*  t56    ref    
               [000256] -c----------       t256 = *  LEA(b+8)  ref   
                                                  /--*  t256   ref    
N002 (  3,  3) [000057] ---X--------        t57 = *  IND       int    $341
                                                  /--*  t57    int    
N004 (  3,  3) [000114] DA-X--------              *  STORE_LCL_VAR int    V08 tmp7         d:1

lowering store lcl var/field (before):
N001 (  2, 10) [000118] H-----------       t118 =    CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL] $106
                                                  /--*  t118   long   
N002 (  4, 12) [000119] #---G-------       t119 = *  IND       ref    $18c
                                                  /--*  t119   ref    
N004 (  8, 15) [000229] DA--G-------              *  STORE_LCL_VAR ref    V27 cse0         d:1

lowering store lcl var/field (after):
N001 (  2, 10) [000118] H-----------       t118 =    CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL] $106
                                                  /--*  t118   long   
N002 (  4, 12) [000119] #---G-------       t119 = *  IND       ref    $18c
                                                  /--*  t119   ref    
N004 (  8, 15) [000229] DA--G-------              *  STORE_LCL_VAR ref    V27 cse0         d:1

lowering store lcl var/field (before):
N005 (  3,  2) [000230] ------------       t230 =    LCL_VAR   ref    V27 cse0         u:1 $18c
                                                  /--*  t230   ref    
N008 ( 15, 20) [000133] DA--G-------              *  STORE_LCL_VAR ref    V13 tmp12        d:1

lowering store lcl var/field (after):
N005 (  3,  2) [000230] ------------       t230 =    LCL_VAR   ref    V27 cse0         u:1 $18c
                                                  /--*  t230   ref    
N008 ( 15, 20) [000133] DA--G-------              *  STORE_LCL_VAR ref    V13 tmp12        d:1

lowering store lcl var/field (before):
N001 (  3,  2) [000232] ------------       t232 =    LCL_VAR   ref    V27 cse0         u:1 $18c
                                                  /--*  t232   ref    
N003 (  7,  5) [000135] DA--G-------              *  STORE_LCL_VAR ref    V14 tmp13        d:1

lowering store lcl var/field (after):
N001 (  3,  2) [000232] ------------       t232 =    LCL_VAR   ref    V27 cse0         u:1 $18c
                                                  /--*  t232   ref    
N003 (  7,  5) [000135] DA--G-------              *  STORE_LCL_VAR ref    V14 tmp13        d:1

lowering call (before):
N003 (  3,  2) [000129] ------------       t129 =    LCL_VAR   ref    V14 tmp13        u:1 (last use) $18c
N004 (  3,  2) [000130] ------------       t130 =    LCL_VAR   ref    V14 tmp13        u:1 (last use) $18c
                                                  /--*  t129   ref    arg0 in rcx
                                                  +--*  t130   ref    arg1 in rdx
N005 ( 20, 11) [000131] --CXG-------              *  CALL      void   System.Diagnostics.Debug.Fail $VN.Void

objp:
======

args:
======
lowering arg : N001 (  0,  0) [000175] ----------L-              *  ARGPLACE  ref    $18c
lowering arg : N002 (  0,  0) [000176] ----------L-              *  ARGPLACE  ref    $18c

late:
======
lowering arg : N003 (  3,  2) [000129] ------------              *  LCL_VAR   ref    V14 tmp13        u:1 (last use) $18c
new node is :                [000261] ------------              *  PUTARG_REG ref    REG rcx

lowering arg : N004 (  3,  2) [000130] ------------              *  LCL_VAR   ref    V14 tmp13        u:1 (last use) $18c
new node is :                [000262] ------------              *  PUTARG_REG ref    REG rdx

lowering call (after):
N003 (  3,  2) [000129] ------------       t129 =    LCL_VAR   ref    V14 tmp13        u:1 (last use) $18c
                                                  /--*  t129   ref    
               [000261] ------------       t261 = *  PUTARG_REG ref    REG rcx
N004 (  3,  2) [000130] ------------       t130 =    LCL_VAR   ref    V14 tmp13        u:1 (last use) $18c
                                                  /--*  t130   ref    
               [000262] ------------       t262 = *  PUTARG_REG ref    REG rdx
                                                  /--*  t261   ref    arg0 in rcx
                                                  +--*  t262   ref    arg1 in rdx
N005 ( 20, 11) [000131] --CXG-------              *  CALL      void   System.Diagnostics.Debug.Fail $VN.Void

lowering store lcl var/field (before):
N001 (  3,  2) [000096] ------------        t96 =    LCL_VAR   byref  V09 tmp8         u:1 (last use) $303
                                                  /--*  t96    byref  
N003 (  7,  5) [000100] DA----------              *  STORE_LCL_VAR byref  V23 tmp22        d:1

lowering store lcl var/field (after):
N001 (  3,  2) [000096] ------------        t96 =    LCL_VAR   byref  V09 tmp8         u:1 (last use) $303
                                                  /--*  t96    byref  
N003 (  7,  5) [000100] DA----------              *  STORE_LCL_VAR byref  V23 tmp22        d:1

lowering store lcl var/field (before):
N001 (  3,  2) [000178] -------N----       t178 =    LCL_VAR   byref  V23 tmp22        u:1 (last use) $303
                                                  /--*  t178   byref  
N003 (  7,  5) [000179] DA----------              *  STORE_LCL_VAR byref  V19 tmp18        d:1

lowering store lcl var/field (after):
N001 (  3,  2) [000178] -------N----       t178 =    LCL_VAR   byref  V23 tmp22        u:1 (last use) $303
                                                  /--*  t178   byref  
N003 (  7,  5) [000179] DA----------              *  STORE_LCL_VAR byref  V19 tmp18        d:1

lowering store lcl var/field (before):
N001 (  1,  1) [000108] ------------       t108 =    LCL_VAR   int    V08 tmp7         u:1 (last use) $400
                                                  /--*  t108   int    
N003 (  5,  4) [000110] DA----------              *  STORE_LCL_VAR int    V20 tmp19        d:1

lowering store lcl var/field (after):
N001 (  1,  1) [000108] ------------       t108 =    LCL_VAR   int    V08 tmp7         u:1 (last use) $400
                                                  /--*  t108   int    
N003 (  5,  4) [000110] DA----------              *  STORE_LCL_VAR int    V20 tmp19        d:1

lowering store lcl var/field (before):
N001 (  3,  2) [000181] ------------       t181 =    LCL_VAR   byref  V19 tmp18        u:1 (last use) $303
                                                  /--*  t181   byref  
N003 (  7,  5) [000182] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:2

lowering store lcl var/field (after):
N001 (  3,  2) [000181] ------------       t181 =    LCL_VAR   byref  V19 tmp18        u:1 (last use) $303
                                                  /--*  t181   byref  
N003 (  7,  5) [000182] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:2

lowering store lcl var/field (before):
N004 (  3,  2) [000184] ------------       t184 =    LCL_VAR   int    V20 tmp19        u:1 (last use) $400
                                                  /--*  t184   int    
N006 (  7,  5) [000185] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:2

lowering store lcl var/field (after):
N004 (  3,  2) [000184] ------------       t184 =    LCL_VAR   int    V20 tmp19        u:1 (last use) $400
                                                  /--*  t184   int    
N006 (  7,  5) [000185] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:2

lowering store lcl var/field (before):
N001 (  0,  0) [000226] ------------       t226 =    PHI_ARG   int    V18 tmp17        u:3 $40
N002 (  0,  0) [000224] ------------       t224 =    PHI_ARG   int    V18 tmp17        u:2 $400
                                                  /--*  t226   int    
                                                  +--*  t224   int    
N003 (  0,  0) [000222] ------------       t222 = *  PHI       int   
                                                  /--*  t222   int    
N005 (  0,  0) [000223] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:1

lowering store lcl var/field (after):
N001 (  0,  0) [000226] ------------       t226 =    PHI_ARG   int    V18 tmp17        u:3 $40
N002 (  0,  0) [000224] ------------       t224 =    PHI_ARG   int    V18 tmp17        u:2 $400
                                                  /--*  t226   int    
                                                  +--*  t224   int    
N003 (  0,  0) [000222] ------------       t222 = *  PHI       int   
                                                  /--*  t222   int    
N005 (  0,  0) [000223] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:1

lowering store lcl var/field (before):
N001 (  0,  0) [000227] ------------       t227 =    PHI_ARG   byref  V17 tmp16        u:3 $VN.Null
N002 (  0,  0) [000225] ------------       t225 =    PHI_ARG   byref  V17 tmp16        u:2 $303
                                                  /--*  t227   byref  
                                                  +--*  t225   byref  
N003 (  0,  0) [000219] ------------       t219 = *  PHI       byref 
                                                  /--*  t219   byref  
N005 (  0,  0) [000220] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:1

lowering store lcl var/field (after):
N001 (  0,  0) [000227] ------------       t227 =    PHI_ARG   byref  V17 tmp16        u:3 $VN.Null
N002 (  0,  0) [000225] ------------       t225 =    PHI_ARG   byref  V17 tmp16        u:2 $303
                                                  /--*  t227   byref  
                                                  +--*  t225   byref  
N003 (  0,  0) [000219] ------------       t219 = *  PHI       byref 
                                                  /--*  t219   byref  
N005 (  0,  0) [000220] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:1

lowering store lcl var/field (before):
N001 (  3,  2) [000188] ------------       t188 =    LCL_VAR   byref  V17 tmp16        u:1 (last use) $480
                                                  /--*  t188   byref  
N003 (  7,  5) [000189] DA----------              *  STORE_LCL_VAR byref  V15 tmp14        d:1

lowering store lcl var/field (after):
N001 (  3,  2) [000188] ------------       t188 =    LCL_VAR   byref  V17 tmp16        u:1 (last use) $480
                                                  /--*  t188   byref  
N003 (  7,  5) [000189] DA----------              *  STORE_LCL_VAR byref  V15 tmp14        d:1

lowering store lcl var/field (before):
N004 (  3,  2) [000191] ------------       t191 =    LCL_VAR   int    V18 tmp17        u:1 (last use) $440
                                                  /--*  t191   int    
N006 (  7,  5) [000192] DA----------              *  STORE_LCL_VAR int    V16 tmp15        d:1

lowering store lcl var/field (after):
N004 (  3,  2) [000191] ------------       t191 =    LCL_VAR   int    V18 tmp17        u:1 (last use) $440
                                                  /--*  t191   int    
N006 (  7,  5) [000192] DA----------              *  STORE_LCL_VAR int    V16 tmp15        d:1

lowering store lcl var/field (before):
N001 (  1,  1) [000007] ------------         t7 =    LCL_VAR   ref    V02 tmp1         u:1 (last use) $180
                                                  /--*  t7     ref    
N003 (  1,  3) [000214] DA--------L-              *  STORE_LCL_VAR ref    V26 tmp25        d:1

lowering store lcl var/field (after):
N001 (  1,  1) [000007] ------------         t7 =    LCL_VAR   ref    V02 tmp1         u:1 (last use) $180
                                                  /--*  t7     ref    
N003 (  1,  3) [000214] DA--------L-              *  STORE_LCL_VAR ref    V26 tmp25        d:1

lowering store lcl var/field (before):
N004 (  3,  2) [000198] -------N----       t198 =    LCL_VAR_ADDR byref  V24 tmp23        
                                                  /--*  t198   byref  
N007 (  3,  3) [000200] DA----------              *  STORE_LCL_VAR byref  V25 tmp24        d:1

lowering store lcl var/field (after):
N004 (  3,  2) [000198] -------N----       t198 =    LCL_VAR_ADDR byref  V24 tmp23        
                                                  /--*  t198   byref  
N007 (  3,  3) [000200] DA----------              *  STORE_LCL_VAR byref  V25 tmp24        d:1

Lower of StoreInd didn't mark the node as self contained for reason: 4
N008 (  1,  1) [000201] ------------       t201 =    LCL_VAR   byref  V25 tmp24        u:1 Zero Fseq[_pointer] $3c7
N010 (  3,  2) [000203] -------N----       t203 =    LCL_VAR   byref  V15 tmp14        u:1 (last use) $480
                                                  /--*  t201   byref  
                                                  +--*  t203   byref  
               [000252] -A----------              *  STOREIND  byref 
Addressing mode:
  Base
    N013 (  1,  1) [000206] ------------              *  LCL_VAR   byref  V25 tmp24        u:1 (last use) $3c7
  + 8
Removing unused node:
  N014 (  1,  1) [000207] -c----------              *  CNS_INT   long   8 Fseq[_length] $201
New addressing mode node:
  N015 (  2,  2) [000208] ------------              *  LEA(b+8)  byref 

Lower of StoreInd didn't mark the node as self contained for reason: 4
N013 (  1,  1) [000206] ------------       t206 =    LCL_VAR   byref  V25 tmp24        u:1 (last use) $3c7
                                                  /--*  t206   byref  
N015 (  2,  2) [000208] ------------       t208 = *  LEA(b+8)  byref 
N017 (  3,  2) [000210] -------N----       t210 =    LCL_VAR   int    V16 tmp15        u:1 (last use) $440
                                                  /--*  t208   byref  
                                                  +--*  t210   int    
               [000253] -A--------L-              *  STOREIND  int   
lowering call (before):
N001 (  1,  1) [000007] ------------         t7 =    LCL_VAR   ref    V02 tmp1         u:1 (last use) $180
                                                  /--*  t7     ref    
N003 (  1,  3) [000214] DA--------L-              *  STORE_LCL_VAR ref    V26 tmp25        d:1
N004 (  3,  2) [000198] -------N----       t198 =    LCL_VAR_ADDR byref  V24 tmp23        
                                                  /--*  t198   byref  
N007 (  3,  3) [000200] DA----------              *  STORE_LCL_VAR byref  V25 tmp24        d:1
N008 (  1,  1) [000201] ------------       t201 =    LCL_VAR   byref  V25 tmp24        u:1 Zero Fseq[_pointer] $3c7
N010 (  3,  2) [000203] -------N----       t203 =    LCL_VAR   byref  V15 tmp14        u:1 (last use) $480
                                                  /--*  t201   byref  
                                                  +--*  t203   byref  
               [000252] -A----------              *  STOREIND  byref 
N013 (  1,  1) [000206] ------------       t206 =    LCL_VAR   byref  V25 tmp24        u:1 (last use) $3c7
                                                  /--*  t206   byref  
N015 (  2,  2) [000208] -c----------       t208 = *  LEA(b+8)  byref 
N017 (  3,  2) [000210] -------N----       t210 =    LCL_VAR   int    V16 tmp15        u:1 (last use) $440
                                                  /--*  t208   byref  
                                                  +--*  t210   int    
               [000253] -A--------L-              *  STOREIND  int   
N020 (  1,  1) [000215] ------------       t215 =    LCL_VAR   ref    V26 tmp25        u:1 (last use) $180
N021 (  3,  2) [000216] -------N----       t216 =    LCL_VAR_ADDR byref  V24 tmp23        
                                                  /--*  t215   ref    this in rcx
                                                  +--*  t216   byref  arg1 in rdx
N023 ( 40, 30) [000011] --CXG-------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer.TokenizeLine $VN.Void

objp:
======
lowering arg : N003 (  1,  3) [000214] DA--------L-              *  STORE_LCL_VAR ref    V26 tmp25        d:1

args:
======
lowering arg :                [000253] -A--------L-              *  STOREIND  int   

late:
======
lowering arg : N020 (  1,  1) [000215] ------------              *  LCL_VAR   ref    V26 tmp25        u:1 (last use) $180
new node is :                [000263] ------------              *  PUTARG_REG ref    REG rcx

lowering arg : N021 (  3,  2) [000216] -------N----              *  LCL_VAR_ADDR byref  V24 tmp23        
new node is :                [000264] ------------              *  PUTARG_REG byref  REG rdx

lowering call (after):
N001 (  1,  1) [000007] ------------         t7 =    LCL_VAR   ref    V02 tmp1         u:1 (last use) $180
                                                  /--*  t7     ref    
N003 (  1,  3) [000214] DA--------L-              *  STORE_LCL_VAR ref    V26 tmp25        d:1
N004 (  3,  2) [000198] -------N----       t198 =    LCL_VAR_ADDR byref  V24 tmp23        
                                                  /--*  t198   byref  
N007 (  3,  3) [000200] DA----------              *  STORE_LCL_VAR byref  V25 tmp24        d:1
N008 (  1,  1) [000201] ------------       t201 =    LCL_VAR   byref  V25 tmp24        u:1 Zero Fseq[_pointer] $3c7
N010 (  3,  2) [000203] -------N----       t203 =    LCL_VAR   byref  V15 tmp14        u:1 (last use) $480
                                                  /--*  t201   byref  
                                                  +--*  t203   byref  
               [000252] -A----------              *  STOREIND  byref 
N013 (  1,  1) [000206] ------------       t206 =    LCL_VAR   byref  V25 tmp24        u:1 (last use) $3c7
                                                  /--*  t206   byref  
N015 (  2,  2) [000208] -c----------       t208 = *  LEA(b+8)  byref 
N017 (  3,  2) [000210] -------N----       t210 =    LCL_VAR   int    V16 tmp15        u:1 (last use) $440
                                                  /--*  t208   byref  
                                                  +--*  t210   int    
               [000253] -A--------L-              *  STOREIND  int   
N020 (  1,  1) [000215] ------------       t215 =    LCL_VAR   ref    V26 tmp25        u:1 (last use) $180
                                                  /--*  t215   ref    
               [000263] ------------       t263 = *  PUTARG_REG ref    REG rcx
N021 (  3,  2) [000216] -------N----       t216 =    LCL_VAR_ADDR byref  V24 tmp23        
                                                  /--*  t216   byref  
               [000264] ------------       t264 = *  PUTARG_REG byref  REG rdx
                                                  /--*  t263   ref    this in rcx
                                                  +--*  t264   byref  arg1 in rdx
N023 ( 40, 30) [000011] --CXG-------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer.TokenizeLine $VN.Void

lowering GT_RETURN
N001 (  0,  0) [000017] ------------              *  RETURN    void   $382
============Lower has completed modifying nodes.

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)-> BB03 ( cond )                     i label target hascall newobj LIR 
BB02 [0007]  1       BB01                  0.50     [006..007)-> BB06 (always)                     i LIR 
BB03 [0008]  1       BB01                  0.50     [006..007)-> BB05 ( cond )                     i label target idxlen nullcheck LIR 
BB04 [0014]  1       BB03                  0.25     [006..007)                                     i hascall gcsafe LIR 
BB05 [0015]  2       BB03,BB04             0.50     [006..007)                                     i label target idxlen nullcheck LIR 
BB06 [0009]  2       BB02,BB05             1        [???..???)        (return)                     internal label target hascall gcsafe newobj LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..012) -> BB03 (cond), preds={} succs={BB02,BB03}
               [000234] ------------                 IL_OFFSET void   IL offset: 0x0
N002 (  2, 10) [000001] H-----------         t1 =    CNS_INT(h) long   0xd1ffab1e token $100
                                                  /--*  t1     long   
               [000257] ------------       t257 = *  PUTARG_REG long   REG rcx
                                                  /--*  t257   long   arg0 in rcx
N003 ( 16, 16) [000002] --C---------         t2 = *  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST $180
                                                  /--*  t2     ref    
N005 ( 16, 16) [000004] DA----------              *  STORE_LCL_VAR ref    V02 tmp1         d:1
N002 (  2, 10) [000018] H-----------        t18 =    CNS_INT(h) long   0xd1ffab1e token $101
                                                  /--*  t18    long   
               [000258] ------------       t258 = *  PUTARG_REG long   REG rcx
                                                  /--*  t258   long   arg0 in rcx
N003 ( 16, 16) [000019] --C---------        t19 = *  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST $181
                                                  /--*  t19    ref    
N005 ( 16, 16) [000021] DA----------              *  STORE_LCL_VAR ref    V04 tmp3         d:1
N003 (  2, 10) [000044] ------------        t44 =    CNS_INT   long   0x7ffa40fb0028 $200
                                                  /--*  t44    long   
               [000259] ------------       t259 = *  PUTARG_REG long   REG rcx
N004 (  1,  1) [000045] ------------        t45 =    CNS_INT   int    6 $42
                                                  /--*  t45    int    
               [000260] ------------       t260 = *  PUTARG_REG int    REG rdx
                                                  /--*  t259   long   arg0 in rcx
                                                  +--*  t260   int    arg1 in rdx
N005 ( 17, 18) [000046] H-CXG-------        t46 = *  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS $281
N006 (  2, 10) [000143] I-----------       t143 =    CNS_INT(h) long   0xd1ffab1e static Fseq[Value] $102
                                                  /--*  t143   long   
N007 (  4, 12) [000042] n---G-------        t42 = *  IND       ref    <l:$2c0, c:$144>
N009 (  1,  1) [000035] ------------        t35 =    LCL_VAR   ref    V04 tmp3         u:1 $181
                                                  /--*  t35    ref    
N011 (  2,  2) [000140] ------------       t140 = *  LEA(b+8)  byref 
                                                  /--*  t140   byref  
                                                  +--*  t42    ref    
               [000235] -ACXGO------              *  STOREIND  ref   
N001 (  1,  1) [000005] ------------         t5 =    LCL_VAR   ref    V02 tmp1         u:1 $180
                                                  /--*  t5     ref    
N003 (  2,  2) [000145] ------------       t145 = *  LEA(b+16) byref 
N005 (  1,  1) [000024] ------------        t24 =    LCL_VAR   ref    V04 tmp3         u:1 (last use) $181
                                                  /--*  t145   byref  
                                                  +--*  t24    ref    
               [000236] -A--GO------              *  STOREIND  ref   
N001 (  1,  1) [000029] ------------        t29 =    LCL_VAR   ref    V02 tmp1         u:1 $180
                                                  /--*  t29    ref    
N003 (  2,  2) [000147] -c----------       t147 = *  LEA(b+8)  byref 
N005 (  1,  1) [000030] ------------        t30 =    CNS_INT   ref    null $VN.Null
                                                  /--*  t147   byref  
                                                  +--*  t30    ref    
               [000237] -A--GO------              *  STOREIND  ref   
               [000238] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  1,  1) [000008] ------------         t8 =    LCL_VAR   ref    V00 arg0         u:1 $80
N002 (  1,  1) [000050] -c----------        t50 =    CNS_INT   ref    null $VN.Null
                                                  /--*  t8     ref    
                                                  +--*  t50    ref    
N003 (  3,  3) [000051] J------N----              *  NE        void   $340
N004 (  5,  5) [000052] ------------              *  JTRUE     void  

------------ BB02 [006..007) -> BB06 (always), preds={BB01} succs={BB06}
               [000239] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  1,  1) [000149] ------------       t149 =    CNS_INT   byref  0 $VN.Null
                                                  /--*  t149   byref  
N003 (  5,  4) [000150] DA----------              *  STORE_LCL_VAR byref  V21 tmp20        d:1
N004 (  1,  1) [000152] ------------       t152 =    CNS_INT   int    0 $40
                                                  /--*  t152   int    
N006 (  5,  4) [000153] DA----------              *  STORE_LCL_VAR int    V22 tmp21        d:1
               [000240] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  3,  2) [000156] ------------       t156 =    LCL_VAR   byref  V21 tmp20        u:1 (last use) $VN.Null
                                                  /--*  t156   byref  
N003 (  7,  5) [000157] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:3
N004 (  1,  1) [000233] ------------       t233 =    CNS_INT   int    0 $40
                                                  /--*  t233   int    
N006 (  5,  4) [000160] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:3

------------ BB03 [006..007) -> BB05 (cond), preds={BB01} succs={BB04,BB05}
               [000241] ------------                 IL_OFFSET void   IL offset: 0x6
               [000242] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  1,  1) [000171] ------------       t171 =    LCL_VAR   ref    V00 arg0         u:1 $80
N002 (  1,  1) [000172] -c----------       t172 =    CNS_INT   long   12 field offset Fseq[_firstChar] $203
                                                  /--*  t171   ref    
                                                  +--*  t172   long   
N003 (  3,  3) [000173] ------------       t173 = *  ADD       byref  $303
                                                  /--*  t173   byref  
N005 (  7,  6) [000112] DA--G-------              *  STORE_LCL_VAR byref  V09 tmp8         d:1
               [000243] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  1,  1) [000056] ------------        t56 =    LCL_VAR   ref    V00 arg0         u:1 (last use) $80
                                                  /--*  t56    ref    
               [000256] -c----------       t256 = *  LEA(b+8)  ref   
                                                  /--*  t256   ref    
N002 (  3,  3) [000057] ---X--------        t57 = *  IND       int    $341
                                                  /--*  t57    int    
N004 (  3,  3) [000114] DA-X--------              *  STORE_LCL_VAR int    V08 tmp7         d:1
               [000244] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  2, 10) [000118] H-----------       t118 =    CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL] $106
                                                  /--*  t118   long   
N002 (  4, 12) [000119] #---G-------       t119 = *  IND       ref    $18c
                                                  /--*  t119   ref    
N004 (  8, 15) [000229] DA--G-------              *  STORE_LCL_VAR ref    V27 cse0         d:1
N005 (  3,  2) [000230] ------------       t230 =    LCL_VAR   ref    V27 cse0         u:1 $18c
                                                  /--*  t230   ref    
N008 ( 15, 20) [000133] DA--G-------              *  STORE_LCL_VAR ref    V13 tmp12        d:1
               [000245] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  3,  2) [000232] ------------       t232 =    LCL_VAR   ref    V27 cse0         u:1 $18c
                                                  /--*  t232   ref    
N003 (  7,  5) [000135] DA--G-------              *  STORE_LCL_VAR ref    V14 tmp13        d:1
               [000246] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  1,  1) [000088] ------------        t88 =    LCL_VAR   int    V08 tmp7         u:1 $400
N002 (  1,  1) [000089] -c----------        t89 =    CNS_INT   int    0 $40
                                                  /--*  t88    int    
                                                  +--*  t89    int    
N003 (  3,  3) [000090] J------N----              *  GE        void   $342
N004 (  5,  5) [000128] ------------              *  JTRUE     void  

------------ BB04 [006..007), preds={BB03} succs={BB05}
               [000247] ------------                 IL_OFFSET void   IL offset: 0x6
N003 (  3,  2) [000129] ------------       t129 =    LCL_VAR   ref    V14 tmp13        u:1 (last use) $18c
                                                  /--*  t129   ref    
               [000261] ------------       t261 = *  PUTARG_REG ref    REG rcx
N004 (  3,  2) [000130] ------------       t130 =    LCL_VAR   ref    V14 tmp13        u:1 (last use) $18c
                                                  /--*  t130   ref    
               [000262] ------------       t262 = *  PUTARG_REG ref    REG rdx
                                                  /--*  t261   ref    arg0 in rcx
                                                  +--*  t262   ref    arg1 in rdx
N005 ( 20, 11) [000131] --CXG-------              *  CALL      void   System.Diagnostics.Debug.Fail $VN.Void

------------ BB05 [006..007), preds={BB03,BB04} succs={BB06}
               [000248] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  3,  2) [000096] ------------        t96 =    LCL_VAR   byref  V09 tmp8         u:1 (last use) $303
                                                  /--*  t96    byref  
N003 (  7,  5) [000100] DA----------              *  STORE_LCL_VAR byref  V23 tmp22        d:1
               [000249] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  3,  2) [000178] -------N----       t178 =    LCL_VAR   byref  V23 tmp22        u:1 (last use) $303
                                                  /--*  t178   byref  
N003 (  7,  5) [000179] DA----------              *  STORE_LCL_VAR byref  V19 tmp18        d:1
               [000250] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  1,  1) [000108] ------------       t108 =    LCL_VAR   int    V08 tmp7         u:1 (last use) $400
                                                  /--*  t108   int    
N003 (  5,  4) [000110] DA----------              *  STORE_LCL_VAR int    V20 tmp19        d:1
               [000251] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  3,  2) [000181] ------------       t181 =    LCL_VAR   byref  V19 tmp18        u:1 (last use) $303
                                                  /--*  t181   byref  
N003 (  7,  5) [000182] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:2
N004 (  3,  2) [000184] ------------       t184 =    LCL_VAR   int    V20 tmp19        u:1 (last use) $400
                                                  /--*  t184   int    
N006 (  7,  5) [000185] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:2

------------ BB06 [???..???) (return), preds={BB02,BB05} succs={}
N001 (  0,  0) [000226] ------------       t226 =    PHI_ARG   int    V18 tmp17        u:3 $40
N002 (  0,  0) [000224] ------------       t224 =    PHI_ARG   int    V18 tmp17        u:2 $400
                                                  /--*  t226   int    
                                                  +--*  t224   int    
N003 (  0,  0) [000222] ------------       t222 = *  PHI       int   
                                                  /--*  t222   int    
N005 (  0,  0) [000223] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:1
N001 (  0,  0) [000227] ------------       t227 =    PHI_ARG   byref  V17 tmp16        u:3 $VN.Null
N002 (  0,  0) [000225] ------------       t225 =    PHI_ARG   byref  V17 tmp16        u:2 $303
                                                  /--*  t227   byref  
                                                  +--*  t225   byref  
N003 (  0,  0) [000219] ------------       t219 = *  PHI       byref 
                                                  /--*  t219   byref  
N005 (  0,  0) [000220] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:1
N001 (  3,  2) [000188] ------------       t188 =    LCL_VAR   byref  V17 tmp16        u:1 (last use) $480
                                                  /--*  t188   byref  
N003 (  7,  5) [000189] DA----------              *  STORE_LCL_VAR byref  V15 tmp14        d:1
N004 (  3,  2) [000191] ------------       t191 =    LCL_VAR   int    V18 tmp17        u:1 (last use) $440
                                                  /--*  t191   int    
N006 (  7,  5) [000192] DA----------              *  STORE_LCL_VAR int    V16 tmp15        d:1
N001 (  1,  1) [000007] ------------         t7 =    LCL_VAR   ref    V02 tmp1         u:1 (last use) $180
                                                  /--*  t7     ref    
N003 (  1,  3) [000214] DA--------L-              *  STORE_LCL_VAR ref    V26 tmp25        d:1
N004 (  3,  2) [000198] -------N----       t198 =    LCL_VAR_ADDR byref  V24 tmp23        
                                                  /--*  t198   byref  
N007 (  3,  3) [000200] DA----------              *  STORE_LCL_VAR byref  V25 tmp24        d:1
N008 (  1,  1) [000201] ------------       t201 =    LCL_VAR   byref  V25 tmp24        u:1 Zero Fseq[_pointer] $3c7
N010 (  3,  2) [000203] -------N----       t203 =    LCL_VAR   byref  V15 tmp14        u:1 (last use) $480
                                                  /--*  t201   byref  
                                                  +--*  t203   byref  
               [000252] -A----------              *  STOREIND  byref 
N013 (  1,  1) [000206] ------------       t206 =    LCL_VAR   byref  V25 tmp24        u:1 (last use) $3c7
                                                  /--*  t206   byref  
N015 (  2,  2) [000208] -c----------       t208 = *  LEA(b+8)  byref 
N017 (  3,  2) [000210] -------N----       t210 =    LCL_VAR   int    V16 tmp15        u:1 (last use) $440
                                                  /--*  t208   byref  
                                                  +--*  t210   int    
               [000253] -A--------L-              *  STOREIND  int   
N020 (  1,  1) [000215] ------------       t215 =    LCL_VAR   ref    V26 tmp25        u:1 (last use) $180
                                                  /--*  t215   ref    
               [000263] ------------       t263 = *  PUTARG_REG ref    REG rcx
N021 (  3,  2) [000216] -------N----       t216 =    LCL_VAR_ADDR byref  V24 tmp23        
                                                  /--*  t216   byref  
               [000264] ------------       t264 = *  PUTARG_REG byref  REG rdx
                                                  /--*  t263   ref    this in rcx
                                                  +--*  t264   byref  arg1 in rdx
N023 ( 40, 30) [000011] --CXG-------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer.TokenizeLine $VN.Void
               [000254] ------------                 IL_OFFSET void   IL offset: 0x11
N001 (  0,  0) [000017] ------------                 RETURN    void   $382

-------------------------------------------------------------------------------------------------------------------

*** lvaComputeRefCounts ***

*** lvaComputeRefCounts -- explicit counts ***
New refCnts for V02: refCnt =  1, refCntWtd = 2   
New refCnts for V04: refCnt =  1, refCntWtd = 2   
New refCnts for V04: refCnt =  2, refCntWtd = 4   
New refCnts for V02: refCnt =  2, refCntWtd = 4   
New refCnts for V04: refCnt =  3, refCntWtd = 6   
New refCnts for V02: refCnt =  3, refCntWtd = 6   
New refCnts for V00: refCnt =  1, refCntWtd = 1   
New refCnts for V21: refCnt =  1, refCntWtd = 0.50
New refCnts for V22: refCnt =  1, refCntWtd = 0.50
New refCnts for V21: refCnt =  2, refCntWtd = 1   
New refCnts for V17: refCnt =  1, refCntWtd = 0.50
New refCnts for V18: refCnt =  1, refCntWtd = 0.50
New refCnts for V00: refCnt =  2, refCntWtd = 1.50
New refCnts for V09: refCnt =  1, refCntWtd = 1   
New refCnts for V00: refCnt =  3, refCntWtd = 2   
New refCnts for V08: refCnt =  1, refCntWtd = 1   
New refCnts for V27: refCnt =  1, refCntWtd = 0.50
New refCnts for V27: refCnt =  2, refCntWtd = 1   
New refCnts for V13: refCnt =  1, refCntWtd = 1   
New refCnts for V27: refCnt =  3, refCntWtd = 1.50
New refCnts for V14: refCnt =  1, refCntWtd = 1   
New refCnts for V08: refCnt =  2, refCntWtd = 2   
New refCnts for V14: refCnt =  2, refCntWtd = 1.50
New refCnts for V14: refCnt =  3, refCntWtd = 2   
New refCnts for V09: refCnt =  2, refCntWtd = 2   
New refCnts for V23: refCnt =  1, refCntWtd = 0.50
New refCnts for V23: refCnt =  2, refCntWtd = 1   
New refCnts for V19: refCnt =  1, refCntWtd = 0.50
New refCnts for V08: refCnt =  3, refCntWtd = 3   
New refCnts for V20: refCnt =  1, refCntWtd = 0.50
New refCnts for V19: refCnt =  2, refCntWtd = 1   
New refCnts for V17: refCnt =  2, refCntWtd = 1   
New refCnts for V20: refCnt =  2, refCntWtd = 1   
New refCnts for V18: refCnt =  2, refCntWtd = 1   
New refCnts for V17: refCnt =  3, refCntWtd = 2   
New refCnts for V15: refCnt =  1, refCntWtd = 1   
New refCnts for V18: refCnt =  3, refCntWtd = 2   
New refCnts for V16: refCnt =  1, refCntWtd = 1   
New refCnts for V02: refCnt =  4, refCntWtd = 8   
New refCnts for V26: refCnt =  1, refCntWtd = 2   
New refCnts for V24: refCnt =  1, refCntWtd = 2   
New refCnts for V25: refCnt =  1, refCntWtd = 2   
New refCnts for V25: refCnt =  2, refCntWtd = 4   
New refCnts for V15: refCnt =  2, refCntWtd = 2   
New refCnts for V25: refCnt =  3, refCntWtd = 6   
New refCnts for V16: refCnt =  2, refCntWtd = 2   
New refCnts for V26: refCnt =  2, refCntWtd = 4   
New refCnts for V24: refCnt =  2, refCntWtd = 4   

*** lvaComputeRefCounts -- implicit counts ***
New refCnts for V00: refCnt =  4, refCntWtd = 3   
New refCnts for V00: refCnt =  5, refCntWtd = 4   
*************** In fgLocalVarLiveness()
; Initial local variable assignments
;
;  V00 arg0              ref  class-hnd
;  V01 OutArgs        lclBlk <32>  "OutgoingArgSpace"
;  V02 tmp1              ref  class-hnd exact "NewObj constructor temp"
;  V03 tmp2           struct <System.ReadOnlySpan`1[Char], 16> "struct address for call/obj"
;  V04 tmp3              ref  class-hnd exact "NewObj constructor temp"
;  V05 tmp4           struct <System.ReadOnlySpan`1[Char], 16> "Inline return value spill temp"
;  V06 tmp5           struct <System.ReadOnlySpan`1[Char], 16> "NewObj constructor temp"
;  V07 tmp6           struct <System.ReadOnlySpan`1[Char], 16> ld-addr-op "Inline ldloca(s) first use temp"
;  V08 tmp7              int  "Inlining Arg"
;  V09 tmp8            byref  "Inlining Arg"
;  V10 tmp9           struct <System.ByReference`1[Char], 8> "NewObj constructor temp"
;  V11 tmp10            bool  "Inlining Arg"
;  V12 tmp11            bool  "Inlining Arg"
;  V13 tmp12             ref  class-hnd "Inlining Arg"
;  V14 tmp13             ref  class-hnd "Inlining Arg"
;  V15 tmp14           byref  V03._pointer(offs=0x00) P-INDEP "field V03._pointer (fldOffset=0x0)"
;  V16 tmp15             int  V03._length(offs=0x08) P-INDEP "field V03._length (fldOffset=0x8)"
;  V17 tmp16           byref  V05._pointer(offs=0x00) P-INDEP "field V05._pointer (fldOffset=0x0)"
;  V18 tmp17             int  V05._length(offs=0x08) P-INDEP "field V05._length (fldOffset=0x8)"
;  V19 tmp18           byref  V06._pointer(offs=0x00) P-INDEP "field V06._pointer (fldOffset=0x0)"
;  V20 tmp19             int  V06._length(offs=0x08) P-INDEP "field V06._length (fldOffset=0x8)"
;  V21 tmp20           byref  V07._pointer(offs=0x00) P-INDEP "field V07._pointer (fldOffset=0x0)"
;  V22 tmp21             int  V07._length(offs=0x08) P-INDEP "field V07._length (fldOffset=0x8)"
;  V23 tmp22           byref  V10._value(offs=0x00) P-INDEP "field V10._value (fldOffset=0x0)"
;  V24 tmp23          struct <System.ReadOnlySpan`1[Char], 16> do-not-enreg[XSB] addr-exposed "by-value struct argument"
;  V25 tmp24           byref  stack-byref "BlockOp address local"
;  V26 tmp25             ref  "argument with side effect"
;  V27 cse0              ref  "CSE - moderate"
In fgLocalVarLivenessInit
Tracked variable (19 out of 28) table:
V02 tmp1          [   ref]: refCnt =    4, refCntWtd =   8   
V00 arg0          [   ref]: refCnt =    5, refCntWtd =   4   
V04 tmp3          [   ref]: refCnt =    3, refCntWtd =   6   
V25 tmp24         [ byref]: refCnt =    3, refCntWtd =   6   
V26 tmp25         [   ref]: refCnt =    2, refCntWtd =   4   
V08 tmp7          [   int]: refCnt =    3, refCntWtd =   3   
V14 tmp13         [   ref]: refCnt =    3, refCntWtd =   2   
V17 tmp16         [ byref]: refCnt =    3, refCntWtd =   2   
V18 tmp17         [   int]: refCnt =    3, refCntWtd =   2   
V09 tmp8          [ byref]: refCnt =    2, refCntWtd =   2   
V15 tmp14         [ byref]: refCnt =    2, refCntWtd =   2   
V16 tmp15         [   int]: refCnt =    2, refCntWtd =   2   
V27 cse0          [   ref]: refCnt =    3, refCntWtd =   1.50
V19 tmp18         [ byref]: refCnt =    2, refCntWtd =   1   
V21 tmp20         [ byref]: refCnt =    2, refCntWtd =   1   
V23 tmp22         [ byref]: refCnt =    2, refCntWtd =   1   
V20 tmp19         [   int]: refCnt =    2, refCntWtd =   1   
V13 tmp12         [   ref]: refCnt =    1, refCntWtd =   1   
V22 tmp21         [   int]: refCnt =    1, refCntWtd =   0.50

*************** In fgPerBlockLocalVarLiveness()
BB01 USE(1)={    V00    } + ByrefExposed + GcHeap
     DEF(2)={V02     V04} + ByrefExposed* + GcHeap*

BB02 USE(0)={               }
     DEF(4)={V17 V18 V21 V22}

BB03 USE(1)={V00                    } + ByrefExposed + GcHeap
     DEF(5)={    V08 V14 V09 V27 V13}

BB04 USE(1)={V14} + ByrefExposed + GcHeap
     DEF(0)={   } + ByrefExposed* + GcHeap*

BB05 USE(2)={V08         V09            }
     DEF(5)={    V17 V18     V19 V23 V20}

BB06 USE(3)={V02         V17 V18        } + ByrefExposed + GcHeap
     DEF(4)={    V25 V26         V15 V16} + ByrefExposed* + GcHeap*

** Memory liveness computed, GcHeap states and ByrefExposed states match
*************** In fgInterBlockLocalVarLiveness()

BB liveness after fgLiveVarAnalysis():

BB01 IN (1)={    V00} + ByrefExposed + GcHeap
     OUT(2)={V02 V00} + ByrefExposed + GcHeap

BB02 IN (1)={V02        } + ByrefExposed + GcHeap
     OUT(3)={V02 V17 V18} + ByrefExposed + GcHeap

BB03 IN (2)={V02 V00            } + ByrefExposed + GcHeap
     OUT(4)={V02     V08 V14 V09} + ByrefExposed + GcHeap

BB04 IN (4)={V02 V08 V14 V09} + ByrefExposed + GcHeap
     OUT(3)={V02 V08     V09} + ByrefExposed + GcHeap

BB05 IN (3)={V02 V08         V09} + ByrefExposed + GcHeap
     OUT(3)={V02     V17 V18    } + ByrefExposed + GcHeap

BB06 IN (3)={V02 V17 V18} + ByrefExposed + GcHeap
     OUT(0)={           }

Removing dead store:
N006 (  5,  4) [000153] DA----------              *  STORE_LCL_VAR int    V22 tmp21        d:1 (last use)
Removing dead node:
N004 (  1,  1) [000152] ------------              *  CNS_INT   int    0 $40
Removing dead store:
N008 ( 15, 20) [000133] DA--G-------              *  STORE_LCL_VAR ref    V13 tmp12        d:1 (last use)
Removing dead LclVar use:
N005 (  3,  2) [000230] ------------              *  LCL_VAR   ref    V27 cse0         u:1 $18c

*************** In fgUpdateFlowGraph()
Before updating the flow graph:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)-> BB03 ( cond )                     i label target hascall newobj LIR 
BB02 [0007]  1       BB01                  0.50     [006..007)-> BB06 (always)                     i LIR 
BB03 [0008]  1       BB01                  0.50     [006..007)-> BB05 ( cond )                     i label target idxlen nullcheck LIR 
BB04 [0014]  1       BB03                  0.25     [006..007)                                     i hascall gcsafe LIR 
BB05 [0015]  2       BB03,BB04             0.50     [006..007)                                     i label target idxlen nullcheck LIR 
BB06 [0009]  2       BB02,BB05             1        [???..???)        (return)                     internal label target hascall gcsafe newobj LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

*************** In fgDebugCheckBBlist

*** lvaComputeRefCounts ***

*** lvaComputeRefCounts -- explicit counts ***
New refCnts for V02: refCnt =  1, refCntWtd = 2   
New refCnts for V04: refCnt =  1, refCntWtd = 2   
New refCnts for V04: refCnt =  2, refCntWtd = 4   
New refCnts for V02: refCnt =  2, refCntWtd = 4   
New refCnts for V04: refCnt =  3, refCntWtd = 6   
New refCnts for V02: refCnt =  3, refCntWtd = 6   
New refCnts for V00: refCnt =  1, refCntWtd = 1   
New refCnts for V21: refCnt =  1, refCntWtd = 0.50
New refCnts for V21: refCnt =  2, refCntWtd = 1   
New refCnts for V17: refCnt =  1, refCntWtd = 0.50
New refCnts for V18: refCnt =  1, refCntWtd = 0.50
New refCnts for V00: refCnt =  2, refCntWtd = 1.50
New refCnts for V09: refCnt =  1, refCntWtd = 1   
New refCnts for V00: refCnt =  3, refCntWtd = 2   
New refCnts for V08: refCnt =  1, refCntWtd = 1   
New refCnts for V27: refCnt =  1, refCntWtd = 0.50
New refCnts for V27: refCnt =  2, refCntWtd = 1   
New refCnts for V14: refCnt =  1, refCntWtd = 1   
New refCnts for V08: refCnt =  2, refCntWtd = 2   
New refCnts for V14: refCnt =  2, refCntWtd = 1.50
New refCnts for V14: refCnt =  3, refCntWtd = 2   
New refCnts for V09: refCnt =  2, refCntWtd = 2   
New refCnts for V23: refCnt =  1, refCntWtd = 0.50
New refCnts for V23: refCnt =  2, refCntWtd = 1   
New refCnts for V19: refCnt =  1, refCntWtd = 0.50
New refCnts for V08: refCnt =  3, refCntWtd = 3   
New refCnts for V20: refCnt =  1, refCntWtd = 0.50
New refCnts for V19: refCnt =  2, refCntWtd = 1   
New refCnts for V17: refCnt =  2, refCntWtd = 1   
New refCnts for V20: refCnt =  2, refCntWtd = 1   
New refCnts for V18: refCnt =  2, refCntWtd = 1   
New refCnts for V17: refCnt =  3, refCntWtd = 2   
New refCnts for V15: refCnt =  1, refCntWtd = 1   
New refCnts for V18: refCnt =  3, refCntWtd = 2   
New refCnts for V16: refCnt =  1, refCntWtd = 1   
New refCnts for V02: refCnt =  4, refCntWtd = 8   
New refCnts for V26: refCnt =  1, refCntWtd = 2   
New refCnts for V24: refCnt =  1, refCntWtd = 2   
New refCnts for V25: refCnt =  1, refCntWtd = 2   
New refCnts for V25: refCnt =  2, refCntWtd = 4   
New refCnts for V15: refCnt =  2, refCntWtd = 2   
New refCnts for V25: refCnt =  3, refCntWtd = 6   
New refCnts for V16: refCnt =  2, refCntWtd = 2   
New refCnts for V26: refCnt =  2, refCntWtd = 4   
New refCnts for V24: refCnt =  2, refCntWtd = 4   

*** lvaComputeRefCounts -- implicit counts ***
New refCnts for V00: refCnt =  4, refCntWtd = 3   
New refCnts for V00: refCnt =  5, refCntWtd = 4   

*************** Finishing PHASE Lowering nodeinfo
Trees after Lowering nodeinfo

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)-> BB03 ( cond )                     i label target hascall newobj LIR 
BB02 [0007]  1       BB01                  0.50     [006..007)-> BB06 (always)                     i LIR 
BB03 [0008]  1       BB01                  0.50     [006..007)-> BB05 ( cond )                     i label target idxlen nullcheck LIR 
BB04 [0014]  1       BB03                  0.25     [006..007)                                     i hascall gcsafe LIR 
BB05 [0015]  2       BB03,BB04             0.50     [006..007)                                     i label target idxlen nullcheck LIR 
BB06 [0009]  2       BB02,BB05             1        [???..???)        (return)                     internal label target hascall gcsafe newobj LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..012) -> BB03 (cond), preds={} succs={BB02,BB03}
               [000234] ------------                 IL_OFFSET void   IL offset: 0x0
N002 (  2, 10) [000001] H-----------         t1 =    CNS_INT(h) long   0xd1ffab1e token $100
                                                  /--*  t1     long   
               [000257] ------------       t257 = *  PUTARG_REG long   REG rcx
                                                  /--*  t257   long   arg0 in rcx
N003 ( 16, 16) [000002] --C---------         t2 = *  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST $180
                                                  /--*  t2     ref    
N005 ( 16, 16) [000004] DA----------              *  STORE_LCL_VAR ref    V02 tmp1         d:1
N002 (  2, 10) [000018] H-----------        t18 =    CNS_INT(h) long   0xd1ffab1e token $101
                                                  /--*  t18    long   
               [000258] ------------       t258 = *  PUTARG_REG long   REG rcx
                                                  /--*  t258   long   arg0 in rcx
N003 ( 16, 16) [000019] --C---------        t19 = *  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST $181
                                                  /--*  t19    ref    
N005 ( 16, 16) [000021] DA----------              *  STORE_LCL_VAR ref    V04 tmp3         d:1
N003 (  2, 10) [000044] ------------        t44 =    CNS_INT   long   0x7ffa40fb0028 $200
                                                  /--*  t44    long   
               [000259] ------------       t259 = *  PUTARG_REG long   REG rcx
N004 (  1,  1) [000045] ------------        t45 =    CNS_INT   int    6 $42
                                                  /--*  t45    int    
               [000260] ------------       t260 = *  PUTARG_REG int    REG rdx
                                                  /--*  t259   long   arg0 in rcx
                                                  +--*  t260   int    arg1 in rdx
N005 ( 17, 18) [000046] H-CXG-------        t46 = *  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS $281
N006 (  2, 10) [000143] I-----------       t143 =    CNS_INT(h) long   0xd1ffab1e static Fseq[Value] $102
                                                  /--*  t143   long   
N007 (  4, 12) [000042] n---G-------        t42 = *  IND       ref    <l:$2c0, c:$144>
N009 (  1,  1) [000035] ------------        t35 =    LCL_VAR   ref    V04 tmp3         u:1 $181
                                                  /--*  t35    ref    
N011 (  2,  2) [000140] ------------       t140 = *  LEA(b+8)  byref 
                                                  /--*  t140   byref  
                                                  +--*  t42    ref    
               [000235] -ACXGO------              *  STOREIND  ref   
N001 (  1,  1) [000005] ------------         t5 =    LCL_VAR   ref    V02 tmp1         u:1 $180
                                                  /--*  t5     ref    
N003 (  2,  2) [000145] ------------       t145 = *  LEA(b+16) byref 
N005 (  1,  1) [000024] ------------        t24 =    LCL_VAR   ref    V04 tmp3         u:1 (last use) $181
                                                  /--*  t145   byref  
                                                  +--*  t24    ref    
               [000236] -A--GO------              *  STOREIND  ref   
N001 (  1,  1) [000029] ------------        t29 =    LCL_VAR   ref    V02 tmp1         u:1 $180
                                                  /--*  t29    ref    
N003 (  2,  2) [000147] -c----------       t147 = *  LEA(b+8)  byref 
N005 (  1,  1) [000030] ------------        t30 =    CNS_INT   ref    null $VN.Null
                                                  /--*  t147   byref  
                                                  +--*  t30    ref    
               [000237] -A--GO------              *  STOREIND  ref   
               [000238] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  1,  1) [000008] ------------         t8 =    LCL_VAR   ref    V00 arg0         u:1 $80
N002 (  1,  1) [000050] -c----------        t50 =    CNS_INT   ref    null $VN.Null
                                                  /--*  t8     ref    
                                                  +--*  t50    ref    
N003 (  3,  3) [000051] J------N----              *  NE        void   $340
N004 (  5,  5) [000052] ------------              *  JTRUE     void  

------------ BB02 [006..007) -> BB06 (always), preds={BB01} succs={BB06}
               [000239] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  1,  1) [000149] ------------       t149 =    CNS_INT   byref  0 $VN.Null
                                                  /--*  t149   byref  
N003 (  5,  4) [000150] DA----------              *  STORE_LCL_VAR byref  V21 tmp20        d:1
               [000240] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  3,  2) [000156] ------------       t156 =    LCL_VAR   byref  V21 tmp20        u:1 (last use) $VN.Null
                                                  /--*  t156   byref  
N003 (  7,  5) [000157] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:3
N004 (  1,  1) [000233] ------------       t233 =    CNS_INT   int    0 $40
                                                  /--*  t233   int    
N006 (  5,  4) [000160] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:3

------------ BB03 [006..007) -> BB05 (cond), preds={BB01} succs={BB04,BB05}
               [000241] ------------                 IL_OFFSET void   IL offset: 0x6
               [000242] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  1,  1) [000171] ------------       t171 =    LCL_VAR   ref    V00 arg0         u:1 $80
N002 (  1,  1) [000172] -c----------       t172 =    CNS_INT   long   12 field offset Fseq[_firstChar] $203
                                                  /--*  t171   ref    
                                                  +--*  t172   long   
N003 (  3,  3) [000173] ------------       t173 = *  ADD       byref  $303
                                                  /--*  t173   byref  
N005 (  7,  6) [000112] DA--G-------              *  STORE_LCL_VAR byref  V09 tmp8         d:1
               [000243] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  1,  1) [000056] ------------        t56 =    LCL_VAR   ref    V00 arg0         u:1 (last use) $80
                                                  /--*  t56    ref    
               [000256] -c----------       t256 = *  LEA(b+8)  ref   
                                                  /--*  t256   ref    
N002 (  3,  3) [000057] ---X--------        t57 = *  IND       int    $341
                                                  /--*  t57    int    
N004 (  3,  3) [000114] DA-X--------              *  STORE_LCL_VAR int    V08 tmp7         d:1
               [000244] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  2, 10) [000118] H-----------       t118 =    CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL] $106
                                                  /--*  t118   long   
N002 (  4, 12) [000119] #---G-------       t119 = *  IND       ref    $18c
                                                  /--*  t119   ref    
N004 (  8, 15) [000229] DA--G-------              *  STORE_LCL_VAR ref    V27 cse0         d:1
               [000245] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  3,  2) [000232] ------------       t232 =    LCL_VAR   ref    V27 cse0         u:1 (last use) $18c
                                                  /--*  t232   ref    
N003 (  7,  5) [000135] DA--G-------              *  STORE_LCL_VAR ref    V14 tmp13        d:1
               [000246] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  1,  1) [000088] ------------        t88 =    LCL_VAR   int    V08 tmp7         u:1 $400
N002 (  1,  1) [000089] -c----------        t89 =    CNS_INT   int    0 $40
                                                  /--*  t88    int    
                                                  +--*  t89    int    
N003 (  3,  3) [000090] J------N----              *  GE        void   $342
N004 (  5,  5) [000128] ------------              *  JTRUE     void  

------------ BB04 [006..007), preds={BB03} succs={BB05}
               [000247] ------------                 IL_OFFSET void   IL offset: 0x6
N003 (  3,  2) [000129] ------------       t129 =    LCL_VAR   ref    V14 tmp13        u:1 $18c
                                                  /--*  t129   ref    
               [000261] ------------       t261 = *  PUTARG_REG ref    REG rcx
N004 (  3,  2) [000130] ------------       t130 =    LCL_VAR   ref    V14 tmp13        u:1 (last use) $18c
                                                  /--*  t130   ref    
               [000262] ------------       t262 = *  PUTARG_REG ref    REG rdx
                                                  /--*  t261   ref    arg0 in rcx
                                                  +--*  t262   ref    arg1 in rdx
N005 ( 20, 11) [000131] --CXG-------              *  CALL      void   System.Diagnostics.Debug.Fail $VN.Void

------------ BB05 [006..007), preds={BB03,BB04} succs={BB06}
               [000248] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  3,  2) [000096] ------------        t96 =    LCL_VAR   byref  V09 tmp8         u:1 (last use) $303
                                                  /--*  t96    byref  
N003 (  7,  5) [000100] DA----------              *  STORE_LCL_VAR byref  V23 tmp22        d:1
               [000249] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  3,  2) [000178] -------N----       t178 =    LCL_VAR   byref  V23 tmp22        u:1 (last use) $303
                                                  /--*  t178   byref  
N003 (  7,  5) [000179] DA----------              *  STORE_LCL_VAR byref  V19 tmp18        d:1
               [000250] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  1,  1) [000108] ------------       t108 =    LCL_VAR   int    V08 tmp7         u:1 (last use) $400
                                                  /--*  t108   int    
N003 (  5,  4) [000110] DA----------              *  STORE_LCL_VAR int    V20 tmp19        d:1
               [000251] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  3,  2) [000181] ------------       t181 =    LCL_VAR   byref  V19 tmp18        u:1 (last use) $303
                                                  /--*  t181   byref  
N003 (  7,  5) [000182] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:2
N004 (  3,  2) [000184] ------------       t184 =    LCL_VAR   int    V20 tmp19        u:1 (last use) $400
                                                  /--*  t184   int    
N006 (  7,  5) [000185] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:2

------------ BB06 [???..???) (return), preds={BB02,BB05} succs={}
N001 (  0,  0) [000226] ------------       t226 =    PHI_ARG   int    V18 tmp17        u:3 $40
N002 (  0,  0) [000224] ------------       t224 =    PHI_ARG   int    V18 tmp17        u:2 $400
                                                  /--*  t226   int    
                                                  +--*  t224   int    
N003 (  0,  0) [000222] ------------       t222 = *  PHI       int   
                                                  /--*  t222   int    
N005 (  0,  0) [000223] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:1
N001 (  0,  0) [000227] ------------       t227 =    PHI_ARG   byref  V17 tmp16        u:3 $VN.Null
N002 (  0,  0) [000225] ------------       t225 =    PHI_ARG   byref  V17 tmp16        u:2 $303
                                                  /--*  t227   byref  
                                                  +--*  t225   byref  
N003 (  0,  0) [000219] ------------       t219 = *  PHI       byref 
                                                  /--*  t219   byref  
N005 (  0,  0) [000220] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:1
N001 (  3,  2) [000188] ------------       t188 =    LCL_VAR   byref  V17 tmp16        u:1 (last use) $480
                                                  /--*  t188   byref  
N003 (  7,  5) [000189] DA----------              *  STORE_LCL_VAR byref  V15 tmp14        d:1
N004 (  3,  2) [000191] ------------       t191 =    LCL_VAR   int    V18 tmp17        u:1 (last use) $440
                                                  /--*  t191   int    
N006 (  7,  5) [000192] DA----------              *  STORE_LCL_VAR int    V16 tmp15        d:1
N001 (  1,  1) [000007] ------------         t7 =    LCL_VAR   ref    V02 tmp1         u:1 (last use) $180
                                                  /--*  t7     ref    
N003 (  1,  3) [000214] DA--------L-              *  STORE_LCL_VAR ref    V26 tmp25        d:1
N004 (  3,  2) [000198] -------N----       t198 =    LCL_VAR_ADDR byref  V24 tmp23        
                                                  /--*  t198   byref  
N007 (  3,  3) [000200] DA----------              *  STORE_LCL_VAR byref  V25 tmp24        d:1
N008 (  1,  1) [000201] ------------       t201 =    LCL_VAR   byref  V25 tmp24        u:1 Zero Fseq[_pointer] $3c7
N010 (  3,  2) [000203] -------N----       t203 =    LCL_VAR   byref  V15 tmp14        u:1 (last use) $480
                                                  /--*  t201   byref  
                                                  +--*  t203   byref  
               [000252] -A----------              *  STOREIND  byref 
N013 (  1,  1) [000206] ------------       t206 =    LCL_VAR   byref  V25 tmp24        u:1 (last use) $3c7
                                                  /--*  t206   byref  
N015 (  2,  2) [000208] -c----------       t208 = *  LEA(b+8)  byref 
N017 (  3,  2) [000210] -------N----       t210 =    LCL_VAR   int    V16 tmp15        u:1 (last use) $440
                                                  /--*  t208   byref  
                                                  +--*  t210   int    
               [000253] -A--------L-              *  STOREIND  int   
N020 (  1,  1) [000215] ------------       t215 =    LCL_VAR   ref    V26 tmp25        u:1 (last use) $180
                                                  /--*  t215   ref    
               [000263] ------------       t263 = *  PUTARG_REG ref    REG rcx
N021 (  3,  2) [000216] -------N----       t216 =    LCL_VAR_ADDR byref  V24 tmp23        
                                                  /--*  t216   byref  
               [000264] ------------       t264 = *  PUTARG_REG byref  REG rdx
                                                  /--*  t263   ref    this in rcx
                                                  +--*  t264   byref  arg1 in rdx
N023 ( 40, 30) [000011] --CXG-------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer.TokenizeLine $VN.Void
               [000254] ------------                 IL_OFFSET void   IL offset: 0x11
N001 (  0,  0) [000017] ------------                 RETURN    void   $382

-------------------------------------------------------------------------------------------------------------------
*************** In fgDebugCheckBBlist
Trees before Calculate stack level slots

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)-> BB03 ( cond )                     i label target hascall newobj LIR 
BB02 [0007]  1       BB01                  0.50     [006..007)-> BB06 (always)                     i LIR 
BB03 [0008]  1       BB01                  0.50     [006..007)-> BB05 ( cond )                     i label target idxlen nullcheck LIR 
BB04 [0014]  1       BB03                  0.25     [006..007)                                     i hascall gcsafe LIR 
BB05 [0015]  2       BB03,BB04             0.50     [006..007)                                     i label target idxlen nullcheck LIR 
BB06 [0009]  2       BB02,BB05             1        [???..???)        (return)                     internal label target hascall gcsafe newobj LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..012) -> BB03 (cond), preds={} succs={BB02,BB03}
               [000234] ------------                 IL_OFFSET void   IL offset: 0x0
N002 (  2, 10) [000001] H-----------         t1 =    CNS_INT(h) long   0xd1ffab1e token $100
                                                  /--*  t1     long   
               [000257] ------------       t257 = *  PUTARG_REG long   REG rcx
                                                  /--*  t257   long   arg0 in rcx
N003 ( 16, 16) [000002] --C---------         t2 = *  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST $180
                                                  /--*  t2     ref    
N005 ( 16, 16) [000004] DA----------              *  STORE_LCL_VAR ref    V02 tmp1         d:1
N002 (  2, 10) [000018] H-----------        t18 =    CNS_INT(h) long   0xd1ffab1e token $101
                                                  /--*  t18    long   
               [000258] ------------       t258 = *  PUTARG_REG long   REG rcx
                                                  /--*  t258   long   arg0 in rcx
N003 ( 16, 16) [000019] --C---------        t19 = *  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST $181
                                                  /--*  t19    ref    
N005 ( 16, 16) [000021] DA----------              *  STORE_LCL_VAR ref    V04 tmp3         d:1
N003 (  2, 10) [000044] ------------        t44 =    CNS_INT   long   0x7ffa40fb0028 $200
                                                  /--*  t44    long   
               [000259] ------------       t259 = *  PUTARG_REG long   REG rcx
N004 (  1,  1) [000045] ------------        t45 =    CNS_INT   int    6 $42
                                                  /--*  t45    int    
               [000260] ------------       t260 = *  PUTARG_REG int    REG rdx
                                                  /--*  t259   long   arg0 in rcx
                                                  +--*  t260   int    arg1 in rdx
N005 ( 17, 18) [000046] H-CXG-------        t46 = *  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS $281
N006 (  2, 10) [000143] I-----------       t143 =    CNS_INT(h) long   0xd1ffab1e static Fseq[Value] $102
                                                  /--*  t143   long   
N007 (  4, 12) [000042] n---G-------        t42 = *  IND       ref    <l:$2c0, c:$144>
N009 (  1,  1) [000035] ------------        t35 =    LCL_VAR   ref    V04 tmp3         u:1 $181
                                                  /--*  t35    ref    
N011 (  2,  2) [000140] ------------       t140 = *  LEA(b+8)  byref 
                                                  /--*  t140   byref  
                                                  +--*  t42    ref    
               [000235] -ACXGO------              *  STOREIND  ref   
N001 (  1,  1) [000005] ------------         t5 =    LCL_VAR   ref    V02 tmp1         u:1 $180
                                                  /--*  t5     ref    
N003 (  2,  2) [000145] ------------       t145 = *  LEA(b+16) byref 
N005 (  1,  1) [000024] ------------        t24 =    LCL_VAR   ref    V04 tmp3         u:1 (last use) $181
                                                  /--*  t145   byref  
                                                  +--*  t24    ref    
               [000236] -A--GO------              *  STOREIND  ref   
N001 (  1,  1) [000029] ------------        t29 =    LCL_VAR   ref    V02 tmp1         u:1 $180
                                                  /--*  t29    ref    
N003 (  2,  2) [000147] -c----------       t147 = *  LEA(b+8)  byref 
N005 (  1,  1) [000030] ------------        t30 =    CNS_INT   ref    null $VN.Null
                                                  /--*  t147   byref  
                                                  +--*  t30    ref    
               [000237] -A--GO------              *  STOREIND  ref   
               [000238] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  1,  1) [000008] ------------         t8 =    LCL_VAR   ref    V00 arg0         u:1 $80
N002 (  1,  1) [000050] -c----------        t50 =    CNS_INT   ref    null $VN.Null
                                                  /--*  t8     ref    
                                                  +--*  t50    ref    
N003 (  3,  3) [000051] J------N----              *  NE        void   $340
N004 (  5,  5) [000052] ------------              *  JTRUE     void  

------------ BB02 [006..007) -> BB06 (always), preds={BB01} succs={BB06}
               [000239] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  1,  1) [000149] ------------       t149 =    CNS_INT   byref  0 $VN.Null
                                                  /--*  t149   byref  
N003 (  5,  4) [000150] DA----------              *  STORE_LCL_VAR byref  V21 tmp20        d:1
               [000240] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  3,  2) [000156] ------------       t156 =    LCL_VAR   byref  V21 tmp20        u:1 (last use) $VN.Null
                                                  /--*  t156   byref  
N003 (  7,  5) [000157] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:3
N004 (  1,  1) [000233] ------------       t233 =    CNS_INT   int    0 $40
                                                  /--*  t233   int    
N006 (  5,  4) [000160] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:3

------------ BB03 [006..007) -> BB05 (cond), preds={BB01} succs={BB04,BB05}
               [000241] ------------                 IL_OFFSET void   IL offset: 0x6
               [000242] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  1,  1) [000171] ------------       t171 =    LCL_VAR   ref    V00 arg0         u:1 $80
N002 (  1,  1) [000172] -c----------       t172 =    CNS_INT   long   12 field offset Fseq[_firstChar] $203
                                                  /--*  t171   ref    
                                                  +--*  t172   long   
N003 (  3,  3) [000173] ------------       t173 = *  ADD       byref  $303
                                                  /--*  t173   byref  
N005 (  7,  6) [000112] DA--G-------              *  STORE_LCL_VAR byref  V09 tmp8         d:1
               [000243] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  1,  1) [000056] ------------        t56 =    LCL_VAR   ref    V00 arg0         u:1 (last use) $80
                                                  /--*  t56    ref    
               [000256] -c----------       t256 = *  LEA(b+8)  ref   
                                                  /--*  t256   ref    
N002 (  3,  3) [000057] ---X--------        t57 = *  IND       int    $341
                                                  /--*  t57    int    
N004 (  3,  3) [000114] DA-X--------              *  STORE_LCL_VAR int    V08 tmp7         d:1
               [000244] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  2, 10) [000118] H-----------       t118 =    CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL] $106
                                                  /--*  t118   long   
N002 (  4, 12) [000119] #---G-------       t119 = *  IND       ref    $18c
                                                  /--*  t119   ref    
N004 (  8, 15) [000229] DA--G-------              *  STORE_LCL_VAR ref    V27 cse0         d:1
               [000245] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  3,  2) [000232] ------------       t232 =    LCL_VAR   ref    V27 cse0         u:1 (last use) $18c
                                                  /--*  t232   ref    
N003 (  7,  5) [000135] DA--G-------              *  STORE_LCL_VAR ref    V14 tmp13        d:1
               [000246] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  1,  1) [000088] ------------        t88 =    LCL_VAR   int    V08 tmp7         u:1 $400
N002 (  1,  1) [000089] -c----------        t89 =    CNS_INT   int    0 $40
                                                  /--*  t88    int    
                                                  +--*  t89    int    
N003 (  3,  3) [000090] J------N----              *  GE        void   $342
N004 (  5,  5) [000128] ------------              *  JTRUE     void  

------------ BB04 [006..007), preds={BB03} succs={BB05}
               [000247] ------------                 IL_OFFSET void   IL offset: 0x6
N003 (  3,  2) [000129] ------------       t129 =    LCL_VAR   ref    V14 tmp13        u:1 $18c
                                                  /--*  t129   ref    
               [000261] ------------       t261 = *  PUTARG_REG ref    REG rcx
N004 (  3,  2) [000130] ------------       t130 =    LCL_VAR   ref    V14 tmp13        u:1 (last use) $18c
                                                  /--*  t130   ref    
               [000262] ------------       t262 = *  PUTARG_REG ref    REG rdx
                                                  /--*  t261   ref    arg0 in rcx
                                                  +--*  t262   ref    arg1 in rdx
N005 ( 20, 11) [000131] --CXG-------              *  CALL      void   System.Diagnostics.Debug.Fail $VN.Void

------------ BB05 [006..007), preds={BB03,BB04} succs={BB06}
               [000248] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  3,  2) [000096] ------------        t96 =    LCL_VAR   byref  V09 tmp8         u:1 (last use) $303
                                                  /--*  t96    byref  
N003 (  7,  5) [000100] DA----------              *  STORE_LCL_VAR byref  V23 tmp22        d:1
               [000249] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  3,  2) [000178] -------N----       t178 =    LCL_VAR   byref  V23 tmp22        u:1 (last use) $303
                                                  /--*  t178   byref  
N003 (  7,  5) [000179] DA----------              *  STORE_LCL_VAR byref  V19 tmp18        d:1
               [000250] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  1,  1) [000108] ------------       t108 =    LCL_VAR   int    V08 tmp7         u:1 (last use) $400
                                                  /--*  t108   int    
N003 (  5,  4) [000110] DA----------              *  STORE_LCL_VAR int    V20 tmp19        d:1
               [000251] ------------                 IL_OFFSET void   IL offset: 0x6
N001 (  3,  2) [000181] ------------       t181 =    LCL_VAR   byref  V19 tmp18        u:1 (last use) $303
                                                  /--*  t181   byref  
N003 (  7,  5) [000182] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:2
N004 (  3,  2) [000184] ------------       t184 =    LCL_VAR   int    V20 tmp19        u:1 (last use) $400
                                                  /--*  t184   int    
N006 (  7,  5) [000185] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:2

------------ BB06 [???..???) (return), preds={BB02,BB05} succs={}
N001 (  0,  0) [000226] ------------       t226 =    PHI_ARG   int    V18 tmp17        u:3 $40
N002 (  0,  0) [000224] ------------       t224 =    PHI_ARG   int    V18 tmp17        u:2 $400
                                                  /--*  t226   int    
                                                  +--*  t224   int    
N003 (  0,  0) [000222] ------------       t222 = *  PHI       int   
                                                  /--*  t222   int    
N005 (  0,  0) [000223] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:1
N001 (  0,  0) [000227] ------------       t227 =    PHI_ARG   byref  V17 tmp16        u:3 $VN.Null
N002 (  0,  0) [000225] ------------       t225 =    PHI_ARG   byref  V17 tmp16        u:2 $303
                                                  /--*  t227   byref  
                                                  +--*  t225   byref  
N003 (  0,  0) [000219] ------------       t219 = *  PHI       byref 
                                                  /--*  t219   byref  
N005 (  0,  0) [000220] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:1
N001 (  3,  2) [000188] ------------       t188 =    LCL_VAR   byref  V17 tmp16        u:1 (last use) $480
                                                  /--*  t188   byref  
N003 (  7,  5) [000189] DA----------              *  STORE_LCL_VAR byref  V15 tmp14        d:1
N004 (  3,  2) [000191] ------------       t191 =    LCL_VAR   int    V18 tmp17        u:1 (last use) $440
                                                  /--*  t191   int    
N006 (  7,  5) [000192] DA----------              *  STORE_LCL_VAR int    V16 tmp15        d:1
N001 (  1,  1) [000007] ------------         t7 =    LCL_VAR   ref    V02 tmp1         u:1 (last use) $180
                                                  /--*  t7     ref    
N003 (  1,  3) [000214] DA--------L-              *  STORE_LCL_VAR ref    V26 tmp25        d:1
N004 (  3,  2) [000198] -------N----       t198 =    LCL_VAR_ADDR byref  V24 tmp23        
                                                  /--*  t198   byref  
N007 (  3,  3) [000200] DA----------              *  STORE_LCL_VAR byref  V25 tmp24        d:1
N008 (  1,  1) [000201] ------------       t201 =    LCL_VAR   byref  V25 tmp24        u:1 Zero Fseq[_pointer] $3c7
N010 (  3,  2) [000203] -------N----       t203 =    LCL_VAR   byref  V15 tmp14        u:1 (last use) $480
                                                  /--*  t201   byref  
                                                  +--*  t203   byref  
               [000252] -A----------              *  STOREIND  byref 
N013 (  1,  1) [000206] ------------       t206 =    LCL_VAR   byref  V25 tmp24        u:1 (last use) $3c7
                                                  /--*  t206   byref  
N015 (  2,  2) [000208] -c----------       t208 = *  LEA(b+8)  byref 
N017 (  3,  2) [000210] -------N----       t210 =    LCL_VAR   int    V16 tmp15        u:1 (last use) $440
                                                  /--*  t208   byref  
                                                  +--*  t210   int    
               [000253] -A--------L-              *  STOREIND  int   
N020 (  1,  1) [000215] ------------       t215 =    LCL_VAR   ref    V26 tmp25        u:1 (last use) $180
                                                  /--*  t215   ref    
               [000263] ------------       t263 = *  PUTARG_REG ref    REG rcx
N021 (  3,  2) [000216] -------N----       t216 =    LCL_VAR_ADDR byref  V24 tmp23        
                                                  /--*  t216   byref  
               [000264] ------------       t264 = *  PUTARG_REG byref  REG rdx
                                                  /--*  t263   ref    this in rcx
                                                  +--*  t264   byref  arg1 in rdx
N023 ( 40, 30) [000011] --CXG-------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer.TokenizeLine $VN.Void
               [000254] ------------                 IL_OFFSET void   IL offset: 0x11
N001 (  0,  0) [000017] ------------                 RETURN    void   $382

-------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Calculate stack level slots

*************** Finishing PHASE Calculate stack level slots [no changes]

*************** Starting PHASE Linear scan register alloc
Clearing modified regs.

buildIntervals ========

-----------------
LIVENESS:
-----------------
BB01 use def in out
{V00}
{V02 V04}
{V00}
{V00 V02}
BB02 use def in out
{}
{V17 V18 V21 V22}
{V02}
{V02 V17 V18}
BB03 use def in out
{V00}
{V08 V09 V13 V14 V27}
{V00 V02}
{V02 V08 V09 V14}
BB04 use def in out
{V14}
{}
{V02 V08 V09 V14}
{V02 V08 V09}
BB05 use def in out
{V08 V09}
{V17 V18 V19 V20 V23}
{V02 V08 V09}
{V02 V17 V18}
BB06 use def in out
{V02 V17 V18}
{V15 V16 V25 V26}
{V02 V17 V18}
{}
Interval  0: ref RefPositions {} physReg:NA Preferences=[allInt]
  Interval  0: (V00) ref RefPositions {} physReg:NA Preferences=[allInt]
Interval  1: ref RefPositions {} physReg:NA Preferences=[allInt]
  Interval  1: (V02) ref RefPositions {} physReg:NA Preferences=[allInt]
Interval  2: ref RefPositions {} physReg:NA Preferences=[allInt]
  Interval  2: (V04) ref RefPositions {} physReg:NA Preferences=[allInt]
Interval  3: int RefPositions {} physReg:NA Preferences=[allInt]
  Interval  3: (V08) int RefPositions {} physReg:NA Preferences=[allInt]
Interval  4: byref RefPositions {} physReg:NA Preferences=[allInt]
  Interval  4: (V09) byref RefPositions {} physReg:NA Preferences=[allInt]
Interval  5: ref RefPositions {} physReg:NA Preferences=[allInt]
  Interval  5: (V14) ref RefPositions {} physReg:NA Preferences=[allInt]
Interval  6: byref RefPositions {} physReg:NA Preferences=[allInt]
  Interval  6: (V15) byref (field) RefPositions {} physReg:NA Preferences=[allInt]
Interval  7: int RefPositions {} physReg:NA Preferences=[allInt]
  Interval  7: (V16) int (field) RefPositions {} physReg:NA Preferences=[allInt]
Interval  8: byref RefPositions {} physReg:NA Preferences=[allInt]
  Interval  8: (V17) byref (field) RefPositions {} physReg:NA Preferences=[allInt]
Interval  9: int RefPositions {} physReg:NA Preferences=[allInt]
  Interval  9: (V18) int (field) RefPositions {} physReg:NA Preferences=[allInt]
Interval 10: byref RefPositions {} physReg:NA Preferences=[allInt]
  Interval 10: (V19) byref (field) RefPositions {} physReg:NA Preferences=[allInt]
Interval 11: int RefPositions {} physReg:NA Preferences=[allInt]
  Interval 11: (V20) int (field) RefPositions {} physReg:NA Preferences=[allInt]
Interval 12: byref RefPositions {} physReg:NA Preferences=[allInt]
  Interval 12: (V21) byref (field) RefPositions {} physReg:NA Preferences=[allInt]
Interval 13: byref RefPositions {} physReg:NA Preferences=[allInt]
  Interval 13: (V23) byref (field) RefPositions {} physReg:NA Preferences=[allInt]
Interval 14: byref RefPositions {} physReg:NA Preferences=[allInt]
  Interval 14: (V25) byref RefPositions {} physReg:NA Preferences=[allInt]
Interval 15: ref RefPositions {} physReg:NA Preferences=[allInt]
  Interval 15: (V26) ref RefPositions {} physReg:NA Preferences=[allInt]
Interval 16: ref RefPositions {} physReg:NA Preferences=[allInt]
  Interval 16: (V27) ref RefPositions {} physReg:NA Preferences=[allInt]

FP callee save candidate vars: None

floatVarCount = 0; hasLoops = 0, singleExit = 1
TUPLE STYLE DUMP BEFORE LSRA
LSRA Block Sequence: BB01(  1   ) 
BB02(  0.50) 
BB03(  0.50) 
BB04(  0.25) 
BB05(  0.50) 
BB06(  1   ) 

BB01 [000..012) -> BB03 (cond), preds={} succs={BB02,BB03}
=====
  N000.                    IL_OFFSET IL offset: 0x0
  N002. t1              =  CNS_INT(h) 0xd1ffab1e token
  N000. t257            =  PUTARG_REG; t1
  N003. t2              =  CALL help; t257
  N005.                    V02(t4); t2
  N002. t18             =  CNS_INT(h) 0xd1ffab1e token
  N000. t258            =  PUTARG_REG; t18
  N003. t19             =  CALL help; t258
  N005.                    V04(t21); t19
  N003. t44             =  CNS_INT   0x7ffa40fb0028
  N000. t259            =  PUTARG_REG; t44
  N004. t45             =  CNS_INT   6
  N000. t260            =  PUTARG_REG; t45
  N005.                    CALL help; t259,t260
  N006. t143            =  CNS_INT(h) 0xd1ffab1e static Fseq[Value]
  N007. t42             =  IND      ; t143
  N009.                    V04(t35)
  N011. t140            =  LEA(b+8) ; t35
  N000.                    STOREIND ; t140,t42
  N001.                    V02(t5)
  N003. t145            =  LEA(b+16); t5
  N005.                    V04(t24*)
  N000.                    STOREIND ; t145,t24*
  N001.                    V02(t29)
  N003. t147            =  LEA(b+8) ; t29
  N005. t30             =  CNS_INT   null
  N000.                    STOREIND ; t147,t30
  N000.                    IL_OFFSET IL offset: 0x6
  N001.                    V00(t8)
  N002.                    CNS_INT   null
  N003.                    NE       ; t8
  N004.                    JTRUE    

BB02 [006..007) -> BB06 (always), preds={BB01} succs={BB06}
=====
  N000.                    IL_OFFSET IL offset: 0x6
  N001. t149            =  CNS_INT   0
  N003.                    V21(t150); t149
  N000.                    IL_OFFSET IL offset: 0x6
  N001.                    V21(t156*)
  N003.                    V17(t157); t156*
  N004. t233            =  CNS_INT   0
  N006.                    V18(t160); t233

BB03 [006..007) -> BB05 (cond), preds={BB01} succs={BB04,BB05}
=====
  N000.                    IL_OFFSET IL offset: 0x6
  N000.                    IL_OFFSET IL offset: 0x6
  N001.                    V00(t171)
  N002.                    CNS_INT   12 field offset Fseq[_firstChar]
  N003. t173            =  ADD      ; t171
  N005.                    V09(t112); t173
  N000.                    IL_OFFSET IL offset: 0x6
  N001.                    V00(t56*)
  N000. t256            =  LEA(b+8) ; t56*
  N002. t57             =  IND      ; t256
  N004.                    V08(t114); t57
  N000.                    IL_OFFSET IL offset: 0x6
  N001. t118            =  CNS_INT(h) 0xD1FFAB1E [ICON_STR_HDL]
  N002. t119            =  IND      ; t118
  N004.                    V27(t229); t119
  N000.                    IL_OFFSET IL offset: 0x6
  N001.                    V27(t232*)
  N003.                    V14(t135); t232*
  N000.                    IL_OFFSET IL offset: 0x6
  N001.                    V08(t88)
  N002.                    CNS_INT   0
  N003.                    GE       ; t88
  N004.                    JTRUE    

BB04 [006..007), preds={BB03} succs={BB05}
=====
  N000.                    IL_OFFSET IL offset: 0x6
  N003.                    V14(t129)
  N000. t261            =  PUTARG_REG; t129
  N004.                    V14(t130*)
  N000. t262            =  PUTARG_REG; t130*
  N005.                    CALL     ; t261,t262

BB05 [006..007), preds={BB03,BB04} succs={BB06}
=====
  N000.                    IL_OFFSET IL offset: 0x6
  N001.                    V09(t96*)
  N003.                    V23(t100); t96*
  N000.                    IL_OFFSET IL offset: 0x6
  N001.                    V23(t178*)
  N003.                    V19(t179); t178*
  N000.                    IL_OFFSET IL offset: 0x6
  N001.                    V08(t108*)
  N003.                    V20(t110); t108*
  N000.                    IL_OFFSET IL offset: 0x6
  N001.                    V19(t181*)
  N003.                    V17(t182); t181*
  N004.                    V20(t184*)
  N006.                    V18(t185); t184*

BB06 [???..???) (return), preds={BB02,BB05} succs={}
=====
  N001.                    V17(t188*)
  N003.                    V15(t189); t188*
  N004.                    V18(t191*)
  N006.                    V16(t192); t191*
  N001.                    V02(t7*)
  N003.                    V26(t214); t7*
  N004. t198            =  LCL_VAR_ADDR V24 tmp23        
  N007.                    V25(t200); t198
  N008.                    V25(t201)
  N010.                    V15(t203*)
  N000.                    STOREIND ; t201,t203*
  N013.                    V25(t206*)
  N015. t208            =  LEA(b+8) ; t206*
  N017.                    V16(t210*)
  N000.                    STOREIND ; t208,t210*
  N020.                    V26(t215*)
  N000. t263            =  PUTARG_REG; t215*
  N021. t216            =  LCL_VAR_ADDR V24 tmp23        
  N000. t264            =  PUTARG_REG; t216
  N023.                    CALL     ; t263,t264
  N000.                    IL_OFFSET IL offset: 0x11
  N001.                    RETURN   




buildIntervals second part ========
Int arg V00 in reg rcx
<RefPosition #0   @0   RefTypeParamDef <Ivl:0 V00>  BB00 regmask=[rcx] minReg=1 fixed>

NEW BLOCK BB01
<RefPosition #1   @1   RefTypeBB  BB01 regmask=[] minReg=1>

DefList: {  }
N003 (???,???) [000234] ------------              *  IL_OFFSET void   IL offset: 0x0 REG NA

DefList: {  }
N005 (  2, 10) [000001] H-----------              *  CNS_INT(h) long   0xd1ffab1e token REG NA $100
Interval 17: long RefPositions {} physReg:NA Preferences=[allInt]
<RefPosition #2   @6   RefTypeDef <Ivl:17> CNS_INT BB01 regmask=[allInt] minReg=1>

DefList: { N005.t1. CNS_INT }
N007 (???,???) [000257] ------------              *  PUTARG_REG long   REG rcx
<RefPosition #3   @7   RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #4   @7   RefTypeUse <Ivl:17>  BB01 regmask=[rcx] minReg=1 last fixed>
Interval 18: long RefPositions {} physReg:NA Preferences=[allInt]
<RefPosition #5   @8   RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #6   @8   RefTypeDef <Ivl:18> PUTARG_REG BB01 regmask=[rcx] minReg=1 fixed>

DefList: { N007.t257. PUTARG_REG }
N009 ( 16, 16) [000002] --C---------              *  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST REG NA $180
<RefPosition #7   @9   RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #8   @9   RefTypeUse <Ivl:18>  BB01 regmask=[rcx] minReg=1 last fixed>
<RefPosition #9   @10  RefTypeKill <Reg:rax>  BB01 regmask=[rax] minReg=1>
<RefPosition #10  @10  RefTypeKill <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #11  @10  RefTypeKill <Reg:rdx>  BB01 regmask=[rdx] minReg=1>
<RefPosition #12  @10  RefTypeKill <Reg:r8 >  BB01 regmask=[r8] minReg=1>
<RefPosition #13  @10  RefTypeKill <Reg:r9 >  BB01 regmask=[r9] minReg=1>
<RefPosition #14  @10  RefTypeKill <Reg:r10>  BB01 regmask=[r10] minReg=1>
<RefPosition #15  @10  RefTypeKill <Reg:r11>  BB01 regmask=[r11] minReg=1>
Interval 19: ref RefPositions {} physReg:NA Preferences=[allInt]
<RefPosition #16  @10  RefTypeFixedReg <Reg:rax>  BB01 regmask=[rax] minReg=1>
<RefPosition #17  @10  RefTypeDef <Ivl:19> CALL BB01 regmask=[rax] minReg=1 fixed>

DefList: { N009.t2. CALL }
N011 ( 16, 16) [000004] DA----------              *  STORE_LCL_VAR ref    V02 tmp1         d:1 NA REG NA
<RefPosition #18  @11  RefTypeUse <Ivl:19>  BB01 regmask=[allInt] minReg=1 last>
Assigning related <V02/L1> to <I19>
<RefPosition #19  @12  RefTypeDef <Ivl:1 V02> STORE_LCL_VAR BB01 regmask=[allInt] minReg=1 last>

DefList: {  }
N013 (  2, 10) [000018] H-----------              *  CNS_INT(h) long   0xd1ffab1e token REG NA $101
Interval 20: long RefPositions {} physReg:NA Preferences=[allInt]
<RefPosition #20  @14  RefTypeDef <Ivl:20> CNS_INT BB01 regmask=[allInt] minReg=1>

DefList: { N013.t18. CNS_INT }
N015 (???,???) [000258] ------------              *  PUTARG_REG long   REG rcx
<RefPosition #21  @15  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #22  @15  RefTypeUse <Ivl:20>  BB01 regmask=[rcx] minReg=1 last fixed>
Interval 21: long RefPositions {} physReg:NA Preferences=[allInt]
<RefPosition #23  @16  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #24  @16  RefTypeDef <Ivl:21> PUTARG_REG BB01 regmask=[rcx] minReg=1 fixed>

DefList: { N015.t258. PUTARG_REG }
N017 ( 16, 16) [000019] --C---------              *  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST REG NA $181
<RefPosition #25  @17  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #26  @17  RefTypeUse <Ivl:21>  BB01 regmask=[rcx] minReg=1 last fixed>
<RefPosition #27  @18  RefTypeKill <Reg:rax>  BB01 regmask=[rax] minReg=1>
<RefPosition #28  @18  RefTypeKill <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #29  @18  RefTypeKill <Reg:rdx>  BB01 regmask=[rdx] minReg=1>
<RefPosition #30  @18  RefTypeKill <Reg:r8 >  BB01 regmask=[r8] minReg=1>
<RefPosition #31  @18  RefTypeKill <Reg:r9 >  BB01 regmask=[r9] minReg=1>
<RefPosition #32  @18  RefTypeKill <Reg:r10>  BB01 regmask=[r10] minReg=1>
<RefPosition #33  @18  RefTypeKill <Reg:r11>  BB01 regmask=[r11] minReg=1>
Interval 22: ref RefPositions {} physReg:NA Preferences=[allInt]
<RefPosition #34  @18  RefTypeFixedReg <Reg:rax>  BB01 regmask=[rax] minReg=1>
<RefPosition #35  @18  RefTypeDef <Ivl:22> CALL BB01 regmask=[rax] minReg=1 fixed>

DefList: { N017.t19. CALL }
N019 ( 16, 16) [000021] DA----------              *  STORE_LCL_VAR ref    V04 tmp3         d:1 NA REG NA
<RefPosition #36  @19  RefTypeUse <Ivl:22>  BB01 regmask=[allInt] minReg=1 last>
Assigning related <V04/L2> to <I22>
<RefPosition #37  @20  RefTypeDef <Ivl:2 V04> STORE_LCL_VAR BB01 regmask=[allInt] minReg=1 last>

DefList: {  }
N021 (  2, 10) [000044] ------------              *  CNS_INT   long   0x7ffa40fb0028 REG NA $200
Interval 23: long RefPositions {} physReg:NA Preferences=[allInt]
<RefPosition #38  @22  RefTypeDef <Ivl:23> CNS_INT BB01 regmask=[allInt] minReg=1>

DefList: { N021.t44. CNS_INT }
N023 (???,???) [000259] ------------              *  PUTARG_REG long   REG rcx
<RefPosition #39  @23  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #40  @23  RefTypeUse <Ivl:23>  BB01 regmask=[rcx] minReg=1 last fixed>
Interval 24: long RefPositions {} physReg:NA Preferences=[allInt]
<RefPosition #41  @24  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #42  @24  RefTypeDef <Ivl:24> PUTARG_REG BB01 regmask=[rcx] minReg=1 fixed>

DefList: { N023.t259. PUTARG_REG }
N025 (  1,  1) [000045] ------------              *  CNS_INT   int    6 REG NA $42
Interval 25: int RefPositions {} physReg:NA Preferences=[allInt]
<RefPosition #43  @26  RefTypeDef <Ivl:25> CNS_INT BB01 regmask=[allInt] minReg=1>

DefList: { N023.t259. PUTARG_REG; N025.t45. CNS_INT }
N027 (???,???) [000260] ------------              *  PUTARG_REG int    REG rdx
<RefPosition #44  @27  RefTypeFixedReg <Reg:rdx>  BB01 regmask=[rdx] minReg=1>
<RefPosition #45  @27  RefTypeUse <Ivl:25>  BB01 regmask=[rdx] minReg=1 last fixed>
Interval 26: int RefPositions {} physReg:NA Preferences=[allInt]
<RefPosition #46  @28  RefTypeFixedReg <Reg:rdx>  BB01 regmask=[rdx] minReg=1>
<RefPosition #47  @28  RefTypeDef <Ivl:26> PUTARG_REG BB01 regmask=[rdx] minReg=1 fixed>

DefList: { N023.t259. PUTARG_REG; N027.t260. PUTARG_REG }
N029 ( 17, 18) [000046] H-CXG-------              *  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS REG NA $281
<RefPosition #48  @29  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #49  @29  RefTypeUse <Ivl:24>  BB01 regmask=[rcx] minReg=1 last fixed>
<RefPosition #50  @29  RefTypeFixedReg <Reg:rdx>  BB01 regmask=[rdx] minReg=1>
<RefPosition #51  @29  RefTypeUse <Ivl:26>  BB01 regmask=[rdx] minReg=1 last fixed>
<RefPosition #52  @30  RefTypeKill <Reg:rax>  BB01 regmask=[rax] minReg=1>
<RefPosition #53  @30  RefTypeKill <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #54  @30  RefTypeKill <Reg:rdx>  BB01 regmask=[rdx] minReg=1>
<RefPosition #55  @30  RefTypeKill <Reg:r8 >  BB01 regmask=[r8] minReg=1>
<RefPosition #56  @30  RefTypeKill <Reg:r9 >  BB01 regmask=[r9] minReg=1>
<RefPosition #57  @30  RefTypeKill <Reg:r10>  BB01 regmask=[r10] minReg=1>
<RefPosition #58  @30  RefTypeKill <Reg:r11>  BB01 regmask=[r11] minReg=1>
Interval 27: long RefPositions {} physReg:NA Preferences=[allInt]
<RefPosition #59  @30  RefTypeFixedReg <Reg:rax>  BB01 regmask=[rax] minReg=1>
<RefPosition #60  @30  RefTypeDef <Ivl:27> CALL BB01 regmask=[rax] minReg=1 fixed>

DefList: {  }
N031 (  2, 10) [000143] I-----------              *  CNS_INT(h) long   0xd1ffab1e static Fseq[Value] REG NA $102
Interval 28: long RefPositions {} physReg:NA Preferences=[allInt]
<RefPosition #61  @32  RefTypeDef <Ivl:28> CNS_INT BB01 regmask=[allInt] minReg=1>

DefList: { N031.t143. CNS_INT }
N033 (  4, 12) [000042] n---G-------              *  IND       ref    REG NA <l:$2c0, c:$144>
<RefPosition #62  @33  RefTypeUse <Ivl:28>  BB01 regmask=[allInt] minReg=1 last>
Interval 29: ref RefPositions {} physReg:NA Preferences=[allInt]
<RefPosition #63  @34  RefTypeDef <Ivl:29> IND BB01 regmask=[allInt] minReg=1>

DefList: { N033.t42. IND }
N035 (  1,  1) [000035] ------------              *  LCL_VAR   ref    V04 tmp3         u:1 NA REG NA $181

DefList: { N033.t42. IND }
N037 (  2,  2) [000140] ------------              *  LEA(b+8)  byref  REG NA
<RefPosition #64  @37  RefTypeUse <Ivl:2 V04> LCL_VAR BB01 regmask=[allInt] minReg=1 last>
Interval 30: byref RefPositions {} physReg:NA Preferences=[allInt]
<RefPosition #65  @38  RefTypeDef <Ivl:30> LEA BB01 regmask=[allInt] minReg=1>

DefList: { N033.t42. IND; N037.t140. LEA }
N039 (???,???) [000235] -ACXGO------              *  STOREIND  ref    REG NA
<RefPosition #66  @39  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #67  @39  RefTypeUse <Ivl:30>  BB01 regmask=[rcx] minReg=1 last fixed>
<RefPosition #68  @39  RefTypeFixedReg <Reg:rdx>  BB01 regmask=[rdx] minReg=1>
<RefPosition #69  @39  RefTypeUse <Ivl:29>  BB01 regmask=[rdx] minReg=1 last fixed>
<RefPosition #70  @40  RefTypeKill <Reg:rax>  BB01 regmask=[rax] minReg=1>
<RefPosition #71  @40  RefTypeKill <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #72  @40  RefTypeKill <Reg:rdx>  BB01 regmask=[rdx] minReg=1>
<RefPosition #73  @40  RefTypeKill <Reg:r8 >  BB01 regmask=[r8] minReg=1>
<RefPosition #74  @40  RefTypeKill <Reg:r9 >  BB01 regmask=[r9] minReg=1>
<RefPosition #75  @40  RefTypeKill <Reg:r10>  BB01 regmask=[r10] minReg=1>
<RefPosition #76  @40  RefTypeKill <Reg:r11>  BB01 regmask=[r11] minReg=1>
<RefPosition #77  @40  RefTypeKill <Reg:mm0>  BB01 regmask=[mm0] minReg=1>
<RefPosition #78  @40  RefTypeKill <Reg:mm1>  BB01 regmask=[mm1] minReg=1>
<RefPosition #79  @40  RefTypeKill <Reg:mm2>  BB01 regmask=[mm2] minReg=1>
<RefPosition #80  @40  RefTypeKill <Reg:mm3>  BB01 regmask=[mm3] minReg=1>
<RefPosition #81  @40  RefTypeKill <Reg:mm4>  BB01 regmask=[mm4] minReg=1>
<RefPosition #82  @40  RefTypeKill <Reg:mm5>  BB01 regmask=[mm5] minReg=1>

DefList: {  }
N041 (  1,  1) [000005] ------------              *  LCL_VAR   ref    V02 tmp1         u:1 NA REG NA $180

DefList: {  }
N043 (  2,  2) [000145] ------------              *  LEA(b+16) byref  REG NA
<RefPosition #83  @43  RefTypeUse <Ivl:1 V02> LCL_VAR BB01 regmask=[allInt] minReg=1 last>
Interval 31: byref RefPositions {} physReg:NA Preferences=[allInt]
<RefPosition #84  @44  RefTypeDef <Ivl:31> LEA BB01 regmask=[allInt] minReg=1>

DefList: { N043.t145. LEA }
N045 (  1,  1) [000024] ------------              *  LCL_VAR   ref    V04 tmp3         u:1 NA (last use) REG NA $181

DefList: { N043.t145. LEA }
N047 (???,???) [000236] -A--GO------              *  STOREIND  ref    REG NA
<RefPosition #85  @47  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #86  @47  RefTypeUse <Ivl:31>  BB01 regmask=[rcx] minReg=1 last fixed>
<RefPosition #87  @47  RefTypeFixedReg <Reg:rdx>  BB01 regmask=[rdx] minReg=1>
<RefPosition #88  @47  RefTypeUse <Ivl:2 V04> LCL_VAR BB01 regmask=[rdx] minReg=1 last fixed>
<RefPosition #89  @48  RefTypeKill <Reg:rax>  BB01 regmask=[rax] minReg=1>
<RefPosition #90  @48  RefTypeKill <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #91  @48  RefTypeKill <Reg:rdx>  BB01 regmask=[rdx] minReg=1>
<RefPosition #92  @48  RefTypeKill <Reg:r8 >  BB01 regmask=[r8] minReg=1>
<RefPosition #93  @48  RefTypeKill <Reg:r9 >  BB01 regmask=[r9] minReg=1>
<RefPosition #94  @48  RefTypeKill <Reg:r10>  BB01 regmask=[r10] minReg=1>
<RefPosition #95  @48  RefTypeKill <Reg:r11>  BB01 regmask=[r11] minReg=1>
<RefPosition #96  @48  RefTypeKill <Reg:mm0>  BB01 regmask=[mm0] minReg=1>
<RefPosition #97  @48  RefTypeKill <Reg:mm1>  BB01 regmask=[mm1] minReg=1>
<RefPosition #98  @48  RefTypeKill <Reg:mm2>  BB01 regmask=[mm2] minReg=1>
<RefPosition #99  @48  RefTypeKill <Reg:mm3>  BB01 regmask=[mm3] minReg=1>
<RefPosition #100 @48  RefTypeKill <Reg:mm4>  BB01 regmask=[mm4] minReg=1>
<RefPosition #101 @48  RefTypeKill <Reg:mm5>  BB01 regmask=[mm5] minReg=1>

DefList: {  }
N049 (  1,  1) [000029] ------------              *  LCL_VAR   ref    V02 tmp1         u:1 NA REG NA $180

DefList: {  }
N051 (  2,  2) [000147] -c----------              *  LEA(b+8)  byref  REG NA
Contained
DefList: {  }
N053 (  1,  1) [000030] ------------              *  CNS_INT   ref    null REG NA $VN.Null
Interval 32: ref RefPositions {} physReg:NA Preferences=[allInt]
<RefPosition #102 @54  RefTypeDef <Ivl:32> CNS_INT BB01 regmask=[allInt] minReg=1>

DefList: { N053.t30. CNS_INT }
N055 (???,???) [000237] -A--GO------              *  STOREIND  ref    REG NA
<RefPosition #103 @55  RefTypeUse <Ivl:1 V02> LCL_VAR BB01 regmask=[allInt] minReg=1 last>
<RefPosition #104 @55  RefTypeUse <Ivl:32>  BB01 regmask=[allInt] minReg=1 last>

DefList: {  }
N057 (???,???) [000238] ------------              *  IL_OFFSET void   IL offset: 0x6 REG NA

DefList: {  }
N059 (  1,  1) [000008] ------------              *  LCL_VAR   ref    V00 arg0         u:1 NA REG NA $80

DefList: {  }
N061 (  1,  1) [000050] -c----------              *  CNS_INT   ref    null REG NA $VN.Null
Contained
DefList: {  }
N063 (  3,  3) [000051] J------N----              *  NE        void   REG NA $340
<RefPosition #105 @63  RefTypeUse <Ivl:0 V00> LCL_VAR BB01 regmask=[allInt] minReg=1 last>

DefList: {  }
N065 (  5,  5) [000052] ------------              *  JTRUE     void   REG NA



CHECKING LAST USES for BB01, liveout={V00 V02}
==============================
use: {V00}
def: {V02 V04}

NEW BLOCK BB02


Setting BB01 as the predecessor for determining incoming variable registers of BB02
<RefPosition #106 @67  RefTypeBB  BB02 regmask=[] minReg=1>

DefList: {  }
N069 (???,???) [000239] ------------              *  IL_OFFSET void   IL offset: 0x6 REG NA

DefList: {  }
N071 (  1,  1) [000149] ------------              *  CNS_INT   byref  0 REG NA $VN.Null
Interval 33: byref RefPositions {} physReg:NA Preferences=[allInt]
<RefPosition #107 @72  RefTypeDef <Ivl:33> CNS_INT BB02 regmask=[allInt] minReg=1>

DefList: { N071.t149. CNS_INT }
N073 (  5,  4) [000150] DA----------              *  STORE_LCL_VAR byref  V21 tmp20        d:1 NA REG NA
<RefPosition #108 @73  RefTypeUse <Ivl:33>  BB02 regmask=[allInt] minReg=1 last>
Assigning related <V21/L12> to <I33>
<RefPosition #109 @74  RefTypeDef <Ivl:12 V21> STORE_LCL_VAR BB02 regmask=[allInt] minReg=1 last>

DefList: {  }
N075 (???,???) [000240] ------------              *  IL_OFFSET void   IL offset: 0x6 REG NA

DefList: {  }
N077 (  3,  2) [000156] ------------              *  LCL_VAR   byref  V21 tmp20        u:1 NA (last use) REG NA $VN.Null

DefList: {  }
N079 (  7,  5) [000157] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:3 NA REG NA
<RefPosition #110 @79  RefTypeUse <Ivl:12 V21> LCL_VAR BB02 regmask=[allInt] minReg=1 last>
Assigning related <V17/L8> to <V21/L12>
<RefPosition #111 @80  RefTypeDef <Ivl:8 V17> STORE_LCL_VAR BB02 regmask=[allInt] minReg=1 last>

DefList: {  }
N081 (  1,  1) [000233] ------------              *  CNS_INT   int    0 REG NA $40
Interval 34: int RefPositions {} physReg:NA Preferences=[allInt]
<RefPosition #112 @82  RefTypeDef <Ivl:34> CNS_INT BB02 regmask=[allInt] minReg=1>

DefList: { N081.t233. CNS_INT }
N083 (  5,  4) [000160] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:3 NA REG NA
<RefPosition #113 @83  RefTypeUse <Ivl:34>  BB02 regmask=[allInt] minReg=1 last>
Assigning related <V18/L9> to <I34>
<RefPosition #114 @84  RefTypeDef <Ivl:9 V18> STORE_LCL_VAR BB02 regmask=[allInt] minReg=1 last>



CHECKING LAST USES for BB02, liveout={V02 V17 V18}
==============================
use: {}
def: {V17 V18 V21 V22}

NEW BLOCK BB03


Setting BB01 as the predecessor for determining incoming variable registers of BB03
<RefPosition #115 @85  RefTypeBB  BB03 regmask=[] minReg=1>

DefList: {  }
N087 (???,???) [000241] ------------              *  IL_OFFSET void   IL offset: 0x6 REG NA

DefList: {  }
N089 (???,???) [000242] ------------              *  IL_OFFSET void   IL offset: 0x6 REG NA

DefList: {  }
N091 (  1,  1) [000171] ------------              *  LCL_VAR   ref    V00 arg0         u:1 NA REG NA $80

DefList: {  }
N093 (  1,  1) [000172] -c----------              *  CNS_INT   long   12 field offset Fseq[_firstChar] REG NA $203
Contained
DefList: {  }
N095 (  3,  3) [000173] ------------              *  ADD       byref  REG NA $303
<RefPosition #116 @95  RefTypeUse <Ivl:0 V00> LCL_VAR BB03 regmask=[allInt] minReg=1 last>
Interval 35: byref RefPositions {} physReg:NA Preferences=[allInt]
<RefPosition #117 @96  RefTypeDef <Ivl:35> ADD BB03 regmask=[allInt] minReg=1>

DefList: { N095.t173. ADD }
N097 (  7,  6) [000112] DA--G-------              *  STORE_LCL_VAR byref  V09 tmp8         d:1 NA REG NA
<RefPosition #118 @97  RefTypeUse <Ivl:35>  BB03 regmask=[allInt] minReg=1 last>
Assigning related <V09/L4> to <I35>
<RefPosition #119 @98  RefTypeDef <Ivl:4 V09> STORE_LCL_VAR BB03 regmask=[allInt] minReg=1 last>

DefList: {  }
N099 (???,???) [000243] ------------              *  IL_OFFSET void   IL offset: 0x6 REG NA

DefList: {  }
N101 (  1,  1) [000056] ------------              *  LCL_VAR   ref    V00 arg0         u:1 NA (last use) REG NA $80

DefList: {  }
N103 (???,???) [000256] -c----------              *  LEA(b+8)  ref    REG NA
Contained
DefList: {  }
N105 (  3,  3) [000057] ---X--------              *  IND       int    REG NA $341
<RefPosition #120 @105 RefTypeUse <Ivl:0 V00> LCL_VAR BB03 regmask=[allInt] minReg=1 last>
Interval 36: int RefPositions {} physReg:NA Preferences=[allInt]
<RefPosition #121 @106 RefTypeDef <Ivl:36> IND BB03 regmask=[allInt] minReg=1>

DefList: { N105.t57. IND }
N107 (  3,  3) [000114] DA-X--------              *  STORE_LCL_VAR int    V08 tmp7         d:1 NA REG NA
<RefPosition #122 @107 RefTypeUse <Ivl:36>  BB03 regmask=[allInt] minReg=1 last>
Assigning related <V08/L3> to <I36>
<RefPosition #123 @108 RefTypeDef <Ivl:3 V08> STORE_LCL_VAR BB03 regmask=[allInt] minReg=1 last>

DefList: {  }
N109 (???,???) [000244] ------------              *  IL_OFFSET void   IL offset: 0x6 REG NA

DefList: {  }
N111 (  2, 10) [000118] H-----------              *  CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL] REG NA $106
Interval 37: long RefPositions {} physReg:NA Preferences=[allInt]
<RefPosition #124 @112 RefTypeDef <Ivl:37> CNS_INT BB03 regmask=[allInt] minReg=1>

DefList: { N111.t118. CNS_INT }
N113 (  4, 12) [000119] #---G-------              *  IND       ref    REG NA $18c
<RefPosition #125 @113 RefTypeUse <Ivl:37>  BB03 regmask=[allInt] minReg=1 last>
Interval 38: ref RefPositions {} physReg:NA Preferences=[allInt]
<RefPosition #126 @114 RefTypeDef <Ivl:38> IND BB03 regmask=[allInt] minReg=1>

DefList: { N113.t119. IND }
N115 (  8, 15) [000229] DA--G-------              *  STORE_LCL_VAR ref    V27 cse0         d:1 NA REG NA
<RefPosition #127 @115 RefTypeUse <Ivl:38>  BB03 regmask=[allInt] minReg=1 last>
Assigning related <V27/L16> to <I38>
<RefPosition #128 @116 RefTypeDef <Ivl:16 V27> STORE_LCL_VAR BB03 regmask=[allInt] minReg=1 last>

DefList: {  }
N117 (???,???) [000245] ------------              *  IL_OFFSET void   IL offset: 0x6 REG NA

DefList: {  }
N119 (  3,  2) [000232] ------------              *  LCL_VAR   ref    V27 cse0         u:1 NA (last use) REG NA $18c

DefList: {  }
N121 (  7,  5) [000135] DA--G-------              *  STORE_LCL_VAR ref    V14 tmp13        d:1 NA REG NA
<RefPosition #129 @121 RefTypeUse <Ivl:16 V27> LCL_VAR BB03 regmask=[allInt] minReg=1 last>
Assigning related <V14/L5> to <V27/L16>
<RefPosition #130 @122 RefTypeDef <Ivl:5 V14> STORE_LCL_VAR BB03 regmask=[allInt] minReg=1 last>

DefList: {  }
N123 (???,???) [000246] ------------              *  IL_OFFSET void   IL offset: 0x6 REG NA

DefList: {  }
N125 (  1,  1) [000088] ------------              *  LCL_VAR   int    V08 tmp7         u:1 NA REG NA $400

DefList: {  }
N127 (  1,  1) [000089] -c----------              *  CNS_INT   int    0 REG NA $40
Contained
DefList: {  }
N129 (  3,  3) [000090] J------N----              *  GE        void   REG NA $342
<RefPosition #131 @129 RefTypeUse <Ivl:3 V08> LCL_VAR BB03 regmask=[allInt] minReg=1 last>

DefList: {  }
N131 (  5,  5) [000128] ------------              *  JTRUE     void   REG NA



CHECKING LAST USES for BB03, liveout={V02 V08 V09 V14}
==============================
use: {V00}
def: {V08 V09 V13 V14 V27}

NEW BLOCK BB04


Setting BB03 as the predecessor for determining incoming variable registers of BB04
<RefPosition #132 @133 RefTypeBB  BB04 regmask=[] minReg=1>

DefList: {  }
N135 (???,???) [000247] ------------              *  IL_OFFSET void   IL offset: 0x6 REG NA

DefList: {  }
N137 (  3,  2) [000129] ------------              *  LCL_VAR   ref    V14 tmp13        u:1 NA REG NA $18c

DefList: {  }
N139 (???,???) [000261] ------------              *  PUTARG_REG ref    REG rcx
<RefPosition #133 @139 RefTypeFixedReg <Reg:rcx>  BB04 regmask=[rcx] minReg=1>
<RefPosition #134 @139 RefTypeUse <Ivl:5 V14> LCL_VAR BB04 regmask=[rcx] minReg=1 last fixed>
Setting putarg_reg as a pass-through of a non-last use lclVar
Interval 39: ref RefPositions {} physReg:NA Preferences=[allInt]
<RefPosition #135 @140 RefTypeFixedReg <Reg:rcx>  BB04 regmask=[rcx] minReg=1>
<RefPosition #136 @140 RefTypeDef <Ivl:39> PUTARG_REG BB04 regmask=[rcx] minReg=1 fixed>
Assigning related <V14/L5> to <I39>

DefList: { N139.t261. PUTARG_REG }
N141 (  3,  2) [000130] ------------              *  LCL_VAR   ref    V14 tmp13        u:1 NA (last use) REG NA $18c

DefList: { N139.t261. PUTARG_REG }
N143 (???,???) [000262] ------------              *  PUTARG_REG ref    REG rdx
<RefPosition #137 @143 RefTypeFixedReg <Reg:rdx>  BB04 regmask=[rdx] minReg=1>
<RefPosition #138 @143 RefTypeUse <Ivl:5 V14> LCL_VAR BB04 regmask=[rdx] minReg=1 last fixed>
Interval 40: ref RefPositions {} physReg:NA Preferences=[allInt]
<RefPosition #139 @144 RefTypeFixedReg <Reg:rdx>  BB04 regmask=[rdx] minReg=1>
<RefPosition #140 @144 RefTypeDef <Ivl:40> PUTARG_REG BB04 regmask=[rdx] minReg=1 fixed>

DefList: { N139.t261. PUTARG_REG; N143.t262. PUTARG_REG }
N145 ( 20, 11) [000131] --CXG-------              *  CALL      void   System.Diagnostics.Debug.Fail REG NA $VN.Void
<RefPosition #141 @145 RefTypeFixedReg <Reg:rcx>  BB04 regmask=[rcx] minReg=1>
<RefPosition #142 @145 RefTypeUse <Ivl:39>  BB04 regmask=[rcx] minReg=1 last fixed>
<RefPosition #143 @145 RefTypeFixedReg <Reg:rdx>  BB04 regmask=[rdx] minReg=1>
<RefPosition #144 @145 RefTypeUse <Ivl:40>  BB04 regmask=[rdx] minReg=1 last fixed>
<RefPosition #145 @146 RefTypeKill <Reg:rax>  BB04 regmask=[rax] minReg=1>
<RefPosition #146 @146 RefTypeKill <Reg:rcx>  BB04 regmask=[rcx] minReg=1>
<RefPosition #147 @146 RefTypeKill <Reg:rdx>  BB04 regmask=[rdx] minReg=1>
<RefPosition #148 @146 RefTypeKill <Reg:r8 >  BB04 regmask=[r8] minReg=1>
<RefPosition #149 @146 RefTypeKill <Reg:r9 >  BB04 regmask=[r9] minReg=1>
<RefPosition #150 @146 RefTypeKill <Reg:r10>  BB04 regmask=[r10] minReg=1>
<RefPosition #151 @146 RefTypeKill <Reg:r11>  BB04 regmask=[r11] minReg=1>



CHECKING LAST USES for BB04, liveout={V02 V08 V09}
==============================
use: {V14}
def: {}

NEW BLOCK BB05


Setting BB03 as the predecessor for determining incoming variable registers of BB05
<RefPosition #152 @147 RefTypeBB  BB05 regmask=[] minReg=1>

DefList: {  }
N149 (???,???) [000248] ------------              *  IL_OFFSET void   IL offset: 0x6 REG NA

DefList: {  }
N151 (  3,  2) [000096] ------------              *  LCL_VAR   byref  V09 tmp8         u:1 NA (last use) REG NA $303

DefList: {  }
N153 (  7,  5) [000100] DA----------              *  STORE_LCL_VAR byref  V23 tmp22        d:1 NA REG NA
<RefPosition #153 @153 RefTypeUse <Ivl:4 V09> LCL_VAR BB05 regmask=[allInt] minReg=1 last>
Assigning related <V23/L13> to <V09/L4>
<RefPosition #154 @154 RefTypeDef <Ivl:13 V23> STORE_LCL_VAR BB05 regmask=[allInt] minReg=1 last>

DefList: {  }
N155 (???,???) [000249] ------------              *  IL_OFFSET void   IL offset: 0x6 REG NA

DefList: {  }
N157 (  3,  2) [000178] -------N----              *  LCL_VAR   byref  V23 tmp22        u:1 NA (last use) REG NA $303

DefList: {  }
N159 (  7,  5) [000179] DA----------              *  STORE_LCL_VAR byref  V19 tmp18        d:1 NA REG NA
<RefPosition #155 @159 RefTypeUse <Ivl:13 V23> LCL_VAR BB05 regmask=[allInt] minReg=1 last>
Assigning related <V19/L10> to <V23/L13>
<RefPosition #156 @160 RefTypeDef <Ivl:10 V19> STORE_LCL_VAR BB05 regmask=[allInt] minReg=1 last>

DefList: {  }
N161 (???,???) [000250] ------------              *  IL_OFFSET void   IL offset: 0x6 REG NA

DefList: {  }
N163 (  1,  1) [000108] ------------              *  LCL_VAR   int    V08 tmp7         u:1 NA (last use) REG NA $400

DefList: {  }
N165 (  5,  4) [000110] DA----------              *  STORE_LCL_VAR int    V20 tmp19        d:1 NA REG NA
<RefPosition #157 @165 RefTypeUse <Ivl:3 V08> LCL_VAR BB05 regmask=[allInt] minReg=1 last>
Assigning related <V20/L11> to <V08/L3>
<RefPosition #158 @166 RefTypeDef <Ivl:11 V20> STORE_LCL_VAR BB05 regmask=[allInt] minReg=1 last>

DefList: {  }
N167 (???,???) [000251] ------------              *  IL_OFFSET void   IL offset: 0x6 REG NA

DefList: {  }
N169 (  3,  2) [000181] ------------              *  LCL_VAR   byref  V19 tmp18        u:1 NA (last use) REG NA $303

DefList: {  }
N171 (  7,  5) [000182] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:2 NA REG NA
<RefPosition #159 @171 RefTypeUse <Ivl:10 V19> LCL_VAR BB05 regmask=[allInt] minReg=1 last>
Assigning related <V17/L8> to <V19/L10>
<RefPosition #160 @172 RefTypeDef <Ivl:8 V17> STORE_LCL_VAR BB05 regmask=[allInt] minReg=1 last>

DefList: {  }
N173 (  3,  2) [000184] ------------              *  LCL_VAR   int    V20 tmp19        u:1 NA (last use) REG NA $400

DefList: {  }
N175 (  7,  5) [000185] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:2 NA REG NA
<RefPosition #161 @175 RefTypeUse <Ivl:11 V20> LCL_VAR BB05 regmask=[allInt] minReg=1 last>
Assigning related <V18/L9> to <V20/L11>
<RefPosition #162 @176 RefTypeDef <Ivl:9 V18> STORE_LCL_VAR BB05 regmask=[allInt] minReg=1 last>



CHECKING LAST USES for BB05, liveout={V02 V17 V18}
==============================
use: {V08 V09}
def: {V17 V18 V19 V20 V23}

NEW BLOCK BB06


Setting BB02 as the predecessor for determining incoming variable registers of BB06
<RefPosition #163 @177 RefTypeBB  BB06 regmask=[] minReg=1>

DefList: {  }
N179 (  3,  2) [000188] ------------              *  LCL_VAR   byref  V17 tmp16        u:1 NA (last use) REG NA $480

DefList: {  }
N181 (  7,  5) [000189] DA----------              *  STORE_LCL_VAR byref  V15 tmp14        d:1 NA REG NA
<RefPosition #164 @181 RefTypeUse <Ivl:8 V17> LCL_VAR BB06 regmask=[allInt] minReg=1 last>
Assigning related <V15/L6> to <V17/L8>
<RefPosition #165 @182 RefTypeDef <Ivl:6 V15> STORE_LCL_VAR BB06 regmask=[allInt] minReg=1 last>

DefList: {  }
N183 (  3,  2) [000191] ------------              *  LCL_VAR   int    V18 tmp17        u:1 NA (last use) REG NA $440

DefList: {  }
N185 (  7,  5) [000192] DA----------              *  STORE_LCL_VAR int    V16 tmp15        d:1 NA REG NA
<RefPosition #166 @185 RefTypeUse <Ivl:9 V18> LCL_VAR BB06 regmask=[allInt] minReg=1 last>
Assigning related <V16/L7> to <V18/L9>
<RefPosition #167 @186 RefTypeDef <Ivl:7 V16> STORE_LCL_VAR BB06 regmask=[allInt] minReg=1 last>

DefList: {  }
N187 (  1,  1) [000007] ------------              *  LCL_VAR   ref    V02 tmp1         u:1 NA (last use) REG NA $180

DefList: {  }
N189 (  1,  3) [000214] DA--------L-              *  STORE_LCL_VAR ref    V26 tmp25        d:1 NA REG NA
<RefPosition #168 @189 RefTypeUse <Ivl:1 V02> LCL_VAR BB06 regmask=[allInt] minReg=1 last>
Assigning related <V26/L15> to <V02/L1>
<RefPosition #169 @190 RefTypeDef <Ivl:15 V26> STORE_LCL_VAR BB06 regmask=[allInt] minReg=1 last>

DefList: {  }
N191 (  3,  2) [000198] -------N----              *  LCL_VAR_ADDR byref  V24 tmp23         NA REG NA
Interval 41: byref RefPositions {} physReg:NA Preferences=[allInt]
<RefPosition #170 @192 RefTypeDef <Ivl:41> LCL_VAR_ADDR BB06 regmask=[allInt] minReg=1>

DefList: { N191.t198. LCL_VAR_ADDR }
N193 (  3,  3) [000200] DA----------              *  STORE_LCL_VAR byref  V25 tmp24        d:1 NA REG NA
<RefPosition #171 @193 RefTypeUse <Ivl:41>  BB06 regmask=[allInt] minReg=1 last>
Assigning related <V25/L14> to <I41>
<RefPosition #172 @194 RefTypeDef <Ivl:14 V25> STORE_LCL_VAR BB06 regmask=[allInt] minReg=1 last>

DefList: {  }
N195 (  1,  1) [000201] ------------              *  LCL_VAR   byref  V25 tmp24        u:1 NA Zero Fseq[_pointer] REG NA $3c7

DefList: {  }
N197 (  3,  2) [000203] -------N----              *  LCL_VAR   byref  V15 tmp14        u:1 NA (last use) REG NA $480

DefList: {  }
N199 (???,???) [000252] -A----------              *  STOREIND  byref  REG NA
<RefPosition #173 @199 RefTypeUse <Ivl:14 V25> LCL_VAR BB06 regmask=[allInt] minReg=1 last>
<RefPosition #174 @199 RefTypeUse <Ivl:6 V15> LCL_VAR BB06 regmask=[allInt] minReg=1 last>

DefList: {  }
N201 (  1,  1) [000206] ------------              *  LCL_VAR   byref  V25 tmp24        u:1 NA (last use) REG NA $3c7

DefList: {  }
N203 (  2,  2) [000208] -c----------              *  LEA(b+8)  byref  REG NA
Contained
DefList: {  }
N205 (  3,  2) [000210] -------N----              *  LCL_VAR   int    V16 tmp15        u:1 NA (last use) REG NA $440

DefList: {  }
N207 (???,???) [000253] -A--------L-              *  STOREIND  int    REG NA
<RefPosition #175 @207 RefTypeUse <Ivl:14 V25> LCL_VAR BB06 regmask=[allInt] minReg=1 last>
<RefPosition #176 @207 RefTypeUse <Ivl:7 V16> LCL_VAR BB06 regmask=[allInt] minReg=1 last>

DefList: {  }
N209 (  1,  1) [000215] ------------              *  LCL_VAR   ref    V26 tmp25        u:1 NA (last use) REG NA $180

DefList: {  }
N211 (???,???) [000263] ------------              *  PUTARG_REG ref    REG rcx
<RefPosition #177 @211 RefTypeFixedReg <Reg:rcx>  BB06 regmask=[rcx] minReg=1>
<RefPosition #178 @211 RefTypeUse <Ivl:15 V26> LCL_VAR BB06 regmask=[rcx] minReg=1 last fixed>
Interval 42: ref RefPositions {} physReg:NA Preferences=[allInt]
<RefPosition #179 @212 RefTypeFixedReg <Reg:rcx>  BB06 regmask=[rcx] minReg=1>
<RefPosition #180 @212 RefTypeDef <Ivl:42> PUTARG_REG BB06 regmask=[rcx] minReg=1 fixed>

DefList: { N211.t263. PUTARG_REG }
N213 (  3,  2) [000216] -------N----              *  LCL_VAR_ADDR byref  V24 tmp23         NA REG NA
Interval 43: byref RefPositions {} physReg:NA Preferences=[allInt]
<RefPosition #181 @214 RefTypeDef <Ivl:43> LCL_VAR_ADDR BB06 regmask=[allInt] minReg=1>

DefList: { N211.t263. PUTARG_REG; N213.t216. LCL_VAR_ADDR }
N215 (???,???) [000264] ------------              *  PUTARG_REG byref  REG rdx
<RefPosition #182 @215 RefTypeFixedReg <Reg:rdx>  BB06 regmask=[rdx] minReg=1>
<RefPosition #183 @215 RefTypeUse <Ivl:43>  BB06 regmask=[rdx] minReg=1 last fixed>
Interval 44: byref RefPositions {} physReg:NA Preferences=[allInt]
<RefPosition #184 @216 RefTypeFixedReg <Reg:rdx>  BB06 regmask=[rdx] minReg=1>
<RefPosition #185 @216 RefTypeDef <Ivl:44> PUTARG_REG BB06 regmask=[rdx] minReg=1 fixed>

DefList: { N211.t263. PUTARG_REG; N215.t264. PUTARG_REG }
N217 ( 40, 30) [000011] --CXG-------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer.TokenizeLine REG NA $VN.Void
<RefPosition #186 @217 RefTypeFixedReg <Reg:rcx>  BB06 regmask=[rcx] minReg=1>
<RefPosition #187 @217 RefTypeUse <Ivl:42>  BB06 regmask=[rcx] minReg=1 last fixed>
<RefPosition #188 @217 RefTypeFixedReg <Reg:rdx>  BB06 regmask=[rdx] minReg=1>
<RefPosition #189 @217 RefTypeUse <Ivl:44>  BB06 regmask=[rdx] minReg=1 last fixed>
<RefPosition #190 @218 RefTypeKill <Reg:rax>  BB06 regmask=[rax] minReg=1>
<RefPosition #191 @218 RefTypeKill <Reg:rcx>  BB06 regmask=[rcx] minReg=1>
<RefPosition #192 @218 RefTypeKill <Reg:rdx>  BB06 regmask=[rdx] minReg=1>
<RefPosition #193 @218 RefTypeKill <Reg:r8 >  BB06 regmask=[r8] minReg=1>
<RefPosition #194 @218 RefTypeKill <Reg:r9 >  BB06 regmask=[r9] minReg=1>
<RefPosition #195 @218 RefTypeKill <Reg:r10>  BB06 regmask=[r10] minReg=1>
<RefPosition #196 @218 RefTypeKill <Reg:r11>  BB06 regmask=[r11] minReg=1>

DefList: {  }
N219 (???,???) [000254] ------------              *  IL_OFFSET void   IL offset: 0x11 REG NA

DefList: {  }
N221 (  0,  0) [000017] ------------              *  RETURN    void   REG NA $382



CHECKING LAST USES for BB06, liveout={}
==============================
use: {V02 V17 V18}
def: {V15 V16 V25 V26}

Linear scan intervals BEFORE VALIDATING INTERVALS:
Interval  0: (V00) ref RefPositions {#0@0 #105@63 #116@95 #120@105} physReg:rcx Preferences=[rbx rbp rsi rdi r12-r15]
Interval  1: (V02) ref RefPositions {#19@12 #83@43 #103@55 #168@189} physReg:NA Preferences=[rbx rbp rsi rdi r12-r15] RelatedInterval <V26/L15>
Interval  2: (V04) ref RefPositions {#37@20 #64@37 #88@47} physReg:NA Preferences=[rbx rbp rsi rdi r12-r15]
Interval  3: (V08) int RefPositions {#123@108 #131@129 #157@165} physReg:NA Preferences=[rbx rbp rsi rdi r12-r15] RelatedInterval <V20/L11>
Interval  4: (V09) byref RefPositions {#119@98 #153@153} physReg:NA Preferences=[rbx rbp rsi rdi r12-r15] RelatedInterval <V23/L13>
Interval  5: (V14) ref RefPositions {#130@122 #134@139 #138@143} physReg:NA Preferences=[rcx rdx]
Interval  6: (V15) byref (field) RefPositions {#165@182 #174@199} physReg:NA Preferences=[allInt]
Interval  7: (V16) int (field) RefPositions {#167@186 #176@207} physReg:NA Preferences=[allInt]
Interval  8: (V17) byref (field) RefPositions {#111@80 #160@172 #164@181} physReg:NA Preferences=[allInt] RelatedInterval <V15/L6>
Interval  9: (V18) int (field) RefPositions {#114@84 #162@176 #166@185} physReg:NA Preferences=[allInt] RelatedInterval <V16/L7>
Interval 10: (V19) byref (field) RefPositions {#156@160 #159@171} physReg:NA Preferences=[allInt] RelatedInterval <V17/L8>
Interval 11: (V20) int (field) RefPositions {#158@166 #161@175} physReg:NA Preferences=[allInt] RelatedInterval <V18/L9>
Interval 12: (V21) byref (field) RefPositions {#109@74 #110@79} physReg:NA Preferences=[allInt] RelatedInterval <V17/L8>
Interval 13: (V23) byref (field) RefPositions {#154@154 #155@159} physReg:NA Preferences=[allInt] RelatedInterval <V19/L10>
Interval 14: (V25) byref RefPositions {#172@194 #173@199 #175@207} physReg:NA Preferences=[allInt]
Interval 15: (V26) ref RefPositions {#169@190 #178@211} physReg:NA Preferences=[rcx]
Interval 16: (V27) ref RefPositions {#128@116 #129@121} physReg:NA Preferences=[allInt] RelatedInterval <V14/L5>
Interval 17: long (constant) RefPositions {#2@6 #4@7} physReg:NA Preferences=[rcx]
Interval 18: long RefPositions {#6@8 #8@9} physReg:NA Preferences=[rcx]
Interval 19: ref RefPositions {#17@10 #18@11} physReg:NA Preferences=[rax] RelatedInterval <V02/L1>
Interval 20: long (constant) RefPositions {#20@14 #22@15} physReg:NA Preferences=[rcx]
Interval 21: long RefPositions {#24@16 #26@17} physReg:NA Preferences=[rcx]
Interval 22: ref RefPositions {#35@18 #36@19} physReg:NA Preferences=[rax] RelatedInterval <V04/L2>
Interval 23: long (constant) RefPositions {#38@22 #40@23} physReg:NA Preferences=[rcx]
Interval 24: long RefPositions {#42@24 #49@29} physReg:NA Preferences=[rcx]
Interval 25: int (constant) RefPositions {#43@26 #45@27} physReg:NA Preferences=[rdx]
Interval 26: int RefPositions {#47@28 #51@29} physReg:NA Preferences=[rdx]
Interval 27: long RefPositions {#60@30} physReg:NA Preferences=[rax]
Interval 28: long (constant) RefPositions {#61@32 #62@33} physReg:NA Preferences=[allInt]
Interval 29: ref RefPositions {#63@34 #69@39} physReg:NA Preferences=[rdx]
Interval 30: byref RefPositions {#65@38 #67@39} physReg:NA Preferences=[rcx]
Interval 31: byref RefPositions {#84@44 #86@47} physReg:NA Preferences=[rcx]
Interval 32: ref (constant) RefPositions {#102@54 #104@55} physReg:NA Preferences=[allInt]
Interval 33: byref (constant) RefPositions {#107@72 #108@73} physReg:NA Preferences=[allInt] RelatedInterval <V21/L12>
Interval 34: int (constant) RefPositions {#112@82 #113@83} physReg:NA Preferences=[allInt] RelatedInterval <V18/L9>
Interval 35: byref RefPositions {#117@96 #118@97} physReg:NA Preferences=[allInt] RelatedInterval <V09/L4>
Interval 36: int RefPositions {#121@106 #122@107} physReg:NA Preferences=[allInt] RelatedInterval <V08/L3>
Interval 37: long (constant) RefPositions {#124@112 #125@113} physReg:NA Preferences=[allInt]
Interval 38: ref RefPositions {#126@114 #127@115} physReg:NA Preferences=[allInt] RelatedInterval <V27/L16>
Interval 39: ref (specialPutArg) RefPositions {#136@140 #142@145} physReg:NA Preferences=[rcx] RelatedInterval <V14/L5>
Interval 40: ref RefPositions {#140@144 #144@145} physReg:NA Preferences=[rdx]
Interval 41: byref RefPositions {#170@192 #171@193} physReg:NA Preferences=[allInt] RelatedInterval <V25/L14>
Interval 42: ref RefPositions {#180@212 #187@217} physReg:NA Preferences=[rcx]
Interval 43: byref RefPositions {#181@214 #183@215} physReg:NA Preferences=[rdx]
Interval 44: byref RefPositions {#185@216 #189@217} physReg:NA Preferences=[rdx]

------------
REFPOSITIONS BEFORE VALIDATING INTERVALS: 
------------
<RefPosition #0   @0   RefTypeParamDef <Ivl:0 V00>  BB00 regmask=[rcx] minReg=1 fixed regOptional>
<RefPosition #1   @1   RefTypeBB  BB01 regmask=[] minReg=1>
<RefPosition #2   @6   RefTypeDef <Ivl:17> CNS_INT BB01 regmask=[rcx] minReg=1>
<RefPosition #3   @7   RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #4   @7   RefTypeUse <Ivl:17>  BB01 regmask=[rcx] minReg=1 last fixed>
<RefPosition #5   @8   RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #6   @8   RefTypeDef <Ivl:18> PUTARG_REG BB01 regmask=[rcx] minReg=1 fixed>
<RefPosition #7   @9   RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #8   @9   RefTypeUse <Ivl:18>  BB01 regmask=[rcx] minReg=1 last fixed>
<RefPosition #9   @10  RefTypeKill <Reg:rax>  BB01 regmask=[rax] minReg=1 last>
<RefPosition #10  @10  RefTypeKill <Reg:rcx>  BB01 regmask=[rcx] minReg=1 last>
<RefPosition #11  @10  RefTypeKill <Reg:rdx>  BB01 regmask=[rdx] minReg=1 last>
<RefPosition #12  @10  RefTypeKill <Reg:r8 >  BB01 regmask=[r8] minReg=1 last>
<RefPosition #13  @10  RefTypeKill <Reg:r9 >  BB01 regmask=[r9] minReg=1 last>
<RefPosition #14  @10  RefTypeKill <Reg:r10>  BB01 regmask=[r10] minReg=1 last>
<RefPosition #15  @10  RefTypeKill <Reg:r11>  BB01 regmask=[r11] minReg=1 last>
<RefPosition #16  @10  RefTypeFixedReg <Reg:rax>  BB01 regmask=[rax] minReg=1>
<RefPosition #17  @10  RefTypeDef <Ivl:19> CALL BB01 regmask=[rax] minReg=1 fixed>
<RefPosition #18  @11  RefTypeUse <Ivl:19>  BB01 regmask=[allInt] minReg=1 last>
<RefPosition #19  @12  RefTypeDef <Ivl:1 V02> STORE_LCL_VAR BB01 regmask=[allInt] minReg=1>
<RefPosition #20  @14  RefTypeDef <Ivl:20> CNS_INT BB01 regmask=[rcx] minReg=1>
<RefPosition #21  @15  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #22  @15  RefTypeUse <Ivl:20>  BB01 regmask=[rcx] minReg=1 last fixed>
<RefPosition #23  @16  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #24  @16  RefTypeDef <Ivl:21> PUTARG_REG BB01 regmask=[rcx] minReg=1 fixed>
<RefPosition #25  @17  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #26  @17  RefTypeUse <Ivl:21>  BB01 regmask=[rcx] minReg=1 last fixed>
<RefPosition #27  @18  RefTypeKill <Reg:rax>  BB01 regmask=[rax] minReg=1 last>
<RefPosition #28  @18  RefTypeKill <Reg:rcx>  BB01 regmask=[rcx] minReg=1 last>
<RefPosition #29  @18  RefTypeKill <Reg:rdx>  BB01 regmask=[rdx] minReg=1 last>
<RefPosition #30  @18  RefTypeKill <Reg:r8 >  BB01 regmask=[r8] minReg=1 last>
<RefPosition #31  @18  RefTypeKill <Reg:r9 >  BB01 regmask=[r9] minReg=1 last>
<RefPosition #32  @18  RefTypeKill <Reg:r10>  BB01 regmask=[r10] minReg=1 last>
<RefPosition #33  @18  RefTypeKill <Reg:r11>  BB01 regmask=[r11] minReg=1 last>
<RefPosition #34  @18  RefTypeFixedReg <Reg:rax>  BB01 regmask=[rax] minReg=1>
<RefPosition #35  @18  RefTypeDef <Ivl:22> CALL BB01 regmask=[rax] minReg=1 fixed>
<RefPosition #36  @19  RefTypeUse <Ivl:22>  BB01 regmask=[allInt] minReg=1 last>
<RefPosition #37  @20  RefTypeDef <Ivl:2 V04> STORE_LCL_VAR BB01 regmask=[allInt] minReg=1>
<RefPosition #38  @22  RefTypeDef <Ivl:23> CNS_INT BB01 regmask=[rcx] minReg=1>
<RefPosition #39  @23  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #40  @23  RefTypeUse <Ivl:23>  BB01 regmask=[rcx] minReg=1 last fixed>
<RefPosition #41  @24  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #42  @24  RefTypeDef <Ivl:24> PUTARG_REG BB01 regmask=[rcx] minReg=1 fixed>
<RefPosition #43  @26  RefTypeDef <Ivl:25> CNS_INT BB01 regmask=[rdx] minReg=1>
<RefPosition #44  @27  RefTypeFixedReg <Reg:rdx>  BB01 regmask=[rdx] minReg=1>
<RefPosition #45  @27  RefTypeUse <Ivl:25>  BB01 regmask=[rdx] minReg=1 last fixed>
<RefPosition #46  @28  RefTypeFixedReg <Reg:rdx>  BB01 regmask=[rdx] minReg=1>
<RefPosition #47  @28  RefTypeDef <Ivl:26> PUTARG_REG BB01 regmask=[rdx] minReg=1 fixed>
<RefPosition #48  @29  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #49  @29  RefTypeUse <Ivl:24>  BB01 regmask=[rcx] minReg=1 last fixed>
<RefPosition #50  @29  RefTypeFixedReg <Reg:rdx>  BB01 regmask=[rdx] minReg=1>
<RefPosition #51  @29  RefTypeUse <Ivl:26>  BB01 regmask=[rdx] minReg=1 last fixed>
<RefPosition #52  @30  RefTypeKill <Reg:rax>  BB01 regmask=[rax] minReg=1 last>
<RefPosition #53  @30  RefTypeKill <Reg:rcx>  BB01 regmask=[rcx] minReg=1 last>
<RefPosition #54  @30  RefTypeKill <Reg:rdx>  BB01 regmask=[rdx] minReg=1 last>
<RefPosition #55  @30  RefTypeKill <Reg:r8 >  BB01 regmask=[r8] minReg=1 last>
<RefPosition #56  @30  RefTypeKill <Reg:r9 >  BB01 regmask=[r9] minReg=1 last>
<RefPosition #57  @30  RefTypeKill <Reg:r10>  BB01 regmask=[r10] minReg=1 last>
<RefPosition #58  @30  RefTypeKill <Reg:r11>  BB01 regmask=[r11] minReg=1 last>
<RefPosition #59  @30  RefTypeFixedReg <Reg:rax>  BB01 regmask=[rax] minReg=1>
<RefPosition #60  @30  RefTypeDef <Ivl:27> CALL BB01 regmask=[rax] minReg=1 last fixed local>
<RefPosition #61  @32  RefTypeDef <Ivl:28> CNS_INT BB01 regmask=[allInt] minReg=1>
<RefPosition #62  @33  RefTypeUse <Ivl:28>  BB01 regmask=[allInt] minReg=1 last>
<RefPosition #63  @34  RefTypeDef <Ivl:29> IND BB01 regmask=[rdx] minReg=1>
<RefPosition #64  @37  RefTypeUse <Ivl:2 V04> LCL_VAR BB01 regmask=[allInt] minReg=1>
<RefPosition #65  @38  RefTypeDef <Ivl:30> LEA BB01 regmask=[rcx] minReg=1>
<RefPosition #66  @39  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #67  @39  RefTypeUse <Ivl:30>  BB01 regmask=[rcx] minReg=1 last fixed>
<RefPosition #68  @39  RefTypeFixedReg <Reg:rdx>  BB01 regmask=[rdx] minReg=1>
<RefPosition #69  @39  RefTypeUse <Ivl:29>  BB01 regmask=[rdx] minReg=1 last fixed>
<RefPosition #70  @40  RefTypeKill <Reg:rax>  BB01 regmask=[rax] minReg=1 last>
<RefPosition #71  @40  RefTypeKill <Reg:rcx>  BB01 regmask=[rcx] minReg=1 last>
<RefPosition #72  @40  RefTypeKill <Reg:rdx>  BB01 regmask=[rdx] minReg=1 last>
<RefPosition #73  @40  RefTypeKill <Reg:r8 >  BB01 regmask=[r8] minReg=1 last>
<RefPosition #74  @40  RefTypeKill <Reg:r9 >  BB01 regmask=[r9] minReg=1 last>
<RefPosition #75  @40  RefTypeKill <Reg:r10>  BB01 regmask=[r10] minReg=1 last>
<RefPosition #76  @40  RefTypeKill <Reg:r11>  BB01 regmask=[r11] minReg=1 last>
<RefPosition #77  @40  RefTypeKill <Reg:mm0>  BB01 regmask=[mm0] minReg=1 last>
<RefPosition #78  @40  RefTypeKill <Reg:mm1>  BB01 regmask=[mm1] minReg=1 last>
<RefPosition #79  @40  RefTypeKill <Reg:mm2>  BB01 regmask=[mm2] minReg=1 last>
<RefPosition #80  @40  RefTypeKill <Reg:mm3>  BB01 regmask=[mm3] minReg=1 last>
<RefPosition #81  @40  RefTypeKill <Reg:mm4>  BB01 regmask=[mm4] minReg=1 last>
<RefPosition #82  @40  RefTypeKill <Reg:mm5>  BB01 regmask=[mm5] minReg=1 last>
<RefPosition #83  @43  RefTypeUse <Ivl:1 V02> LCL_VAR BB01 regmask=[allInt] minReg=1>
<RefPosition #84  @44  RefTypeDef <Ivl:31> LEA BB01 regmask=[rcx] minReg=1>
<RefPosition #85  @47  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #86  @47  RefTypeUse <Ivl:31>  BB01 regmask=[rcx] minReg=1 last fixed>
<RefPosition #87  @47  RefTypeFixedReg <Reg:rdx>  BB01 regmask=[rdx] minReg=1>
<RefPosition #88  @47  RefTypeUse <Ivl:2 V04> LCL_VAR BB01 regmask=[rdx] minReg=1 last fixed>
<RefPosition #89  @48  RefTypeKill <Reg:rax>  BB01 regmask=[rax] minReg=1 last>
<RefPosition #90  @48  RefTypeKill <Reg:rcx>  BB01 regmask=[rcx] minReg=1 last>
<RefPosition #91  @48  RefTypeKill <Reg:rdx>  BB01 regmask=[rdx] minReg=1 last>
<RefPosition #92  @48  RefTypeKill <Reg:r8 >  BB01 regmask=[r8] minReg=1 last>
<RefPosition #93  @48  RefTypeKill <Reg:r9 >  BB01 regmask=[r9] minReg=1 last>
<RefPosition #94  @48  RefTypeKill <Reg:r10>  BB01 regmask=[r10] minReg=1 last>
<RefPosition #95  @48  RefTypeKill <Reg:r11>  BB01 regmask=[r11] minReg=1 last>
<RefPosition #96  @48  RefTypeKill <Reg:mm0>  BB01 regmask=[mm0] minReg=1 last>
<RefPosition #97  @48  RefTypeKill <Reg:mm1>  BB01 regmask=[mm1] minReg=1 last>
<RefPosition #98  @48  RefTypeKill <Reg:mm2>  BB01 regmask=[mm2] minReg=1 last>
<RefPosition #99  @48  RefTypeKill <Reg:mm3>  BB01 regmask=[mm3] minReg=1 last>
<RefPosition #100 @48  RefTypeKill <Reg:mm4>  BB01 regmask=[mm4] minReg=1 last>
<RefPosition #101 @48  RefTypeKill <Reg:mm5>  BB01 regmask=[mm5] minReg=1 last>
<RefPosition #102 @54  RefTypeDef <Ivl:32> CNS_INT BB01 regmask=[allInt] minReg=1>
<RefPosition #103 @55  RefTypeUse <Ivl:1 V02> LCL_VAR BB01 regmask=[allInt] minReg=1>
<RefPosition #104 @55  RefTypeUse <Ivl:32>  BB01 regmask=[allInt] minReg=1 last>
<RefPosition #105 @63  RefTypeUse <Ivl:0 V00> LCL_VAR BB01 regmask=[allInt] minReg=1 regOptional>
<RefPosition #106 @67  RefTypeBB  BB02 regmask=[] minReg=1>
<RefPosition #107 @72  RefTypeDef <Ivl:33> CNS_INT BB02 regmask=[allInt] minReg=1>
<RefPosition #108 @73  RefTypeUse <Ivl:33>  BB02 regmask=[allInt] minReg=1 last>
<RefPosition #109 @74  RefTypeDef <Ivl:12 V21> STORE_LCL_VAR BB02 regmask=[allInt] minReg=1>
<RefPosition #110 @79  RefTypeUse <Ivl:12 V21> LCL_VAR BB02 regmask=[allInt] minReg=1 last>
<RefPosition #111 @80  RefTypeDef <Ivl:8 V17> STORE_LCL_VAR BB02 regmask=[allInt] minReg=1>
<RefPosition #112 @82  RefTypeDef <Ivl:34> CNS_INT BB02 regmask=[allInt] minReg=1>
<RefPosition #113 @83  RefTypeUse <Ivl:34>  BB02 regmask=[allInt] minReg=1 last>
<RefPosition #114 @84  RefTypeDef <Ivl:9 V18> STORE_LCL_VAR BB02 regmask=[allInt] minReg=1>
<RefPosition #115 @85  RefTypeBB  BB03 regmask=[] minReg=1>
<RefPosition #116 @95  RefTypeUse <Ivl:0 V00> LCL_VAR BB03 regmask=[allInt] minReg=1>
<RefPosition #117 @96  RefTypeDef <Ivl:35> ADD BB03 regmask=[allInt] minReg=1>
<RefPosition #118 @97  RefTypeUse <Ivl:35>  BB03 regmask=[allInt] minReg=1 last>
<RefPosition #119 @98  RefTypeDef <Ivl:4 V09> STORE_LCL_VAR BB03 regmask=[allInt] minReg=1>
<RefPosition #120 @105 RefTypeUse <Ivl:0 V00> LCL_VAR BB03 regmask=[allInt] minReg=1 last>
<RefPosition #121 @106 RefTypeDef <Ivl:36> IND BB03 regmask=[allInt] minReg=1>
<RefPosition #122 @107 RefTypeUse <Ivl:36>  BB03 regmask=[allInt] minReg=1 last>
<RefPosition #123 @108 RefTypeDef <Ivl:3 V08> STORE_LCL_VAR BB03 regmask=[allInt] minReg=1>
<RefPosition #124 @112 RefTypeDef <Ivl:37> CNS_INT BB03 regmask=[allInt] minReg=1>
<RefPosition #125 @113 RefTypeUse <Ivl:37>  BB03 regmask=[allInt] minReg=1 last>
<RefPosition #126 @114 RefTypeDef <Ivl:38> IND BB03 regmask=[allInt] minReg=1>
<RefPosition #127 @115 RefTypeUse <Ivl:38>  BB03 regmask=[allInt] minReg=1 last>
<RefPosition #128 @116 RefTypeDef <Ivl:16 V27> STORE_LCL_VAR BB03 regmask=[allInt] minReg=1>
<RefPosition #129 @121 RefTypeUse <Ivl:16 V27> LCL_VAR BB03 regmask=[allInt] minReg=1 last>
<RefPosition #130 @122 RefTypeDef <Ivl:5 V14> STORE_LCL_VAR BB03 regmask=[allInt] minReg=1>
<RefPosition #131 @129 RefTypeUse <Ivl:3 V08> LCL_VAR BB03 regmask=[allInt] minReg=1 regOptional>
<RefPosition #132 @133 RefTypeBB  BB04 regmask=[] minReg=1>
<RefPosition #133 @139 RefTypeFixedReg <Reg:rcx>  BB04 regmask=[rcx] minReg=1>
<RefPosition #134 @139 RefTypeUse <Ivl:5 V14> LCL_VAR BB04 regmask=[rcx] minReg=1 fixed>
<RefPosition #135 @140 RefTypeFixedReg <Reg:rcx>  BB04 regmask=[rcx] minReg=1>
<RefPosition #136 @140 RefTypeDef <Ivl:39> PUTARG_REG BB04 regmask=[rcx] minReg=1 fixed>
<RefPosition #137 @143 RefTypeFixedReg <Reg:rdx>  BB04 regmask=[rdx] minReg=1>
<RefPosition #138 @143 RefTypeUse <Ivl:5 V14> LCL_VAR BB04 regmask=[rdx] minReg=1 last fixed>
<RefPosition #139 @144 RefTypeFixedReg <Reg:rdx>  BB04 regmask=[rdx] minReg=1>
<RefPosition #140 @144 RefTypeDef <Ivl:40> PUTARG_REG BB04 regmask=[rdx] minReg=1 fixed>
<RefPosition #141 @145 RefTypeFixedReg <Reg:rcx>  BB04 regmask=[rcx] minReg=1>
<RefPosition #142 @145 RefTypeUse <Ivl:39>  BB04 regmask=[rcx] minReg=1 last fixed>
<RefPosition #143 @145 RefTypeFixedReg <Reg:rdx>  BB04 regmask=[rdx] minReg=1>
<RefPosition #144 @145 RefTypeUse <Ivl:40>  BB04 regmask=[rdx] minReg=1 last fixed>
<RefPosition #145 @146 RefTypeKill <Reg:rax>  BB04 regmask=[rax] minReg=1 last>
<RefPosition #146 @146 RefTypeKill <Reg:rcx>  BB04 regmask=[rcx] minReg=1 last>
<RefPosition #147 @146 RefTypeKill <Reg:rdx>  BB04 regmask=[rdx] minReg=1 last>
<RefPosition #148 @146 RefTypeKill <Reg:r8 >  BB04 regmask=[r8] minReg=1 last>
<RefPosition #149 @146 RefTypeKill <Reg:r9 >  BB04 regmask=[r9] minReg=1 last>
<RefPosition #150 @146 RefTypeKill <Reg:r10>  BB04 regmask=[r10] minReg=1 last>
<RefPosition #151 @146 RefTypeKill <Reg:r11>  BB04 regmask=[r11] minReg=1 last>
<RefPosition #152 @147 RefTypeBB  BB05 regmask=[] minReg=1>
<RefPosition #153 @153 RefTypeUse <Ivl:4 V09> LCL_VAR BB05 regmask=[allInt] minReg=1 last>
<RefPosition #154 @154 RefTypeDef <Ivl:13 V23> STORE_LCL_VAR BB05 regmask=[allInt] minReg=1>
<RefPosition #155 @159 RefTypeUse <Ivl:13 V23> LCL_VAR BB05 regmask=[allInt] minReg=1 last>
<RefPosition #156 @160 RefTypeDef <Ivl:10 V19> STORE_LCL_VAR BB05 regmask=[allInt] minReg=1>
<RefPosition #157 @165 RefTypeUse <Ivl:3 V08> LCL_VAR BB05 regmask=[allInt] minReg=1 last>
<RefPosition #158 @166 RefTypeDef <Ivl:11 V20> STORE_LCL_VAR BB05 regmask=[allInt] minReg=1>
<RefPosition #159 @171 RefTypeUse <Ivl:10 V19> LCL_VAR BB05 regmask=[allInt] minReg=1 last>
<RefPosition #160 @172 RefTypeDef <Ivl:8 V17> STORE_LCL_VAR BB05 regmask=[allInt] minReg=1>
<RefPosition #161 @175 RefTypeUse <Ivl:11 V20> LCL_VAR BB05 regmask=[allInt] minReg=1 last>
<RefPosition #162 @176 RefTypeDef <Ivl:9 V18> STORE_LCL_VAR BB05 regmask=[allInt] minReg=1>
<RefPosition #163 @177 RefTypeBB  BB06 regmask=[] minReg=1>
<RefPosition #164 @181 RefTypeUse <Ivl:8 V17> LCL_VAR BB06 regmask=[allInt] minReg=1 last>
<RefPosition #165 @182 RefTypeDef <Ivl:6 V15> STORE_LCL_VAR BB06 regmask=[allInt] minReg=1>
<RefPosition #166 @185 RefTypeUse <Ivl:9 V18> LCL_VAR BB06 regmask=[allInt] minReg=1 last>
<RefPosition #167 @186 RefTypeDef <Ivl:7 V16> STORE_LCL_VAR BB06 regmask=[allInt] minReg=1>
<RefPosition #168 @189 RefTypeUse <Ivl:1 V02> LCL_VAR BB06 regmask=[allInt] minReg=1 last>
<RefPosition #169 @190 RefTypeDef <Ivl:15 V26> STORE_LCL_VAR BB06 regmask=[allInt] minReg=1>
<RefPosition #170 @192 RefTypeDef <Ivl:41> LCL_VAR_ADDR BB06 regmask=[allInt] minReg=1>
<RefPosition #171 @193 RefTypeUse <Ivl:41>  BB06 regmask=[allInt] minReg=1 last>
<RefPosition #172 @194 RefTypeDef <Ivl:14 V25> STORE_LCL_VAR BB06 regmask=[allInt] minReg=1>
<RefPosition #173 @199 RefTypeUse <Ivl:14 V25> LCL_VAR BB06 regmask=[allInt] minReg=1>
<RefPosition #174 @199 RefTypeUse <Ivl:6 V15> LCL_VAR BB06 regmask=[allInt] minReg=1 last>
<RefPosition #175 @207 RefTypeUse <Ivl:14 V25> LCL_VAR BB06 regmask=[allInt] minReg=1 last>
<RefPosition #176 @207 RefTypeUse <Ivl:7 V16> LCL_VAR BB06 regmask=[allInt] minReg=1 last>
<RefPosition #177 @211 RefTypeFixedReg <Reg:rcx>  BB06 regmask=[rcx] minReg=1>
<RefPosition #178 @211 RefTypeUse <Ivl:15 V26> LCL_VAR BB06 regmask=[rcx] minReg=1 last fixed>
<RefPosition #179 @212 RefTypeFixedReg <Reg:rcx>  BB06 regmask=[rcx] minReg=1>
<RefPosition #180 @212 RefTypeDef <Ivl:42> PUTARG_REG BB06 regmask=[rcx] minReg=1 fixed>
<RefPosition #181 @214 RefTypeDef <Ivl:43> LCL_VAR_ADDR BB06 regmask=[rdx] minReg=1>
<RefPosition #182 @215 RefTypeFixedReg <Reg:rdx>  BB06 regmask=[rdx] minReg=1>
<RefPosition #183 @215 RefTypeUse <Ivl:43>  BB06 regmask=[rdx] minReg=1 last fixed>
<RefPosition #184 @216 RefTypeFixedReg <Reg:rdx>  BB06 regmask=[rdx] minReg=1>
<RefPosition #185 @216 RefTypeDef <Ivl:44> PUTARG_REG BB06 regmask=[rdx] minReg=1 fixed>
<RefPosition #186 @217 RefTypeFixedReg <Reg:rcx>  BB06 regmask=[rcx] minReg=1>
<RefPosition #187 @217 RefTypeUse <Ivl:42>  BB06 regmask=[rcx] minReg=1 last fixed>
<RefPosition #188 @217 RefTypeFixedReg <Reg:rdx>  BB06 regmask=[rdx] minReg=1>
<RefPosition #189 @217 RefTypeUse <Ivl:44>  BB06 regmask=[rdx] minReg=1 last fixed>
<RefPosition #190 @218 RefTypeKill <Reg:rax>  BB06 regmask=[rax] minReg=1 last>
<RefPosition #191 @218 RefTypeKill <Reg:rcx>  BB06 regmask=[rcx] minReg=1 last>
<RefPosition #192 @218 RefTypeKill <Reg:rdx>  BB06 regmask=[rdx] minReg=1 last>
<RefPosition #193 @218 RefTypeKill <Reg:r8 >  BB06 regmask=[r8] minReg=1 last>
<RefPosition #194 @218 RefTypeKill <Reg:r9 >  BB06 regmask=[r9] minReg=1 last>
<RefPosition #195 @218 RefTypeKill <Reg:r10>  BB06 regmask=[r10] minReg=1 last>
<RefPosition #196 @218 RefTypeKill <Reg:r11>  BB06 regmask=[r11] minReg=1 last>
-----------------
<RefPosition #19  @12  RefTypeDef <Ivl:1 V02> STORE_LCL_VAR BB01 regmask=[allInt] minReg=1>
<RefPosition #83  @43  RefTypeUse <Ivl:1 V02> LCL_VAR BB01 regmask=[allInt] minReg=1>
<RefPosition #103 @55  RefTypeUse <Ivl:1 V02> LCL_VAR BB01 regmask=[allInt] minReg=1>
<RefPosition #168 @189 RefTypeUse <Ivl:1 V02> LCL_VAR BB06 regmask=[allInt] minReg=1 last>
-----------------
<RefPosition #0   @0   RefTypeParamDef <Ivl:0 V00>  BB00 regmask=[rcx] minReg=1 fixed regOptional>
<RefPosition #105 @63  RefTypeUse <Ivl:0 V00> LCL_VAR BB01 regmask=[allInt] minReg=1 regOptional>
<RefPosition #116 @95  RefTypeUse <Ivl:0 V00> LCL_VAR BB03 regmask=[allInt] minReg=1>
<RefPosition #120 @105 RefTypeUse <Ivl:0 V00> LCL_VAR BB03 regmask=[allInt] minReg=1 last>
-----------------
<RefPosition #37  @20  RefTypeDef <Ivl:2 V04> STORE_LCL_VAR BB01 regmask=[allInt] minReg=1>
<RefPosition #64  @37  RefTypeUse <Ivl:2 V04> LCL_VAR BB01 regmask=[allInt] minReg=1>
<RefPosition #88  @47  RefTypeUse <Ivl:2 V04> LCL_VAR BB01 regmask=[rdx] minReg=1 last fixed>
-----------------
<RefPosition #172 @194 RefTypeDef <Ivl:14 V25> STORE_LCL_VAR BB06 regmask=[allInt] minReg=1>
<RefPosition #173 @199 RefTypeUse <Ivl:14 V25> LCL_VAR BB06 regmask=[allInt] minReg=1>
<RefPosition #175 @207 RefTypeUse <Ivl:14 V25> LCL_VAR BB06 regmask=[allInt] minReg=1 last>
-----------------
<RefPosition #169 @190 RefTypeDef <Ivl:15 V26> STORE_LCL_VAR BB06 regmask=[allInt] minReg=1>
<RefPosition #178 @211 RefTypeUse <Ivl:15 V26> LCL_VAR BB06 regmask=[rcx] minReg=1 last fixed>
-----------------
<RefPosition #123 @108 RefTypeDef <Ivl:3 V08> STORE_LCL_VAR BB03 regmask=[allInt] minReg=1>
<RefPosition #131 @129 RefTypeUse <Ivl:3 V08> LCL_VAR BB03 regmask=[allInt] minReg=1 regOptional>
<RefPosition #157 @165 RefTypeUse <Ivl:3 V08> LCL_VAR BB05 regmask=[allInt] minReg=1 last>
-----------------
<RefPosition #130 @122 RefTypeDef <Ivl:5 V14> STORE_LCL_VAR BB03 regmask=[allInt] minReg=1>
<RefPosition #134 @139 RefTypeUse <Ivl:5 V14> LCL_VAR BB04 regmask=[rcx] minReg=1 fixed>
<RefPosition #138 @143 RefTypeUse <Ivl:5 V14> LCL_VAR BB04 regmask=[rdx] minReg=1 last fixed>
-----------------
<RefPosition #111 @80  RefTypeDef <Ivl:8 V17> STORE_LCL_VAR BB02 regmask=[allInt] minReg=1>
<RefPosition #160 @172 RefTypeDef <Ivl:8 V17> STORE_LCL_VAR BB05 regmask=[allInt] minReg=1>
<RefPosition #164 @181 RefTypeUse <Ivl:8 V17> LCL_VAR BB06 regmask=[allInt] minReg=1 last>
-----------------
<RefPosition #114 @84  RefTypeDef <Ivl:9 V18> STORE_LCL_VAR BB02 regmask=[allInt] minReg=1>
<RefPosition #162 @176 RefTypeDef <Ivl:9 V18> STORE_LCL_VAR BB05 regmask=[allInt] minReg=1>
<RefPosition #166 @185 RefTypeUse <Ivl:9 V18> LCL_VAR BB06 regmask=[allInt] minReg=1 last>
-----------------
<RefPosition #119 @98  RefTypeDef <Ivl:4 V09> STORE_LCL_VAR BB03 regmask=[allInt] minReg=1>
<RefPosition #153 @153 RefTypeUse <Ivl:4 V09> LCL_VAR BB05 regmask=[allInt] minReg=1 last>
-----------------
<RefPosition #165 @182 RefTypeDef <Ivl:6 V15> STORE_LCL_VAR BB06 regmask=[allInt] minReg=1>
<RefPosition #174 @199 RefTypeUse <Ivl:6 V15> LCL_VAR BB06 regmask=[allInt] minReg=1 last>
-----------------
<RefPosition #167 @186 RefTypeDef <Ivl:7 V16> STORE_LCL_VAR BB06 regmask=[allInt] minReg=1>
<RefPosition #176 @207 RefTypeUse <Ivl:7 V16> LCL_VAR BB06 regmask=[allInt] minReg=1 last>
-----------------
<RefPosition #128 @116 RefTypeDef <Ivl:16 V27> STORE_LCL_VAR BB03 regmask=[allInt] minReg=1>
<RefPosition #129 @121 RefTypeUse <Ivl:16 V27> LCL_VAR BB03 regmask=[allInt] minReg=1 last>
-----------------
<RefPosition #156 @160 RefTypeDef <Ivl:10 V19> STORE_LCL_VAR BB05 regmask=[allInt] minReg=1>
<RefPosition #159 @171 RefTypeUse <Ivl:10 V19> LCL_VAR BB05 regmask=[allInt] minReg=1 last>
-----------------
<RefPosition #109 @74  RefTypeDef <Ivl:12 V21> STORE_LCL_VAR BB02 regmask=[allInt] minReg=1>
<RefPosition #110 @79  RefTypeUse <Ivl:12 V21> LCL_VAR BB02 regmask=[allInt] minReg=1 last>
-----------------
<RefPosition #154 @154 RefTypeDef <Ivl:13 V23> STORE_LCL_VAR BB05 regmask=[allInt] minReg=1>
<RefPosition #155 @159 RefTypeUse <Ivl:13 V23> LCL_VAR BB05 regmask=[allInt] minReg=1 last>
-----------------
<RefPosition #158 @166 RefTypeDef <Ivl:11 V20> STORE_LCL_VAR BB05 regmask=[allInt] minReg=1>
<RefPosition #161 @175 RefTypeUse <Ivl:11 V20> LCL_VAR BB05 regmask=[allInt] minReg=1 last>
TUPLE STYLE DUMP WITH REF POSITIONS
Incoming Parameters:  V00
BB01 [000..012) -> BB03 (cond), preds={} succs={BB02,BB03}
=====
  N003.                    IL_OFFSET IL offset: 0x0
  N005.                    CNS_INT(h) 0xd1ffab1e token
        Def:<I17>(#2)
  N007.                    PUTARG_REG
                               Use:<I17>(#4) Fixed:rcx(#3) *
        Def:<I18>(#6) rcx
  N009.                    CALL help
                               Use:<I18>(#8) Fixed:rcx(#7) *
        Kill: rax rcx rdx r8 r9 r10 r11 
        Def:<I19>(#17) rax Pref:<V02/L1>
  N011.                    V02(L1)
                               Use:<I19>(#18) *
        Def:<V02/L1>(#19) Pref:<V26/L15>
  N013.                    CNS_INT(h) 0xd1ffab1e token
        Def:<I20>(#20)
  N015.                    PUTARG_REG
                               Use:<I20>(#22) Fixed:rcx(#21) *
        Def:<I21>(#24) rcx
  N017.                    CALL help
                               Use:<I21>(#26) Fixed:rcx(#25) *
        Kill: rax rcx rdx r8 r9 r10 r11 
        Def:<I22>(#35) rax Pref:<V04/L2>
  N019.                    V04(L2)
                               Use:<I22>(#36) *
        Def:<V04/L2>(#37)
  N021.                    CNS_INT   0x7ffa40fb0028
        Def:<I23>(#38)
  N023.                    PUTARG_REG
                               Use:<I23>(#40) Fixed:rcx(#39) *
        Def:<I24>(#42) rcx
  N025.                    CNS_INT   6
        Def:<I25>(#43)
  N027.                    PUTARG_REG
                               Use:<I25>(#45) Fixed:rdx(#44) *
        Def:<I26>(#47) rdx
  N029.                    CALL help
                               Use:<I24>(#49) Fixed:rcx(#48) *
                               Use:<I26>(#51) Fixed:rdx(#50) *
        Kill: rax rcx rdx r8 r9 r10 r11 
        Def:<I27>(#60) rax LocalDefUse *
  N031.                    CNS_INT(h) 0xd1ffab1e static Fseq[Value]
        Def:<I28>(#61)
  N033.                    IND      
                               Use:<I28>(#62) *
        Def:<I29>(#63)
  N035.                    V04(L2)
  N037.                    LEA(b+8) 
                               Use:<V04/L2>(#64)
        Def:<I30>(#65)
  N039.                    STOREIND 
                               Use:<I30>(#67) Fixed:rcx(#66) *
                               Use:<I29>(#69) Fixed:rdx(#68) *
        Kill: rax rcx rdx r8 r9 r10 r11 mm0 mm1 mm2 mm3 mm4 mm5 
  N041.                    V02(L1)
  N043.                    LEA(b+16)
                               Use:<V02/L1>(#83)
        Def:<I31>(#84)
  N045.                    V04(L2)
  N047.                    STOREIND 
                               Use:<I31>(#86) Fixed:rcx(#85) *
                               Use:<V04/L2>(#88) Fixed:rdx(#87) *
        Kill: rax rcx rdx r8 r9 r10 r11 mm0 mm1 mm2 mm3 mm4 mm5 
  N049.                    V02(L1)
  N051.                    LEA(b+8) 
  N053.                    CNS_INT   null
        Def:<I32>(#102)
  N055.                    STOREIND 
                               Use:<V02/L1>(#103)
                               Use:<I32>(#104) *
  N057.                    IL_OFFSET IL offset: 0x6
  N059.                    V00(L0)
  N061.                    CNS_INT   null
  N063.                    NE       
                               Use:<V00/L0>(#105)
  N065.                    JTRUE    

BB02 [006..007) -> BB06 (always), preds={BB01} succs={BB06}
=====
  N069.                    IL_OFFSET IL offset: 0x6
  N071.                    CNS_INT   0
        Def:<I33>(#107) Pref:<V21/L12>
  N073.                    V21(L12)
                               Use:<I33>(#108) *
        Def:<V21/L12>(#109) Pref:<V17/L8>
  N075.                    IL_OFFSET IL offset: 0x6
  N077.                    V21(L12)
  N079.                    V17(L8)
                               Use:<V21/L12>(#110) *
        Def:<V17/L8>(#111) Pref:<V15/L6>
  N081.                    CNS_INT   0
        Def:<I34>(#112) Pref:<V18/L9>
  N083.                    V18(L9)
                               Use:<I34>(#113) *
        Def:<V18/L9>(#114) Pref:<V16/L7>

BB03 [006..007) -> BB05 (cond), preds={BB01} succs={BB04,BB05}
=====
  N087.                    IL_OFFSET IL offset: 0x6
  N089.                    IL_OFFSET IL offset: 0x6
  N091.                    V00(L0)
  N093.                    CNS_INT   12 field offset Fseq[_firstChar]
  N095.                    ADD      
                               Use:<V00/L0>(#116)
        Def:<I35>(#117) Pref:<V09/L4>
  N097.                    V09(L4)
                               Use:<I35>(#118) *
        Def:<V09/L4>(#119) Pref:<V23/L13>
  N099.                    IL_OFFSET IL offset: 0x6
  N101.                    V00(L0)
  N103.                    LEA(b+8) 
  N105.                    IND      
                               Use:<V00/L0>(#120) *
        Def:<I36>(#121) Pref:<V08/L3>
  N107.                    V08(L3)
                               Use:<I36>(#122) *
        Def:<V08/L3>(#123) Pref:<V20/L11>
  N109.                    IL_OFFSET IL offset: 0x6
  N111.                    CNS_INT(h) 0xD1FFAB1E [ICON_STR_HDL]
        Def:<I37>(#124)
  N113.                    IND      
                               Use:<I37>(#125) *
        Def:<I38>(#126) Pref:<V27/L16>
  N115.                    V27(L16)
                               Use:<I38>(#127) *
        Def:<V27/L16>(#128) Pref:<V14/L5>
  N117.                    IL_OFFSET IL offset: 0x6
  N119.                    V27(L16)
  N121.                    V14(L5)
                               Use:<V27/L16>(#129) *
        Def:<V14/L5>(#130)
  N123.                    IL_OFFSET IL offset: 0x6
  N125.                    V08(L3)
  N127.                    CNS_INT   0
  N129.                    GE       
                               Use:<V08/L3>(#131)
  N131.                    JTRUE    

BB04 [006..007), preds={BB03} succs={BB05}
=====
  N135.                    IL_OFFSET IL offset: 0x6
  N137.                    V14(L5)
  N139.                    PUTARG_REG
                               Use:<V14/L5>(#134) Fixed:rcx(#133)
        Def:<I39>(#136) rcx Pref:<V14/L5>
  N141.                    V14(L5)
  N143.                    PUTARG_REG
                               Use:<V14/L5>(#138) Fixed:rdx(#137) *
        Def:<I40>(#140) rdx
  N145.                    CALL     
                               Use:<I39>(#142) Fixed:rcx(#141) *
                               Use:<I40>(#144) Fixed:rdx(#143) *
        Kill: rax rcx rdx r8 r9 r10 r11 

BB05 [006..007), preds={BB03,BB04} succs={BB06}
=====
  N149.                    IL_OFFSET IL offset: 0x6
  N151.                    V09(L4)
  N153.                    V23(L13)
                               Use:<V09/L4>(#153) *
        Def:<V23/L13>(#154) Pref:<V19/L10>
  N155.                    IL_OFFSET IL offset: 0x6
  N157.                    V23(L13)
  N159.                    V19(L10)
                               Use:<V23/L13>(#155) *
        Def:<V19/L10>(#156) Pref:<V17/L8>
  N161.                    IL_OFFSET IL offset: 0x6
  N163.                    V08(L3)
  N165.                    V20(L11)
                               Use:<V08/L3>(#157) *
        Def:<V20/L11>(#158) Pref:<V18/L9>
  N167.                    IL_OFFSET IL offset: 0x6
  N169.                    V19(L10)
  N171.                    V17(L8)
                               Use:<V19/L10>(#159) *
        Def:<V17/L8>(#160) Pref:<V15/L6>
  N173.                    V20(L11)
  N175.                    V18(L9)
                               Use:<V20/L11>(#161) *
        Def:<V18/L9>(#162) Pref:<V16/L7>

BB06 [???..???) (return), preds={BB02,BB05} succs={}
=====
  N179.                    V17(L8)
  N181.                    V15(L6)
                               Use:<V17/L8>(#164) *
        Def:<V15/L6>(#165)
  N183.                    V18(L9)
  N185.                    V16(L7)
                               Use:<V18/L9>(#166) *
        Def:<V16/L7>(#167)
  N187.                    V02(L1)
  N189.                    V26(L15)
                               Use:<V02/L1>(#168) *
        Def:<V26/L15>(#169)
  N191.                    LCL_VAR_ADDR V24 tmp23         NA
        Def:<I41>(#170) Pref:<V25/L14>
  N193.                    V25(L14)
                               Use:<I41>(#171) *
        Def:<V25/L14>(#172)
  N195.                    V25(L14)
  N197.                    V15(L6)
  N199.                    STOREIND 
                               Use:<V25/L14>(#173)
                               Use:<V15/L6>(#174) *
  N201.                    V25(L14)
  N203.                    LEA(b+8) 
  N205.                    V16(L7)
  N207.                    STOREIND 
                               Use:<V25/L14>(#175) *
                               Use:<V16/L7>(#176) *
  N209.                    V26(L15)
  N211.                    PUTARG_REG
                               Use:<V26/L15>(#178) Fixed:rcx(#177) *
        Def:<I42>(#180) rcx
  N213.                    LCL_VAR_ADDR V24 tmp23         NA
        Def:<I43>(#181)
  N215.                    PUTARG_REG
                               Use:<I43>(#183) Fixed:rdx(#182) *
        Def:<I44>(#185) rdx
  N217.                    CALL     
                               Use:<I42>(#187) Fixed:rcx(#186) *
                               Use:<I44>(#189) Fixed:rdx(#188) *
        Kill: rax rcx rdx r8 r9 r10 r11 
  N219.                    IL_OFFSET IL offset: 0x11
  N221.                    RETURN   




Linear scan intervals after buildIntervals:
Interval  0: (V00) ref RefPositions {#0@0 #105@63 #116@95 #120@105} physReg:rcx Preferences=[rbx rbp rsi rdi r12-r15]
Interval  1: (V02) ref RefPositions {#19@12 #83@43 #103@55 #168@189} physReg:NA Preferences=[rbx rbp rsi rdi r12-r15] RelatedInterval <V26/L15>
Interval  2: (V04) ref RefPositions {#37@20 #64@37 #88@47} physReg:NA Preferences=[rbx rbp rsi rdi r12-r15]
Interval  3: (V08) int RefPositions {#123@108 #131@129 #157@165} physReg:NA Preferences=[rbx rbp rsi rdi r12-r15] RelatedInterval <V20/L11>
Interval  4: (V09) byref RefPositions {#119@98 #153@153} physReg:NA Preferences=[rbx rbp rsi rdi r12-r15] RelatedInterval <V23/L13>
Interval  5: (V14) ref RefPositions {#130@122 #134@139 #138@143} physReg:NA Preferences=[rcx rdx]
Interval  6: (V15) byref (field) RefPositions {#165@182 #174@199} physReg:NA Preferences=[allInt]
Interval  7: (V16) int (field) RefPositions {#167@186 #176@207} physReg:NA Preferences=[allInt]
Interval  8: (V17) byref (field) RefPositions {#111@80 #160@172 #164@181} physReg:NA Preferences=[allInt] RelatedInterval <V15/L6>
Interval  9: (V18) int (field) RefPositions {#114@84 #162@176 #166@185} physReg:NA Preferences=[allInt] RelatedInterval <V16/L7>
Interval 10: (V19) byref (field) RefPositions {#156@160 #159@171} physReg:NA Preferences=[allInt] RelatedInterval <V17/L8>
Interval 11: (V20) int (field) RefPositions {#158@166 #161@175} physReg:NA Preferences=[allInt] RelatedInterval <V18/L9>
Interval 12: (V21) byref (field) RefPositions {#109@74 #110@79} physReg:NA Preferences=[allInt] RelatedInterval <V17/L8>
Interval 13: (V23) byref (field) RefPositions {#154@154 #155@159} physReg:NA Preferences=[allInt] RelatedInterval <V19/L10>
Interval 14: (V25) byref RefPositions {#172@194 #173@199 #175@207} physReg:NA Preferences=[allInt]
Interval 15: (V26) ref RefPositions {#169@190 #178@211} physReg:NA Preferences=[rcx]
Interval 16: (V27) ref RefPositions {#128@116 #129@121} physReg:NA Preferences=[allInt] RelatedInterval <V14/L5>
Interval 17: long (constant) RefPositions {#2@6 #4@7} physReg:NA Preferences=[rcx]
Interval 18: long RefPositions {#6@8 #8@9} physReg:NA Preferences=[rcx]
Interval 19: ref RefPositions {#17@10 #18@11} physReg:NA Preferences=[rax] RelatedInterval <V02/L1>
Interval 20: long (constant) RefPositions {#20@14 #22@15} physReg:NA Preferences=[rcx]
Interval 21: long RefPositions {#24@16 #26@17} physReg:NA Preferences=[rcx]
Interval 22: ref RefPositions {#35@18 #36@19} physReg:NA Preferences=[rax] RelatedInterval <V04/L2>
Interval 23: long (constant) RefPositions {#38@22 #40@23} physReg:NA Preferences=[rcx]
Interval 24: long RefPositions {#42@24 #49@29} physReg:NA Preferences=[rcx]
Interval 25: int (constant) RefPositions {#43@26 #45@27} physReg:NA Preferences=[rdx]
Interval 26: int RefPositions {#47@28 #51@29} physReg:NA Preferences=[rdx]
Interval 27: long RefPositions {#60@30} physReg:NA Preferences=[rax]
Interval 28: long (constant) RefPositions {#61@32 #62@33} physReg:NA Preferences=[allInt]
Interval 29: ref RefPositions {#63@34 #69@39} physReg:NA Preferences=[rdx]
Interval 30: byref RefPositions {#65@38 #67@39} physReg:NA Preferences=[rcx]
Interval 31: byref RefPositions {#84@44 #86@47} physReg:NA Preferences=[rcx]
Interval 32: ref (constant) RefPositions {#102@54 #104@55} physReg:NA Preferences=[allInt]
Interval 33: byref (constant) RefPositions {#107@72 #108@73} physReg:NA Preferences=[allInt] RelatedInterval <V21/L12>
Interval 34: int (constant) RefPositions {#112@82 #113@83} physReg:NA Preferences=[allInt] RelatedInterval <V18/L9>
Interval 35: byref RefPositions {#117@96 #118@97} physReg:NA Preferences=[allInt] RelatedInterval <V09/L4>
Interval 36: int RefPositions {#121@106 #122@107} physReg:NA Preferences=[allInt] RelatedInterval <V08/L3>
Interval 37: long (constant) RefPositions {#124@112 #125@113} physReg:NA Preferences=[allInt]
Interval 38: ref RefPositions {#126@114 #127@115} physReg:NA Preferences=[allInt] RelatedInterval <V27/L16>
Interval 39: ref (specialPutArg) RefPositions {#136@140 #142@145} physReg:NA Preferences=[rcx] RelatedInterval <V14/L5>
Interval 40: ref RefPositions {#140@144 #144@145} physReg:NA Preferences=[rdx]
Interval 41: byref RefPositions {#170@192 #171@193} physReg:NA Preferences=[allInt] RelatedInterval <V25/L14>
Interval 42: ref RefPositions {#180@212 #187@217} physReg:NA Preferences=[rcx]
Interval 43: byref RefPositions {#181@214 #183@215} physReg:NA Preferences=[rdx]
Interval 44: byref RefPositions {#185@216 #189@217} physReg:NA Preferences=[rdx]

*************** In LinearScan::allocateRegisters()

Linear scan intervals before allocateRegisters:
Interval  0: (V00) ref RefPositions {#0@0 #105@63 #116@95 #120@105} physReg:rcx Preferences=[rbx rbp rsi rdi r12-r15]
Interval  1: (V02) ref RefPositions {#19@12 #83@43 #103@55 #168@189} physReg:NA Preferences=[rbx rbp rsi rdi r12-r15] RelatedInterval <V26/L15>
Interval  2: (V04) ref RefPositions {#37@20 #64@37 #88@47} physReg:NA Preferences=[rbx rbp rsi rdi r12-r15]
Interval  3: (V08) int RefPositions {#123@108 #131@129 #157@165} physReg:NA Preferences=[rbx rbp rsi rdi r12-r15] RelatedInterval <V20/L11>
Interval  4: (V09) byref RefPositions {#119@98 #153@153} physReg:NA Preferences=[rbx rbp rsi rdi r12-r15] RelatedInterval <V23/L13>
Interval  5: (V14) ref RefPositions {#130@122 #134@139 #138@143} physReg:NA Preferences=[rcx rdx]
Interval  6: (V15) byref (field) RefPositions {#165@182 #174@199} physReg:NA Preferences=[allInt]
Interval  7: (V16) int (field) RefPositions {#167@186 #176@207} physReg:NA Preferences=[allInt]
Interval  8: (V17) byref (field) RefPositions {#111@80 #160@172 #164@181} physReg:NA Preferences=[allInt] RelatedInterval <V15/L6>
Interval  9: (V18) int (field) RefPositions {#114@84 #162@176 #166@185} physReg:NA Preferences=[allInt] RelatedInterval <V16/L7>
Interval 10: (V19) byref (field) RefPositions {#156@160 #159@171} physReg:NA Preferences=[allInt] RelatedInterval <V17/L8>
Interval 11: (V20) int (field) RefPositions {#158@166 #161@175} physReg:NA Preferences=[allInt] RelatedInterval <V18/L9>
Interval 12: (V21) byref (field) RefPositions {#109@74 #110@79} physReg:NA Preferences=[allInt] RelatedInterval <V17/L8>
Interval 13: (V23) byref (field) RefPositions {#154@154 #155@159} physReg:NA Preferences=[allInt] RelatedInterval <V19/L10>
Interval 14: (V25) byref RefPositions {#172@194 #173@199 #175@207} physReg:NA Preferences=[allInt]
Interval 15: (V26) ref RefPositions {#169@190 #178@211} physReg:NA Preferences=[rcx]
Interval 16: (V27) ref RefPositions {#128@116 #129@121} physReg:NA Preferences=[allInt] RelatedInterval <V14/L5>
Interval 17: long (constant) RefPositions {#2@6 #4@7} physReg:NA Preferences=[rcx]
Interval 18: long RefPositions {#6@8 #8@9} physReg:NA Preferences=[rcx]
Interval 19: ref RefPositions {#17@10 #18@11} physReg:NA Preferences=[rax] RelatedInterval <V02/L1>
Interval 20: long (constant) RefPositions {#20@14 #22@15} physReg:NA Preferences=[rcx]
Interval 21: long RefPositions {#24@16 #26@17} physReg:NA Preferences=[rcx]
Interval 22: ref RefPositions {#35@18 #36@19} physReg:NA Preferences=[rax] RelatedInterval <V04/L2>
Interval 23: long (constant) RefPositions {#38@22 #40@23} physReg:NA Preferences=[rcx]
Interval 24: long RefPositions {#42@24 #49@29} physReg:NA Preferences=[rcx]
Interval 25: int (constant) RefPositions {#43@26 #45@27} physReg:NA Preferences=[rdx]
Interval 26: int RefPositions {#47@28 #51@29} physReg:NA Preferences=[rdx]
Interval 27: long RefPositions {#60@30} physReg:NA Preferences=[rax]
Interval 28: long (constant) RefPositions {#61@32 #62@33} physReg:NA Preferences=[allInt]
Interval 29: ref RefPositions {#63@34 #69@39} physReg:NA Preferences=[rdx]
Interval 30: byref RefPositions {#65@38 #67@39} physReg:NA Preferences=[rcx]
Interval 31: byref RefPositions {#84@44 #86@47} physReg:NA Preferences=[rcx]
Interval 32: ref (constant) RefPositions {#102@54 #104@55} physReg:NA Preferences=[allInt]
Interval 33: byref (constant) RefPositions {#107@72 #108@73} physReg:NA Preferences=[allInt] RelatedInterval <V21/L12>
Interval 34: int (constant) RefPositions {#112@82 #113@83} physReg:NA Preferences=[allInt] RelatedInterval <V18/L9>
Interval 35: byref RefPositions {#117@96 #118@97} physReg:NA Preferences=[allInt] RelatedInterval <V09/L4>
Interval 36: int RefPositions {#121@106 #122@107} physReg:NA Preferences=[allInt] RelatedInterval <V08/L3>
Interval 37: long (constant) RefPositions {#124@112 #125@113} physReg:NA Preferences=[allInt]
Interval 38: ref RefPositions {#126@114 #127@115} physReg:NA Preferences=[allInt] RelatedInterval <V27/L16>
Interval 39: ref (specialPutArg) RefPositions {#136@140 #142@145} physReg:NA Preferences=[rcx] RelatedInterval <V14/L5>
Interval 40: ref RefPositions {#140@144 #144@145} physReg:NA Preferences=[rdx]
Interval 41: byref RefPositions {#170@192 #171@193} physReg:NA Preferences=[allInt] RelatedInterval <V25/L14>
Interval 42: ref RefPositions {#180@212 #187@217} physReg:NA Preferences=[rcx]
Interval 43: byref RefPositions {#181@214 #183@215} physReg:NA Preferences=[rdx]
Interval 44: byref RefPositions {#185@216 #189@217} physReg:NA Preferences=[rdx]

------------
REFPOSITIONS BEFORE ALLOCATION: 
------------
<RefPosition #0   @0   RefTypeParamDef <Ivl:0 V00>  BB00 regmask=[rcx] minReg=1 fixed regOptional>
<RefPosition #1   @1   RefTypeBB  BB01 regmask=[] minReg=1>
<RefPosition #2   @6   RefTypeDef <Ivl:17> CNS_INT BB01 regmask=[rcx] minReg=1>
<RefPosition #3   @7   RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #4   @7   RefTypeUse <Ivl:17>  BB01 regmask=[rcx] minReg=1 last fixed>
<RefPosition #5   @8   RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #6   @8   RefTypeDef <Ivl:18> PUTARG_REG BB01 regmask=[rcx] minReg=1 fixed>
<RefPosition #7   @9   RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #8   @9   RefTypeUse <Ivl:18>  BB01 regmask=[rcx] minReg=1 last fixed>
<RefPosition #9   @10  RefTypeKill <Reg:rax>  BB01 regmask=[rax] minReg=1 last>
<RefPosition #10  @10  RefTypeKill <Reg:rcx>  BB01 regmask=[rcx] minReg=1 last>
<RefPosition #11  @10  RefTypeKill <Reg:rdx>  BB01 regmask=[rdx] minReg=1 last>
<RefPosition #12  @10  RefTypeKill <Reg:r8 >  BB01 regmask=[r8] minReg=1 last>
<RefPosition #13  @10  RefTypeKill <Reg:r9 >  BB01 regmask=[r9] minReg=1 last>
<RefPosition #14  @10  RefTypeKill <Reg:r10>  BB01 regmask=[r10] minReg=1 last>
<RefPosition #15  @10  RefTypeKill <Reg:r11>  BB01 regmask=[r11] minReg=1 last>
<RefPosition #16  @10  RefTypeFixedReg <Reg:rax>  BB01 regmask=[rax] minReg=1>
<RefPosition #17  @10  RefTypeDef <Ivl:19> CALL BB01 regmask=[rax] minReg=1 fixed>
<RefPosition #18  @11  RefTypeUse <Ivl:19>  BB01 regmask=[allInt] minReg=1 last>
<RefPosition #19  @12  RefTypeDef <Ivl:1 V02> STORE_LCL_VAR BB01 regmask=[allInt] minReg=1>
<RefPosition #20  @14  RefTypeDef <Ivl:20> CNS_INT BB01 regmask=[rcx] minReg=1>
<RefPosition #21  @15  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #22  @15  RefTypeUse <Ivl:20>  BB01 regmask=[rcx] minReg=1 last fixed>
<RefPosition #23  @16  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #24  @16  RefTypeDef <Ivl:21> PUTARG_REG BB01 regmask=[rcx] minReg=1 fixed>
<RefPosition #25  @17  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #26  @17  RefTypeUse <Ivl:21>  BB01 regmask=[rcx] minReg=1 last fixed>
<RefPosition #27  @18  RefTypeKill <Reg:rax>  BB01 regmask=[rax] minReg=1 last>
<RefPosition #28  @18  RefTypeKill <Reg:rcx>  BB01 regmask=[rcx] minReg=1 last>
<RefPosition #29  @18  RefTypeKill <Reg:rdx>  BB01 regmask=[rdx] minReg=1 last>
<RefPosition #30  @18  RefTypeKill <Reg:r8 >  BB01 regmask=[r8] minReg=1 last>
<RefPosition #31  @18  RefTypeKill <Reg:r9 >  BB01 regmask=[r9] minReg=1 last>
<RefPosition #32  @18  RefTypeKill <Reg:r10>  BB01 regmask=[r10] minReg=1 last>
<RefPosition #33  @18  RefTypeKill <Reg:r11>  BB01 regmask=[r11] minReg=1 last>
<RefPosition #34  @18  RefTypeFixedReg <Reg:rax>  BB01 regmask=[rax] minReg=1>
<RefPosition #35  @18  RefTypeDef <Ivl:22> CALL BB01 regmask=[rax] minReg=1 fixed>
<RefPosition #36  @19  RefTypeUse <Ivl:22>  BB01 regmask=[allInt] minReg=1 last>
<RefPosition #37  @20  RefTypeDef <Ivl:2 V04> STORE_LCL_VAR BB01 regmask=[allInt] minReg=1>
<RefPosition #38  @22  RefTypeDef <Ivl:23> CNS_INT BB01 regmask=[rcx] minReg=1>
<RefPosition #39  @23  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #40  @23  RefTypeUse <Ivl:23>  BB01 regmask=[rcx] minReg=1 last fixed>
<RefPosition #41  @24  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #42  @24  RefTypeDef <Ivl:24> PUTARG_REG BB01 regmask=[rcx] minReg=1 fixed>
<RefPosition #43  @26  RefTypeDef <Ivl:25> CNS_INT BB01 regmask=[rdx] minReg=1>
<RefPosition #44  @27  RefTypeFixedReg <Reg:rdx>  BB01 regmask=[rdx] minReg=1>
<RefPosition #45  @27  RefTypeUse <Ivl:25>  BB01 regmask=[rdx] minReg=1 last fixed>
<RefPosition #46  @28  RefTypeFixedReg <Reg:rdx>  BB01 regmask=[rdx] minReg=1>
<RefPosition #47  @28  RefTypeDef <Ivl:26> PUTARG_REG BB01 regmask=[rdx] minReg=1 fixed>
<RefPosition #48  @29  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #49  @29  RefTypeUse <Ivl:24>  BB01 regmask=[rcx] minReg=1 last fixed>
<RefPosition #50  @29  RefTypeFixedReg <Reg:rdx>  BB01 regmask=[rdx] minReg=1>
<RefPosition #51  @29  RefTypeUse <Ivl:26>  BB01 regmask=[rdx] minReg=1 last fixed>
<RefPosition #52  @30  RefTypeKill <Reg:rax>  BB01 regmask=[rax] minReg=1 last>
<RefPosition #53  @30  RefTypeKill <Reg:rcx>  BB01 regmask=[rcx] minReg=1 last>
<RefPosition #54  @30  RefTypeKill <Reg:rdx>  BB01 regmask=[rdx] minReg=1 last>
<RefPosition #55  @30  RefTypeKill <Reg:r8 >  BB01 regmask=[r8] minReg=1 last>
<RefPosition #56  @30  RefTypeKill <Reg:r9 >  BB01 regmask=[r9] minReg=1 last>
<RefPosition #57  @30  RefTypeKill <Reg:r10>  BB01 regmask=[r10] minReg=1 last>
<RefPosition #58  @30  RefTypeKill <Reg:r11>  BB01 regmask=[r11] minReg=1 last>
<RefPosition #59  @30  RefTypeFixedReg <Reg:rax>  BB01 regmask=[rax] minReg=1>
<RefPosition #60  @30  RefTypeDef <Ivl:27> CALL BB01 regmask=[rax] minReg=1 last fixed local>
<RefPosition #61  @32  RefTypeDef <Ivl:28> CNS_INT BB01 regmask=[allInt] minReg=1>
<RefPosition #62  @33  RefTypeUse <Ivl:28>  BB01 regmask=[allInt] minReg=1 last>
<RefPosition #63  @34  RefTypeDef <Ivl:29> IND BB01 regmask=[rdx] minReg=1>
<RefPosition #64  @37  RefTypeUse <Ivl:2 V04> LCL_VAR BB01 regmask=[allInt] minReg=1>
<RefPosition #65  @38  RefTypeDef <Ivl:30> LEA BB01 regmask=[rcx] minReg=1>
<RefPosition #66  @39  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #67  @39  RefTypeUse <Ivl:30>  BB01 regmask=[rcx] minReg=1 last fixed>
<RefPosition #68  @39  RefTypeFixedReg <Reg:rdx>  BB01 regmask=[rdx] minReg=1>
<RefPosition #69  @39  RefTypeUse <Ivl:29>  BB01 regmask=[rdx] minReg=1 last fixed>
<RefPosition #70  @40  RefTypeKill <Reg:rax>  BB01 regmask=[rax] minReg=1 last>
<RefPosition #71  @40  RefTypeKill <Reg:rcx>  BB01 regmask=[rcx] minReg=1 last>
<RefPosition #72  @40  RefTypeKill <Reg:rdx>  BB01 regmask=[rdx] minReg=1 last>
<RefPosition #73  @40  RefTypeKill <Reg:r8 >  BB01 regmask=[r8] minReg=1 last>
<RefPosition #74  @40  RefTypeKill <Reg:r9 >  BB01 regmask=[r9] minReg=1 last>
<RefPosition #75  @40  RefTypeKill <Reg:r10>  BB01 regmask=[r10] minReg=1 last>
<RefPosition #76  @40  RefTypeKill <Reg:r11>  BB01 regmask=[r11] minReg=1 last>
<RefPosition #77  @40  RefTypeKill <Reg:mm0>  BB01 regmask=[mm0] minReg=1 last>
<RefPosition #78  @40  RefTypeKill <Reg:mm1>  BB01 regmask=[mm1] minReg=1 last>
<RefPosition #79  @40  RefTypeKill <Reg:mm2>  BB01 regmask=[mm2] minReg=1 last>
<RefPosition #80  @40  RefTypeKill <Reg:mm3>  BB01 regmask=[mm3] minReg=1 last>
<RefPosition #81  @40  RefTypeKill <Reg:mm4>  BB01 regmask=[mm4] minReg=1 last>
<RefPosition #82  @40  RefTypeKill <Reg:mm5>  BB01 regmask=[mm5] minReg=1 last>
<RefPosition #83  @43  RefTypeUse <Ivl:1 V02> LCL_VAR BB01 regmask=[allInt] minReg=1>
<RefPosition #84  @44  RefTypeDef <Ivl:31> LEA BB01 regmask=[rcx] minReg=1>
<RefPosition #85  @47  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #86  @47  RefTypeUse <Ivl:31>  BB01 regmask=[rcx] minReg=1 last fixed>
<RefPosition #87  @47  RefTypeFixedReg <Reg:rdx>  BB01 regmask=[rdx] minReg=1>
<RefPosition #88  @47  RefTypeUse <Ivl:2 V04> LCL_VAR BB01 regmask=[rdx] minReg=1 last fixed>
<RefPosition #89  @48  RefTypeKill <Reg:rax>  BB01 regmask=[rax] minReg=1 last>
<RefPosition #90  @48  RefTypeKill <Reg:rcx>  BB01 regmask=[rcx] minReg=1 last>
<RefPosition #91  @48  RefTypeKill <Reg:rdx>  BB01 regmask=[rdx] minReg=1 last>
<RefPosition #92  @48  RefTypeKill <Reg:r8 >  BB01 regmask=[r8] minReg=1 last>
<RefPosition #93  @48  RefTypeKill <Reg:r9 >  BB01 regmask=[r9] minReg=1 last>
<RefPosition #94  @48  RefTypeKill <Reg:r10>  BB01 regmask=[r10] minReg=1 last>
<RefPosition #95  @48  RefTypeKill <Reg:r11>  BB01 regmask=[r11] minReg=1 last>
<RefPosition #96  @48  RefTypeKill <Reg:mm0>  BB01 regmask=[mm0] minReg=1 last>
<RefPosition #97  @48  RefTypeKill <Reg:mm1>  BB01 regmask=[mm1] minReg=1 last>
<RefPosition #98  @48  RefTypeKill <Reg:mm2>  BB01 regmask=[mm2] minReg=1 last>
<RefPosition #99  @48  RefTypeKill <Reg:mm3>  BB01 regmask=[mm3] minReg=1 last>
<RefPosition #100 @48  RefTypeKill <Reg:mm4>  BB01 regmask=[mm4] minReg=1 last>
<RefPosition #101 @48  RefTypeKill <Reg:mm5>  BB01 regmask=[mm5] minReg=1 last>
<RefPosition #102 @54  RefTypeDef <Ivl:32> CNS_INT BB01 regmask=[allInt] minReg=1>
<RefPosition #103 @55  RefTypeUse <Ivl:1 V02> LCL_VAR BB01 regmask=[allInt] minReg=1>
<RefPosition #104 @55  RefTypeUse <Ivl:32>  BB01 regmask=[allInt] minReg=1 last>
<RefPosition #105 @63  RefTypeUse <Ivl:0 V00> LCL_VAR BB01 regmask=[allInt] minReg=1 regOptional>
<RefPosition #106 @67  RefTypeBB  BB02 regmask=[] minReg=1>
<RefPosition #107 @72  RefTypeDef <Ivl:33> CNS_INT BB02 regmask=[allInt] minReg=1>
<RefPosition #108 @73  RefTypeUse <Ivl:33>  BB02 regmask=[allInt] minReg=1 last>
<RefPosition #109 @74  RefTypeDef <Ivl:12 V21> STORE_LCL_VAR BB02 regmask=[allInt] minReg=1>
<RefPosition #110 @79  RefTypeUse <Ivl:12 V21> LCL_VAR BB02 regmask=[allInt] minReg=1 last>
<RefPosition #111 @80  RefTypeDef <Ivl:8 V17> STORE_LCL_VAR BB02 regmask=[allInt] minReg=1>
<RefPosition #112 @82  RefTypeDef <Ivl:34> CNS_INT BB02 regmask=[allInt] minReg=1>
<RefPosition #113 @83  RefTypeUse <Ivl:34>  BB02 regmask=[allInt] minReg=1 last>
<RefPosition #114 @84  RefTypeDef <Ivl:9 V18> STORE_LCL_VAR BB02 regmask=[allInt] minReg=1>
<RefPosition #115 @85  RefTypeBB  BB03 regmask=[] minReg=1>
<RefPosition #116 @95  RefTypeUse <Ivl:0 V00> LCL_VAR BB03 regmask=[allInt] minReg=1>
<RefPosition #117 @96  RefTypeDef <Ivl:35> ADD BB03 regmask=[allInt] minReg=1>
<RefPosition #118 @97  RefTypeUse <Ivl:35>  BB03 regmask=[allInt] minReg=1 last>
<RefPosition #119 @98  RefTypeDef <Ivl:4 V09> STORE_LCL_VAR BB03 regmask=[allInt] minReg=1>
<RefPosition #120 @105 RefTypeUse <Ivl:0 V00> LCL_VAR BB03 regmask=[allInt] minReg=1 last>
<RefPosition #121 @106 RefTypeDef <Ivl:36> IND BB03 regmask=[allInt] minReg=1>
<RefPosition #122 @107 RefTypeUse <Ivl:36>  BB03 regmask=[allInt] minReg=1 last>
<RefPosition #123 @108 RefTypeDef <Ivl:3 V08> STORE_LCL_VAR BB03 regmask=[allInt] minReg=1>
<RefPosition #124 @112 RefTypeDef <Ivl:37> CNS_INT BB03 regmask=[allInt] minReg=1>
<RefPosition #125 @113 RefTypeUse <Ivl:37>  BB03 regmask=[allInt] minReg=1 last>
<RefPosition #126 @114 RefTypeDef <Ivl:38> IND BB03 regmask=[allInt] minReg=1>
<RefPosition #127 @115 RefTypeUse <Ivl:38>  BB03 regmask=[allInt] minReg=1 last>
<RefPosition #128 @116 RefTypeDef <Ivl:16 V27> STORE_LCL_VAR BB03 regmask=[allInt] minReg=1>
<RefPosition #129 @121 RefTypeUse <Ivl:16 V27> LCL_VAR BB03 regmask=[allInt] minReg=1 last>
<RefPosition #130 @122 RefTypeDef <Ivl:5 V14> STORE_LCL_VAR BB03 regmask=[allInt] minReg=1>
<RefPosition #131 @129 RefTypeUse <Ivl:3 V08> LCL_VAR BB03 regmask=[allInt] minReg=1 regOptional>
<RefPosition #132 @133 RefTypeBB  BB04 regmask=[] minReg=1>
<RefPosition #133 @139 RefTypeFixedReg <Reg:rcx>  BB04 regmask=[rcx] minReg=1>
<RefPosition #134 @139 RefTypeUse <Ivl:5 V14> LCL_VAR BB04 regmask=[rcx] minReg=1 fixed>
<RefPosition #135 @140 RefTypeFixedReg <Reg:rcx>  BB04 regmask=[rcx] minReg=1>
<RefPosition #136 @140 RefTypeDef <Ivl:39> PUTARG_REG BB04 regmask=[rcx] minReg=1 fixed>
<RefPosition #137 @143 RefTypeFixedReg <Reg:rdx>  BB04 regmask=[rdx] minReg=1>
<RefPosition #138 @143 RefTypeUse <Ivl:5 V14> LCL_VAR BB04 regmask=[rdx] minReg=1 last fixed>
<RefPosition #139 @144 RefTypeFixedReg <Reg:rdx>  BB04 regmask=[rdx] minReg=1>
<RefPosition #140 @144 RefTypeDef <Ivl:40> PUTARG_REG BB04 regmask=[rdx] minReg=1 fixed>
<RefPosition #141 @145 RefTypeFixedReg <Reg:rcx>  BB04 regmask=[rcx] minReg=1>
<RefPosition #142 @145 RefTypeUse <Ivl:39>  BB04 regmask=[rcx] minReg=1 last fixed>
<RefPosition #143 @145 RefTypeFixedReg <Reg:rdx>  BB04 regmask=[rdx] minReg=1>
<RefPosition #144 @145 RefTypeUse <Ivl:40>  BB04 regmask=[rdx] minReg=1 last fixed>
<RefPosition #145 @146 RefTypeKill <Reg:rax>  BB04 regmask=[rax] minReg=1 last>
<RefPosition #146 @146 RefTypeKill <Reg:rcx>  BB04 regmask=[rcx] minReg=1 last>
<RefPosition #147 @146 RefTypeKill <Reg:rdx>  BB04 regmask=[rdx] minReg=1 last>
<RefPosition #148 @146 RefTypeKill <Reg:r8 >  BB04 regmask=[r8] minReg=1 last>
<RefPosition #149 @146 RefTypeKill <Reg:r9 >  BB04 regmask=[r9] minReg=1 last>
<RefPosition #150 @146 RefTypeKill <Reg:r10>  BB04 regmask=[r10] minReg=1 last>
<RefPosition #151 @146 RefTypeKill <Reg:r11>  BB04 regmask=[r11] minReg=1 last>
<RefPosition #152 @147 RefTypeBB  BB05 regmask=[] minReg=1>
<RefPosition #153 @153 RefTypeUse <Ivl:4 V09> LCL_VAR BB05 regmask=[allInt] minReg=1 last>
<RefPosition #154 @154 RefTypeDef <Ivl:13 V23> STORE_LCL_VAR BB05 regmask=[allInt] minReg=1>
<RefPosition #155 @159 RefTypeUse <Ivl:13 V23> LCL_VAR BB05 regmask=[allInt] minReg=1 last>
<RefPosition #156 @160 RefTypeDef <Ivl:10 V19> STORE_LCL_VAR BB05 regmask=[allInt] minReg=1>
<RefPosition #157 @165 RefTypeUse <Ivl:3 V08> LCL_VAR BB05 regmask=[allInt] minReg=1 last>
<RefPosition #158 @166 RefTypeDef <Ivl:11 V20> STORE_LCL_VAR BB05 regmask=[allInt] minReg=1>
<RefPosition #159 @171 RefTypeUse <Ivl:10 V19> LCL_VAR BB05 regmask=[allInt] minReg=1 last>
<RefPosition #160 @172 RefTypeDef <Ivl:8 V17> STORE_LCL_VAR BB05 regmask=[allInt] minReg=1>
<RefPosition #161 @175 RefTypeUse <Ivl:11 V20> LCL_VAR BB05 regmask=[allInt] minReg=1 last>
<RefPosition #162 @176 RefTypeDef <Ivl:9 V18> STORE_LCL_VAR BB05 regmask=[allInt] minReg=1>
<RefPosition #163 @177 RefTypeBB  BB06 regmask=[] minReg=1>
<RefPosition #164 @181 RefTypeUse <Ivl:8 V17> LCL_VAR BB06 regmask=[allInt] minReg=1 last>
<RefPosition #165 @182 RefTypeDef <Ivl:6 V15> STORE_LCL_VAR BB06 regmask=[allInt] minReg=1>
<RefPosition #166 @185 RefTypeUse <Ivl:9 V18> LCL_VAR BB06 regmask=[allInt] minReg=1 last>
<RefPosition #167 @186 RefTypeDef <Ivl:7 V16> STORE_LCL_VAR BB06 regmask=[allInt] minReg=1>
<RefPosition #168 @189 RefTypeUse <Ivl:1 V02> LCL_VAR BB06 regmask=[allInt] minReg=1 last>
<RefPosition #169 @190 RefTypeDef <Ivl:15 V26> STORE_LCL_VAR BB06 regmask=[allInt] minReg=1>
<RefPosition #170 @192 RefTypeDef <Ivl:41> LCL_VAR_ADDR BB06 regmask=[allInt] minReg=1>
<RefPosition #171 @193 RefTypeUse <Ivl:41>  BB06 regmask=[allInt] minReg=1 last>
<RefPosition #172 @194 RefTypeDef <Ivl:14 V25> STORE_LCL_VAR BB06 regmask=[allInt] minReg=1>
<RefPosition #173 @199 RefTypeUse <Ivl:14 V25> LCL_VAR BB06 regmask=[allInt] minReg=1>
<RefPosition #174 @199 RefTypeUse <Ivl:6 V15> LCL_VAR BB06 regmask=[allInt] minReg=1 last>
<RefPosition #175 @207 RefTypeUse <Ivl:14 V25> LCL_VAR BB06 regmask=[allInt] minReg=1 last>
<RefPosition #176 @207 RefTypeUse <Ivl:7 V16> LCL_VAR BB06 regmask=[allInt] minReg=1 last>
<RefPosition #177 @211 RefTypeFixedReg <Reg:rcx>  BB06 regmask=[rcx] minReg=1>
<RefPosition #178 @211 RefTypeUse <Ivl:15 V26> LCL_VAR BB06 regmask=[rcx] minReg=1 last fixed>
<RefPosition #179 @212 RefTypeFixedReg <Reg:rcx>  BB06 regmask=[rcx] minReg=1>
<RefPosition #180 @212 RefTypeDef <Ivl:42> PUTARG_REG BB06 regmask=[rcx] minReg=1 fixed>
<RefPosition #181 @214 RefTypeDef <Ivl:43> LCL_VAR_ADDR BB06 regmask=[rdx] minReg=1>
<RefPosition #182 @215 RefTypeFixedReg <Reg:rdx>  BB06 regmask=[rdx] minReg=1>
<RefPosition #183 @215 RefTypeUse <Ivl:43>  BB06 regmask=[rdx] minReg=1 last fixed>
<RefPosition #184 @216 RefTypeFixedReg <Reg:rdx>  BB06 regmask=[rdx] minReg=1>
<RefPosition #185 @216 RefTypeDef <Ivl:44> PUTARG_REG BB06 regmask=[rdx] minReg=1 fixed>
<RefPosition #186 @217 RefTypeFixedReg <Reg:rcx>  BB06 regmask=[rcx] minReg=1>
<RefPosition #187 @217 RefTypeUse <Ivl:42>  BB06 regmask=[rcx] minReg=1 last fixed>
<RefPosition #188 @217 RefTypeFixedReg <Reg:rdx>  BB06 regmask=[rdx] minReg=1>
<RefPosition #189 @217 RefTypeUse <Ivl:44>  BB06 regmask=[rdx] minReg=1 last fixed>
<RefPosition #190 @218 RefTypeKill <Reg:rax>  BB06 regmask=[rax] minReg=1 last>
<RefPosition #191 @218 RefTypeKill <Reg:rcx>  BB06 regmask=[rcx] minReg=1 last>
<RefPosition #192 @218 RefTypeKill <Reg:rdx>  BB06 regmask=[rdx] minReg=1 last>
<RefPosition #193 @218 RefTypeKill <Reg:r8 >  BB06 regmask=[r8] minReg=1 last>
<RefPosition #194 @218 RefTypeKill <Reg:r9 >  BB06 regmask=[r9] minReg=1 last>
<RefPosition #195 @218 RefTypeKill <Reg:r10>  BB06 regmask=[r10] minReg=1 last>
<RefPosition #196 @218 RefTypeKill <Reg:r11>  BB06 regmask=[r11] minReg=1 last>

VAR REFPOSITIONS BEFORE ALLOCATION
--- V00  (Interval 0)
<RefPosition #0   @0   RefTypeParamDef <Ivl:0 V00>  BB00 regmask=[rcx] minReg=1 fixed regOptional>
<RefPosition #105 @63  RefTypeUse <Ivl:0 V00> LCL_VAR BB01 regmask=[allInt] minReg=1 regOptional>
<RefPosition #116 @95  RefTypeUse <Ivl:0 V00> LCL_VAR BB03 regmask=[allInt] minReg=1>
<RefPosition #120 @105 RefTypeUse <Ivl:0 V00> LCL_VAR BB03 regmask=[allInt] minReg=1 last>
--- V01
--- V02  (Interval 1)
<RefPosition #19  @12  RefTypeDef <Ivl:1 V02> STORE_LCL_VAR BB01 regmask=[allInt] minReg=1>
<RefPosition #83  @43  RefTypeUse <Ivl:1 V02> LCL_VAR BB01 regmask=[allInt] minReg=1>
<RefPosition #103 @55  RefTypeUse <Ivl:1 V02> LCL_VAR BB01 regmask=[allInt] minReg=1>
<RefPosition #168 @189 RefTypeUse <Ivl:1 V02> LCL_VAR BB06 regmask=[allInt] minReg=1 last>
--- V03
--- V04  (Interval 2)
<RefPosition #37  @20  RefTypeDef <Ivl:2 V04> STORE_LCL_VAR BB01 regmask=[allInt] minReg=1>
<RefPosition #64  @37  RefTypeUse <Ivl:2 V04> LCL_VAR BB01 regmask=[allInt] minReg=1>
<RefPosition #88  @47  RefTypeUse <Ivl:2 V04> LCL_VAR BB01 regmask=[rdx] minReg=1 last fixed>
--- V05
--- V06
--- V07
--- V08  (Interval 3)
<RefPosition #123 @108 RefTypeDef <Ivl:3 V08> STORE_LCL_VAR BB03 regmask=[allInt] minReg=1>
<RefPosition #131 @129 RefTypeUse <Ivl:3 V08> LCL_VAR BB03 regmask=[allInt] minReg=1 regOptional>
<RefPosition #157 @165 RefTypeUse <Ivl:3 V08> LCL_VAR BB05 regmask=[allInt] minReg=1 last>
--- V09  (Interval 4)
<RefPosition #119 @98  RefTypeDef <Ivl:4 V09> STORE_LCL_VAR BB03 regmask=[allInt] minReg=1>
<RefPosition #153 @153 RefTypeUse <Ivl:4 V09> LCL_VAR BB05 regmask=[allInt] minReg=1 last>
--- V10
--- V11
--- V12
--- V13
--- V14  (Interval 5)
<RefPosition #130 @122 RefTypeDef <Ivl:5 V14> STORE_LCL_VAR BB03 regmask=[allInt] minReg=1>
<RefPosition #134 @139 RefTypeUse <Ivl:5 V14> LCL_VAR BB04 regmask=[rcx] minReg=1 fixed>
<RefPosition #138 @143 RefTypeUse <Ivl:5 V14> LCL_VAR BB04 regmask=[rdx] minReg=1 last fixed>
--- V15  (Interval 6)
<RefPosition #165 @182 RefTypeDef <Ivl:6 V15> STORE_LCL_VAR BB06 regmask=[allInt] minReg=1>
<RefPosition #174 @199 RefTypeUse <Ivl:6 V15> LCL_VAR BB06 regmask=[allInt] minReg=1 last>
--- V16  (Interval 7)
<RefPosition #167 @186 RefTypeDef <Ivl:7 V16> STORE_LCL_VAR BB06 regmask=[allInt] minReg=1>
<RefPosition #176 @207 RefTypeUse <Ivl:7 V16> LCL_VAR BB06 regmask=[allInt] minReg=1 last>
--- V17  (Interval 8)
<RefPosition #111 @80  RefTypeDef <Ivl:8 V17> STORE_LCL_VAR BB02 regmask=[allInt] minReg=1>
<RefPosition #160 @172 RefTypeDef <Ivl:8 V17> STORE_LCL_VAR BB05 regmask=[allInt] minReg=1>
<RefPosition #164 @181 RefTypeUse <Ivl:8 V17> LCL_VAR BB06 regmask=[allInt] minReg=1 last>
--- V18  (Interval 9)
<RefPosition #114 @84  RefTypeDef <Ivl:9 V18> STORE_LCL_VAR BB02 regmask=[allInt] minReg=1>
<RefPosition #162 @176 RefTypeDef <Ivl:9 V18> STORE_LCL_VAR BB05 regmask=[allInt] minReg=1>
<RefPosition #166 @185 RefTypeUse <Ivl:9 V18> LCL_VAR BB06 regmask=[allInt] minReg=1 last>
--- V19  (Interval 10)
<RefPosition #156 @160 RefTypeDef <Ivl:10 V19> STORE_LCL_VAR BB05 regmask=[allInt] minReg=1>
<RefPosition #159 @171 RefTypeUse <Ivl:10 V19> LCL_VAR BB05 regmask=[allInt] minReg=1 last>
--- V20  (Interval 11)
<RefPosition #158 @166 RefTypeDef <Ivl:11 V20> STORE_LCL_VAR BB05 regmask=[allInt] minReg=1>
<RefPosition #161 @175 RefTypeUse <Ivl:11 V20> LCL_VAR BB05 regmask=[allInt] minReg=1 last>
--- V21  (Interval 12)
<RefPosition #109 @74  RefTypeDef <Ivl:12 V21> STORE_LCL_VAR BB02 regmask=[allInt] minReg=1>
<RefPosition #110 @79  RefTypeUse <Ivl:12 V21> LCL_VAR BB02 regmask=[allInt] minReg=1 last>
--- V22
--- V23  (Interval 13)
<RefPosition #154 @154 RefTypeDef <Ivl:13 V23> STORE_LCL_VAR BB05 regmask=[allInt] minReg=1>
<RefPosition #155 @159 RefTypeUse <Ivl:13 V23> LCL_VAR BB05 regmask=[allInt] minReg=1 last>
--- V24
--- V25  (Interval 14)
<RefPosition #172 @194 RefTypeDef <Ivl:14 V25> STORE_LCL_VAR BB06 regmask=[allInt] minReg=1>
<RefPosition #173 @199 RefTypeUse <Ivl:14 V25> LCL_VAR BB06 regmask=[allInt] minReg=1>
<RefPosition #175 @207 RefTypeUse <Ivl:14 V25> LCL_VAR BB06 regmask=[allInt] minReg=1 last>
--- V26  (Interval 15)
<RefPosition #169 @190 RefTypeDef <Ivl:15 V26> STORE_LCL_VAR BB06 regmask=[allInt] minReg=1>
<RefPosition #178 @211 RefTypeUse <Ivl:15 V26> LCL_VAR BB06 regmask=[rcx] minReg=1 last fixed>
--- V27  (Interval 16)
<RefPosition #128 @116 RefTypeDef <Ivl:16 V27> STORE_LCL_VAR BB03 regmask=[allInt] minReg=1>
<RefPosition #129 @121 RefTypeUse <Ivl:16 V27> LCL_VAR BB03 regmask=[allInt] minReg=1 last>



Allocating Registers
--------------------
The following table has one or more rows for each RefPosition that is handled during allocation.
The first column provides the basic information about the RefPosition, with its type (e.g. Def,
Use, Fixd) followed by a '*' if it is a last use, and a 'D' if it is delayRegFree, and then the
action taken during allocation (e.g. Alloc a new register, or Keep an existing one).
The subsequent columns show the Interval occupying each register, if any, followed by 'a' if it is
active, a 'p' if it is a large vector that has been partially spilled, and 'i'if it is inactive.
Columns are only printed up to the last modifed register, which may increase during allocation,
in which case additional columns will appear.  
Registers which are not marked modified have ---- in their column.

--------------------------------+----+----+----+----+----+----+----+----+----+
Loc RP#  Name Type  Action Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
--------------------------------+----+----+----+----+----+----+----+----+----+
                                |    |V0 a|    |    |    |    |    |    |    |
  0.#0   V0   Parm   Alloc rsi  |    |    |    |    |    |V0 a|    |    |    |
  1.#1   BB1 PredBB0            |    |    |    |    |    |V0 a|    |    |    |
  6.#2   C17  Def    Alloc rcx  |    |C17a|    |    |    |V0 a|    |    |    |
  7.#3   rcx  Fixd   Keep  rcx  |    |C17a|    |    |    |V0 a|    |    |    |
  7.#4   C17  Use *  Keep  rcx  |    |C17a|    |    |    |V0 a|    |    |    |
  8.#5   rcx  Fixd   Keep  rcx  |    |    |    |    |    |V0 a|    |    |    |
  8.#6   I18  Def    Alloc rcx  |    |I18a|    |    |    |V0 a|    |    |    |
  9.#7   rcx  Fixd   Keep  rcx  |    |I18a|    |    |    |V0 a|    |    |    |
  9.#8   I18  Use *  Keep  rcx  |    |I18a|    |    |    |V0 a|    |    |    |
 10.#9   rax  Kill   Keep  rax  |    |    |    |    |    |V0 a|    |    |    |
 10.#10  rcx  Kill   Keep  rcx  |    |    |    |    |    |V0 a|    |    |    |
 10.#11  rdx  Kill   Keep  rdx  |    |    |    |    |    |V0 a|    |    |    |
 10.#12  r8   Kill   Keep  r8   |    |    |    |    |    |V0 a|    |    |    |
 10.#13  r9   Kill   Keep  r9   |    |    |    |    |    |V0 a|    |    |    |
 10.#14  r10  Kill   Keep  r10  |    |    |    |    |    |V0 a|    |    |    |
 10.#15  r11  Kill   Keep  r11  |    |    |    |    |    |V0 a|    |    |    |
 10.#16  rax  Fixd   Keep  rax  |    |    |    |    |    |V0 a|    |    |    |
 10.#17  I19  Def    Alloc rax  |I19a|    |    |    |    |V0 a|    |    |    |
 11.#18  I19  Use *  Keep  rax  |I19a|    |    |    |    |V0 a|    |    |    |
 12.#19  V2   Def    Alloc rdi  |    |    |    |    |    |V0 a|V2 a|    |    |
 14.#20  C20  Def    Alloc rcx  |    |C20a|    |    |    |V0 a|V2 a|    |    |
 15.#21  rcx  Fixd   Keep  rcx  |    |C20a|    |    |    |V0 a|V2 a|    |    |
 15.#22  C20  Use *  Keep  rcx  |    |C20a|    |    |    |V0 a|V2 a|    |    |
 16.#23  rcx  Fixd   Keep  rcx  |    |    |    |    |    |V0 a|V2 a|    |    |
 16.#24  I21  Def    Alloc rcx  |    |I21a|    |    |    |V0 a|V2 a|    |    |
 17.#25  rcx  Fixd   Keep  rcx  |    |I21a|    |    |    |V0 a|V2 a|    |    |
 17.#26  I21  Use *  Keep  rcx  |    |I21a|    |    |    |V0 a|V2 a|    |    |
 18.#27  rax  Kill   Keep  rax  |    |    |    |    |    |V0 a|V2 a|    |    |
 18.#28  rcx  Kill   Keep  rcx  |    |    |    |    |    |V0 a|V2 a|    |    |
 18.#29  rdx  Kill   Keep  rdx  |    |    |    |    |    |V0 a|V2 a|    |    |
 18.#30  r8   Kill   Keep  r8   |    |    |    |    |    |V0 a|V2 a|    |    |
 18.#31  r9   Kill   Keep  r9   |    |    |    |    |    |V0 a|V2 a|    |    |
 18.#32  r10  Kill   Keep  r10  |    |    |    |    |    |V0 a|V2 a|    |    |
 18.#33  r11  Kill   Keep  r11  |    |    |    |    |    |V0 a|V2 a|    |    |
 18.#34  rax  Fixd   Keep  rax  |    |    |    |    |    |V0 a|V2 a|    |    |
 18.#35  I22  Def    Alloc rax  |I22a|    |    |    |    |V0 a|V2 a|    |    |
 19.#36  I22  Use *  Keep  rax  |I22a|    |    |    |    |V0 a|V2 a|    |    |
 20.#37  V4   Def    Alloc rbx  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 22.#38  C23  Def    Alloc rcx  |    |C23a|    |V4 a|    |V0 a|V2 a|    |    |
 23.#39  rcx  Fixd   Keep  rcx  |    |C23a|    |V4 a|    |V0 a|V2 a|    |    |
 23.#40  C23  Use *  Keep  rcx  |    |C23a|    |V4 a|    |V0 a|V2 a|    |    |
 24.#41  rcx  Fixd   Keep  rcx  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 24.#42  I24  Def    Alloc rcx  |    |I24a|    |V4 a|    |V0 a|V2 a|    |    |
 26.#43  C25  Def    Alloc rdx  |    |I24a|C25a|V4 a|    |V0 a|V2 a|    |    |
 27.#44  rdx  Fixd   Keep  rdx  |    |I24a|C25a|V4 a|    |V0 a|V2 a|    |    |
 27.#45  C25  Use *  Keep  rdx  |    |I24a|C25a|V4 a|    |V0 a|V2 a|    |    |
 28.#46  rdx  Fixd   Keep  rdx  |    |I24a|    |V4 a|    |V0 a|V2 a|    |    |
 28.#47  I26  Def    Alloc rdx  |    |I24a|I26a|V4 a|    |V0 a|V2 a|    |    |
 29.#48  rcx  Fixd   Keep  rcx  |    |I24a|I26a|V4 a|    |V0 a|V2 a|    |    |
 29.#49  I24  Use *  Keep  rcx  |    |I24a|I26a|V4 a|    |V0 a|V2 a|    |    |
 29.#50  rdx  Fixd   Keep  rdx  |    |I24a|I26a|V4 a|    |V0 a|V2 a|    |    |
--------------------------------+----+----+----+----+----+----+----+----+----+
Loc RP#  Name Type  Action Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
--------------------------------+----+----+----+----+----+----+----+----+----+
 29.#51  I26  Use *  Keep  rdx  |    |I24a|I26a|V4 a|    |V0 a|V2 a|    |    |
 30.#52  rax  Kill   Keep  rax  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 30.#53  rcx  Kill   Keep  rcx  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 30.#54  rdx  Kill   Keep  rdx  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 30.#55  r8   Kill   Keep  r8   |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 30.#56  r9   Kill   Keep  r9   |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 30.#57  r10  Kill   Keep  r10  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 30.#58  r11  Kill   Keep  r11  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 30.#59  rax  Fixd   Keep  rax  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 30.#60  I27  Def *  Alloc rax  |I27a|    |    |V4 a|    |V0 a|V2 a|    |    |
 32.#61  C28  Def    Alloc rdx  |    |    |C28a|V4 a|    |V0 a|V2 a|    |    |
 33.#62  C28  Use *  Keep  rdx  |    |    |C28a|V4 a|    |V0 a|V2 a|    |    |
 34.#63  I29  Def    Alloc rdx  |    |    |I29a|V4 a|    |V0 a|V2 a|    |    |
 37.#64  V4   Use    Keep  rbx  |    |    |I29a|V4 a|    |V0 a|V2 a|    |    |
 38.#65  I30  Def    Alloc rcx  |    |I30a|I29a|V4 a|    |V0 a|V2 a|    |    |
 39.#66  rcx  Fixd   Keep  rcx  |    |I30a|I29a|V4 a|    |V0 a|V2 a|    |    |
 39.#67  I30  Use *  Keep  rcx  |    |I30a|I29a|V4 a|    |V0 a|V2 a|    |    |
 39.#68  rdx  Fixd   Keep  rdx  |    |I30a|I29a|V4 a|    |V0 a|V2 a|    |    |
 39.#69  I29  Use *  Keep  rdx  |    |I30a|I29a|V4 a|    |V0 a|V2 a|    |    |
 40.#70  rax  Kill   Keep  rax  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 40.#71  rcx  Kill   Keep  rcx  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 40.#72  rdx  Kill   Keep  rdx  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 40.#73  r8   Kill   Keep  r8   |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 40.#74  r9   Kill   Keep  r9   |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 40.#75  r10  Kill   Keep  r10  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 40.#76  r11  Kill   Keep  r11  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 40.#77  mm0  Kill   Keep  mm0  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 40.#78  mm1  Kill   Keep  mm1  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 40.#79  mm2  Kill   Keep  mm2  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 40.#80  mm3  Kill   Keep  mm3  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 40.#81  mm4  Kill   Keep  mm4  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 40.#82  mm5  Kill   Keep  mm5  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 43.#83  V2   Use    Keep  rdi  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 44.#84  I31  Def    Alloc rcx  |    |I31a|    |V4 a|    |V0 a|V2 a|    |    |
 47.#85  rcx  Fixd   Keep  rcx  |    |I31a|    |V4 a|    |V0 a|V2 a|    |    |
 47.#86  I31  Use *  Keep  rcx  |    |I31a|    |V4 a|    |V0 a|V2 a|    |    |
 47.#87  rdx  Fixd   Keep  rdx  |    |I31a|    |V4 a|    |V0 a|V2 a|    |    |
 47.#88  V4   Use *  Copy  rdx  |    |I31a|V4 a|V4 a|    |V0 a|V2 a|    |    |
 48.#89  rax  Kill   Keep  rax  |    |    |    |    |    |V0 a|V2 a|    |    |
 48.#90  rcx  Kill   Keep  rcx  |    |    |    |    |    |V0 a|V2 a|    |    |
 48.#91  rdx  Kill   Keep  rdx  |    |    |    |    |    |V0 a|V2 a|    |    |
 48.#92  r8   Kill   Keep  r8   |    |    |    |    |    |V0 a|V2 a|    |    |
 48.#93  r9   Kill   Keep  r9   |    |    |    |    |    |V0 a|V2 a|    |    |
 48.#94  r10  Kill   Keep  r10  |    |    |    |    |    |V0 a|V2 a|    |    |
 48.#95  r11  Kill   Keep  r11  |    |    |    |    |    |V0 a|V2 a|    |    |
 48.#96  mm0  Kill   Keep  mm0  |    |    |    |    |    |V0 a|V2 a|    |    |
 48.#97  mm1  Kill   Keep  mm1  |    |    |    |    |    |V0 a|V2 a|    |    |
 48.#98  mm2  Kill   Keep  mm2  |    |    |    |    |    |V0 a|V2 a|    |    |
 48.#99  mm3  Kill   Keep  mm3  |    |    |    |    |    |V0 a|V2 a|    |    |
 48.#100 mm4  Kill   Keep  mm4  |    |    |    |    |    |V0 a|V2 a|    |    |
 48.#101 mm5  Kill   Keep  mm5  |    |    |    |    |    |V0 a|V2 a|    |    |
--------------------------------+----+----+----+----+----+----+----+----+----+
Loc RP#  Name Type  Action Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
--------------------------------+----+----+----+----+----+----+----+----+----+
 54.#102 C32  Def    Alloc rcx  |    |C32a|    |    |    |V0 a|V2 a|    |    |
 55.#103 V2   Use    Keep  rdi  |    |C32a|    |    |    |V0 a|V2 a|    |    |
 55.#104 C32  Use *  Keep  rcx  |    |C32a|    |    |    |V0 a|V2 a|    |    |
 63.#105 V0   Use    Keep  rsi  |    |C32i|    |    |    |V0 a|V2 a|    |    |
--------------------------------+----+----+----+----+----+----+----+----+----+
Loc RP#  Name Type  Action Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
--------------------------------+----+----+----+----+----+----+----+----+----+
 67.#106 BB2 PredBB1            |    |    |    |    |    |V0 i|V2 a|    |    |
 72.#107 C33  Def    Alloc rax  |C33a|    |    |    |    |V0 i|V2 a|    |    |
 73.#108 C33  Use *  Keep  rax  |C33a|    |    |    |    |V0 i|V2 a|    |    |
 74.#109 V21  Def    Alloc rax  |V21a|    |    |    |    |V0 i|V2 a|    |    |
 79.#110 V21  Use *  Keep  rax  |V21a|    |    |    |    |V0 i|V2 a|    |    |
 80.#111 V17  Def    Alloc rax  |V17a|    |    |    |    |V0 i|V2 a|    |    |
 82.#112 C34  Def    Alloc rbx  |V17a|    |    |C34a|    |V0 i|V2 a|    |    |
 83.#113 C34  Use *  Keep  rbx  |V17a|    |    |C34a|    |V0 i|V2 a|    |    |
 84.#114 V18  Def    Alloc rbx  |V17a|    |    |V18a|    |V0 i|V2 a|    |    |
--------------------------------+----+----+----+----+----+----+----+----+----+
Loc RP#  Name Type  Action Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
--------------------------------+----+----+----+----+----+----+----+----+----+
 85.#115 BB3 PredBB1            |V17i|    |    |V18i|    |V0 a|V2 a|    |    |
 95.#116 V0   Use    Keep  rsi  |V17i|    |    |V18i|    |V0 a|V2 a|    |    |
 96.#117 I35  Def    Alloc rbx  |V17i|    |    |I35a|    |V0 a|V2 a|    |    |
 97.#118 I35  Use *  Keep  rbx  |V17i|    |    |I35a|    |V0 a|V2 a|    |    |
                     Restr rbx  |V17i|    |    |V18i|    |V0 a|V2 a|    |    |
 98.#119 V9   Def    Alloc rbx  |V17i|    |    |V9 a|    |V0 a|V2 a|    |    |
105.#120 V0   Use *  Keep  rsi  |V17i|    |    |V9 a|    |V0 a|V2 a|    |    |
106.#121 I36  Def    Alloc rsi  |V17i|    |    |V9 a|    |I36a|V2 a|    |    |
107.#122 I36  Use *  Keep  rsi  |V17i|    |    |V9 a|    |I36a|V2 a|    |    |
108.#123 V8   Def    Alloc rsi  |V17i|    |    |V9 a|    |V8 a|V2 a|    |    |
112.#124 C37  Def    Alloc rcx  |V17i|C37a|    |V9 a|    |V8 a|V2 a|    |    |
113.#125 C37  Use *  Keep  rcx  |V17i|C37a|    |V9 a|    |V8 a|V2 a|    |    |
114.#126 I38  Def    Alloc rdx  |V17i|C37i|I38a|V9 a|    |V8 a|V2 a|    |    |
115.#127 I38  Use *  Keep  rdx  |V17i|C37i|I38a|V9 a|    |V8 a|V2 a|    |    |
116.#128 V27  Def    Alloc rdx  |V17i|C37i|V27a|V9 a|    |V8 a|V2 a|    |    |
121.#129 V27  Use *  Keep  rdx  |V17i|C37i|V27a|V9 a|    |V8 a|V2 a|    |    |
122.#130 V14  Def    Alloc rdx  |V17i|C37i|V14a|V9 a|    |V8 a|V2 a|    |    |
129.#131 V8   Use    Keep  rsi  |V17i|C37i|V14a|V9 a|    |V8 a|V2 a|    |    |
--------------------------------+----+----+----+----+----+----+----+----+----+
Loc RP#  Name Type  Action Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
--------------------------------+----+----+----+----+----+----+----+----+----+
133.#132 BB4 PredBB3            |V17i|    |V14a|V9 a|    |V8 a|V2 a|    |    |
139.#133 rcx  Fixd   Keep  rcx  |V17i|    |V14a|V9 a|    |V8 a|V2 a|    |    |
139.#134 V14  Use    Copy  rcx  |V17i|V14a|V14a|V9 a|    |V8 a|V2 a|    |    |
140.#135 rcx  Fixd   Keep  rcx  |V17i|V14a|V14a|V9 a|    |V8 a|V2 a|    |    |
140.#136 I39  Def    Alloc rcx  |V17i|I39a|V14a|V9 a|    |V8 a|V2 a|    |    |
143.#137 rdx  Fixd   Keep  rdx  |V17i|I39a|V14a|V9 a|    |V8 a|V2 a|    |    |
143.#138 V14  Use *  Keep  rdx  |V17i|I39a|V14a|V9 a|    |V8 a|V2 a|    |    |
144.#139 rdx  Fixd   Keep  rdx  |V17i|I39a|    |V9 a|    |V8 a|V2 a|    |    |
144.#140 I40  Def    Alloc rdx  |V17i|I39a|I40a|V9 a|    |V8 a|V2 a|    |    |
145.#141 rcx  Fixd   Keep  rcx  |V17i|I39a|I40a|V9 a|    |V8 a|V2 a|    |    |
145.#142 I39  Use *  Keep  rcx  |V17i|I39a|I40a|V9 a|    |V8 a|V2 a|    |    |
145.#143 rdx  Fixd   Keep  rdx  |V17i|I39a|I40a|V9 a|    |V8 a|V2 a|    |    |
145.#144 I40  Use *  Keep  rdx  |V17i|I39a|I40a|V9 a|    |V8 a|V2 a|    |    |
146.#145 rax  Kill   Keep  rax  |    |    |    |V9 a|    |V8 a|V2 a|    |    |
146.#146 rcx  Kill   Keep  rcx  |    |    |    |V9 a|    |V8 a|V2 a|    |    |
146.#147 rdx  Kill   Keep  rdx  |    |    |    |V9 a|    |V8 a|V2 a|    |    |
146.#148 r8   Kill   Keep  r8   |    |    |    |V9 a|    |V8 a|V2 a|    |    |
146.#149 r9   Kill   Keep  r9   |    |    |    |V9 a|    |V8 a|V2 a|    |    |
146.#150 r10  Kill   Keep  r10  |    |    |    |V9 a|    |V8 a|V2 a|    |    |
146.#151 r11  Kill   Keep  r11  |    |    |    |V9 a|    |V8 a|V2 a|    |    |
--------------------------------+----+----+----+----+----+----+----+----+----+
Loc RP#  Name Type  Action Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
--------------------------------+----+----+----+----+----+----+----+----+----+
147.#152 BB5 PredBB3            |    |    |    |V9 a|    |V8 a|V2 a|    |    |
153.#153 V9   Use *  Keep  rbx  |    |    |    |V9 a|    |V8 a|V2 a|    |    |
154.#154 V23  Def    Alloc rbx  |    |    |    |V23a|    |V8 a|V2 a|    |    |
159.#155 V23  Use *  Keep  rbx  |    |    |    |V23a|    |V8 a|V2 a|    |    |
160.#156 V19  Def    Alloc rax  |V19a|    |    |    |    |V8 a|V2 a|    |    |
165.#157 V8   Use *  Keep  rsi  |V19a|    |    |    |    |V8 a|V2 a|    |    |
166.#158 V20  Def    Alloc rbx  |V19a|    |    |V20a|    |    |V2 a|    |    |
171.#159 V19  Use *  Keep  rax  |V19a|    |    |V20a|    |    |V2 a|    |    |
172.#160 V17  Def    Alloc rax  |V17a|    |    |V20a|    |    |V2 a|    |    |
175.#161 V20  Use *  Keep  rbx  |V17a|    |    |V20a|    |    |V2 a|    |    |
176.#162 V18  Def    Alloc rbx  |V17a|    |    |V18a|    |    |V2 a|    |    |
--------------------------------+----+----+----+----+----+----+----+----+----+
Loc RP#  Name Type  Action Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
--------------------------------+----+----+----+----+----+----+----+----+----+
177.#163 BB6 PredBB2            |V17a|    |    |V18a|    |    |V2 a|    |    |
181.#164 V17  Use *  Keep  rax  |V17a|    |    |V18a|    |    |V2 a|    |    |
182.#165 V15  Def    Alloc rax  |V15a|    |    |V18a|    |    |V2 a|    |    |
185.#166 V18  Use *  Keep  rbx  |V15a|    |    |V18a|    |    |V2 a|    |    |
186.#167 V16  Def    Alloc rbx  |V15a|    |    |V16a|    |    |V2 a|    |    |
189.#168 V2   Use *  Keep  rdi  |V15a|    |    |V16a|    |    |V2 a|    |    |
190.#169 V26  Def    Alloc rcx  |V15a|V26a|    |V16a|    |    |    |    |    |
192.#170 I41  Def    Alloc rdx  |V15a|V26a|I41a|V16a|    |    |    |    |    |
193.#171 I41  Use *  Keep  rdx  |V15a|V26a|I41a|V16a|    |    |    |    |    |
194.#172 V25  Def    Alloc rdx  |V15a|V26a|V25a|V16a|    |    |    |    |    |
199.#173 V25  Use    Keep  rdx  |V15a|V26a|V25a|V16a|    |    |    |    |    |
199.#174 V15  Use *  Keep  rax  |V15a|V26a|V25a|V16a|    |    |    |    |    |
207.#175 V25  Use *  Keep  rdx  |    |V26a|V25a|V16a|    |    |    |    |    |
207.#176 V16  Use *  Keep  rbx  |    |V26a|V25a|V16a|    |    |    |    |    |
211.#177 rcx  Fixd   Keep  rcx  |    |V26a|    |    |    |    |    |    |    |
211.#178 V26  Use *  Keep  rcx  |    |V26a|    |    |    |    |    |    |    |
212.#179 rcx  Fixd   Keep  rcx  |    |    |    |    |    |    |    |    |    |
212.#180 I42  Def    Alloc rcx  |    |I42a|    |    |    |    |    |    |    |
214.#181 I43  Def    Alloc rdx  |    |I42a|I43a|    |    |    |    |    |    |
215.#182 rdx  Fixd   Keep  rdx  |    |I42a|I43a|    |    |    |    |    |    |
215.#183 I43  Use *  Keep  rdx  |    |I42a|I43a|    |    |    |    |    |    |
216.#184 rdx  Fixd   Keep  rdx  |    |I42a|    |    |    |    |    |    |    |
216.#185 I44  Def    Alloc rdx  |    |I42a|I44a|    |    |    |    |    |    |
217.#186 rcx  Fixd   Keep  rcx  |    |I42a|I44a|    |    |    |    |    |    |
217.#187 I42  Use *  Keep  rcx  |    |I42a|I44a|    |    |    |    |    |    |
217.#188 rdx  Fixd   Keep  rdx  |    |I42a|I44a|    |    |    |    |    |    |
217.#189 I44  Use *  Keep  rdx  |    |I42a|I44a|    |    |    |    |    |    |
218.#190 rax  Kill   Keep  rax  |    |    |    |    |    |    |    |    |    |
218.#191 rcx  Kill   Keep  rcx  |    |    |    |    |    |    |    |    |    |
218.#192 rdx  Kill   Keep  rdx  |    |    |    |    |    |    |    |    |    |
218.#193 r8   Kill   Keep  r8   |    |    |    |    |    |    |    |    |    |
218.#194 r9   Kill   Keep  r9   |    |    |    |    |    |    |    |    |    |
218.#195 r10  Kill   Keep  r10  |    |    |    |    |    |    |    |    |    |
218.#196 r11  Kill   Keep  r11  |    |    |    |    |    |    |    |    |    |

------------
REFPOSITIONS AFTER ALLOCATION: 
------------
<RefPosition #0   @0   RefTypeParamDef <Ivl:0 V00>  BB00 regmask=[rsi] minReg=1 fixed regOptional>
<RefPosition #1   @1   RefTypeBB  BB01 regmask=[] minReg=1>
<RefPosition #2   @6   RefTypeDef <Ivl:17> CNS_INT BB01 regmask=[rcx] minReg=1>
<RefPosition #3   @7   RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #4   @7   RefTypeUse <Ivl:17>  BB01 regmask=[rcx] minReg=1 last fixed>
<RefPosition #5   @8   RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #6   @8   RefTypeDef <Ivl:18> PUTARG_REG BB01 regmask=[rcx] minReg=1 fixed>
<RefPosition #7   @9   RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #8   @9   RefTypeUse <Ivl:18>  BB01 regmask=[rcx] minReg=1 last fixed>
<RefPosition #9   @10  RefTypeKill <Reg:rax>  BB01 regmask=[rax] minReg=1 last>
<RefPosition #10  @10  RefTypeKill <Reg:rcx>  BB01 regmask=[rcx] minReg=1 last>
<RefPosition #11  @10  RefTypeKill <Reg:rdx>  BB01 regmask=[rdx] minReg=1 last>
<RefPosition #12  @10  RefTypeKill <Reg:r8 >  BB01 regmask=[r8] minReg=1 last>
<RefPosition #13  @10  RefTypeKill <Reg:r9 >  BB01 regmask=[r9] minReg=1 last>
<RefPosition #14  @10  RefTypeKill <Reg:r10>  BB01 regmask=[r10] minReg=1 last>
<RefPosition #15  @10  RefTypeKill <Reg:r11>  BB01 regmask=[r11] minReg=1 last>
<RefPosition #16  @10  RefTypeFixedReg <Reg:rax>  BB01 regmask=[rax] minReg=1>
<RefPosition #17  @10  RefTypeDef <Ivl:19> CALL BB01 regmask=[rax] minReg=1 fixed>
<RefPosition #18  @11  RefTypeUse <Ivl:19>  BB01 regmask=[rax] minReg=1 last>
<RefPosition #19  @12  RefTypeDef <Ivl:1 V02> STORE_LCL_VAR BB01 regmask=[rdi] minReg=1>
<RefPosition #20  @14  RefTypeDef <Ivl:20> CNS_INT BB01 regmask=[rcx] minReg=1>
<RefPosition #21  @15  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #22  @15  RefTypeUse <Ivl:20>  BB01 regmask=[rcx] minReg=1 last fixed>
<RefPosition #23  @16  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #24  @16  RefTypeDef <Ivl:21> PUTARG_REG BB01 regmask=[rcx] minReg=1 fixed>
<RefPosition #25  @17  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #26  @17  RefTypeUse <Ivl:21>  BB01 regmask=[rcx] minReg=1 last fixed>
<RefPosition #27  @18  RefTypeKill <Reg:rax>  BB01 regmask=[rax] minReg=1 last>
<RefPosition #28  @18  RefTypeKill <Reg:rcx>  BB01 regmask=[rcx] minReg=1 last>
<RefPosition #29  @18  RefTypeKill <Reg:rdx>  BB01 regmask=[rdx] minReg=1 last>
<RefPosition #30  @18  RefTypeKill <Reg:r8 >  BB01 regmask=[r8] minReg=1 last>
<RefPosition #31  @18  RefTypeKill <Reg:r9 >  BB01 regmask=[r9] minReg=1 last>
<RefPosition #32  @18  RefTypeKill <Reg:r10>  BB01 regmask=[r10] minReg=1 last>
<RefPosition #33  @18  RefTypeKill <Reg:r11>  BB01 regmask=[r11] minReg=1 last>
<RefPosition #34  @18  RefTypeFixedReg <Reg:rax>  BB01 regmask=[rax] minReg=1>
<RefPosition #35  @18  RefTypeDef <Ivl:22> CALL BB01 regmask=[rax] minReg=1 fixed>
<RefPosition #36  @19  RefTypeUse <Ivl:22>  BB01 regmask=[rax] minReg=1 last>
<RefPosition #37  @20  RefTypeDef <Ivl:2 V04> STORE_LCL_VAR BB01 regmask=[rbx] minReg=1>
<RefPosition #38  @22  RefTypeDef <Ivl:23> CNS_INT BB01 regmask=[rcx] minReg=1>
<RefPosition #39  @23  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #40  @23  RefTypeUse <Ivl:23>  BB01 regmask=[rcx] minReg=1 last fixed>
<RefPosition #41  @24  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #42  @24  RefTypeDef <Ivl:24> PUTARG_REG BB01 regmask=[rcx] minReg=1 fixed>
<RefPosition #43  @26  RefTypeDef <Ivl:25> CNS_INT BB01 regmask=[rdx] minReg=1>
<RefPosition #44  @27  RefTypeFixedReg <Reg:rdx>  BB01 regmask=[rdx] minReg=1>
<RefPosition #45  @27  RefTypeUse <Ivl:25>  BB01 regmask=[rdx] minReg=1 last fixed>
<RefPosition #46  @28  RefTypeFixedReg <Reg:rdx>  BB01 regmask=[rdx] minReg=1>
<RefPosition #47  @28  RefTypeDef <Ivl:26> PUTARG_REG BB01 regmask=[rdx] minReg=1 fixed>
<RefPosition #48  @29  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #49  @29  RefTypeUse <Ivl:24>  BB01 regmask=[rcx] minReg=1 last fixed>
<RefPosition #50  @29  RefTypeFixedReg <Reg:rdx>  BB01 regmask=[rdx] minReg=1>
<RefPosition #51  @29  RefTypeUse <Ivl:26>  BB01 regmask=[rdx] minReg=1 last fixed>
<RefPosition #52  @30  RefTypeKill <Reg:rax>  BB01 regmask=[rax] minReg=1 last>
<RefPosition #53  @30  RefTypeKill <Reg:rcx>  BB01 regmask=[rcx] minReg=1 last>
<RefPosition #54  @30  RefTypeKill <Reg:rdx>  BB01 regmask=[rdx] minReg=1 last>
<RefPosition #55  @30  RefTypeKill <Reg:r8 >  BB01 regmask=[r8] minReg=1 last>
<RefPosition #56  @30  RefTypeKill <Reg:r9 >  BB01 regmask=[r9] minReg=1 last>
<RefPosition #57  @30  RefTypeKill <Reg:r10>  BB01 regmask=[r10] minReg=1 last>
<RefPosition #58  @30  RefTypeKill <Reg:r11>  BB01 regmask=[r11] minReg=1 last>
<RefPosition #59  @30  RefTypeFixedReg <Reg:rax>  BB01 regmask=[rax] minReg=1>
<RefPosition #60  @30  RefTypeDef <Ivl:27> CALL BB01 regmask=[rax] minReg=1 last fixed local>
<RefPosition #61  @32  RefTypeDef <Ivl:28> CNS_INT BB01 regmask=[rdx] minReg=1>
<RefPosition #62  @33  RefTypeUse <Ivl:28>  BB01 regmask=[rdx] minReg=1 last>
<RefPosition #63  @34  RefTypeDef <Ivl:29> IND BB01 regmask=[rdx] minReg=1>
<RefPosition #64  @37  RefTypeUse <Ivl:2 V04> LCL_VAR BB01 regmask=[rbx] minReg=1>
<RefPosition #65  @38  RefTypeDef <Ivl:30> LEA BB01 regmask=[rcx] minReg=1>
<RefPosition #66  @39  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #67  @39  RefTypeUse <Ivl:30>  BB01 regmask=[rcx] minReg=1 last fixed>
<RefPosition #68  @39  RefTypeFixedReg <Reg:rdx>  BB01 regmask=[rdx] minReg=1>
<RefPosition #69  @39  RefTypeUse <Ivl:29>  BB01 regmask=[rdx] minReg=1 last fixed>
<RefPosition #70  @40  RefTypeKill <Reg:rax>  BB01 regmask=[rax] minReg=1 last>
<RefPosition #71  @40  RefTypeKill <Reg:rcx>  BB01 regmask=[rcx] minReg=1 last>
<RefPosition #72  @40  RefTypeKill <Reg:rdx>  BB01 regmask=[rdx] minReg=1 last>
<RefPosition #73  @40  RefTypeKill <Reg:r8 >  BB01 regmask=[r8] minReg=1 last>
<RefPosition #74  @40  RefTypeKill <Reg:r9 >  BB01 regmask=[r9] minReg=1 last>
<RefPosition #75  @40  RefTypeKill <Reg:r10>  BB01 regmask=[r10] minReg=1 last>
<RefPosition #76  @40  RefTypeKill <Reg:r11>  BB01 regmask=[r11] minReg=1 last>
<RefPosition #77  @40  RefTypeKill <Reg:mm0>  BB01 regmask=[mm0] minReg=1 last>
<RefPosition #78  @40  RefTypeKill <Reg:mm1>  BB01 regmask=[mm1] minReg=1 last>
<RefPosition #79  @40  RefTypeKill <Reg:mm2>  BB01 regmask=[mm2] minReg=1 last>
<RefPosition #80  @40  RefTypeKill <Reg:mm3>  BB01 regmask=[mm3] minReg=1 last>
<RefPosition #81  @40  RefTypeKill <Reg:mm4>  BB01 regmask=[mm4] minReg=1 last>
<RefPosition #82  @40  RefTypeKill <Reg:mm5>  BB01 regmask=[mm5] minReg=1 last>
<RefPosition #83  @43  RefTypeUse <Ivl:1 V02> LCL_VAR BB01 regmask=[rdi] minReg=1>
<RefPosition #84  @44  RefTypeDef <Ivl:31> LEA BB01 regmask=[rcx] minReg=1>
<RefPosition #85  @47  RefTypeFixedReg <Reg:rcx>  BB01 regmask=[rcx] minReg=1>
<RefPosition #86  @47  RefTypeUse <Ivl:31>  BB01 regmask=[rcx] minReg=1 last fixed>
<RefPosition #87  @47  RefTypeFixedReg <Reg:rdx>  BB01 regmask=[rdx] minReg=1>
<RefPosition #88  @47  RefTypeUse <Ivl:2 V04> LCL_VAR BB01 regmask=[rdx] minReg=1 last copy fixed>
<RefPosition #89  @48  RefTypeKill <Reg:rax>  BB01 regmask=[rax] minReg=1 last>
<RefPosition #90  @48  RefTypeKill <Reg:rcx>  BB01 regmask=[rcx] minReg=1 last>
<RefPosition #91  @48  RefTypeKill <Reg:rdx>  BB01 regmask=[rdx] minReg=1 last>
<RefPosition #92  @48  RefTypeKill <Reg:r8 >  BB01 regmask=[r8] minReg=1 last>
<RefPosition #93  @48  RefTypeKill <Reg:r9 >  BB01 regmask=[r9] minReg=1 last>
<RefPosition #94  @48  RefTypeKill <Reg:r10>  BB01 regmask=[r10] minReg=1 last>
<RefPosition #95  @48  RefTypeKill <Reg:r11>  BB01 regmask=[r11] minReg=1 last>
<RefPosition #96  @48  RefTypeKill <Reg:mm0>  BB01 regmask=[mm0] minReg=1 last>
<RefPosition #97  @48  RefTypeKill <Reg:mm1>  BB01 regmask=[mm1] minReg=1 last>
<RefPosition #98  @48  RefTypeKill <Reg:mm2>  BB01 regmask=[mm2] minReg=1 last>
<RefPosition #99  @48  RefTypeKill <Reg:mm3>  BB01 regmask=[mm3] minReg=1 last>
<RefPosition #100 @48  RefTypeKill <Reg:mm4>  BB01 regmask=[mm4] minReg=1 last>
<RefPosition #101 @48  RefTypeKill <Reg:mm5>  BB01 regmask=[mm5] minReg=1 last>
<RefPosition #102 @54  RefTypeDef <Ivl:32> CNS_INT BB01 regmask=[rcx] minReg=1>
<RefPosition #103 @55  RefTypeUse <Ivl:1 V02> LCL_VAR BB01 regmask=[rdi] minReg=1>
<RefPosition #104 @55  RefTypeUse <Ivl:32>  BB01 regmask=[rcx] minReg=1 last>
<RefPosition #105 @63  RefTypeUse <Ivl:0 V00> LCL_VAR BB01 regmask=[rsi] minReg=1 regOptional>
<RefPosition #106 @67  RefTypeBB  BB02 regmask=[] minReg=1>
<RefPosition #107 @72  RefTypeDef <Ivl:33> CNS_INT BB02 regmask=[rax] minReg=1>
<RefPosition #108 @73  RefTypeUse <Ivl:33>  BB02 regmask=[rax] minReg=1 last>
<RefPosition #109 @74  RefTypeDef <Ivl:12 V21> STORE_LCL_VAR BB02 regmask=[rax] minReg=1>
<RefPosition #110 @79  RefTypeUse <Ivl:12 V21> LCL_VAR BB02 regmask=[rax] minReg=1 last>
<RefPosition #111 @80  RefTypeDef <Ivl:8 V17> STORE_LCL_VAR BB02 regmask=[rax] minReg=1>
<RefPosition #112 @82  RefTypeDef <Ivl:34> CNS_INT BB02 regmask=[rbx] minReg=1>
<RefPosition #113 @83  RefTypeUse <Ivl:34>  BB02 regmask=[rbx] minReg=1 last>
<RefPosition #114 @84  RefTypeDef <Ivl:9 V18> STORE_LCL_VAR BB02 regmask=[rbx] minReg=1>
<RefPosition #115 @85  RefTypeBB  BB03 regmask=[] minReg=1>
<RefPosition #116 @95  RefTypeUse <Ivl:0 V00> LCL_VAR BB03 regmask=[rsi] minReg=1>
<RefPosition #117 @96  RefTypeDef <Ivl:35> ADD BB03 regmask=[rbx] minReg=1>
<RefPosition #118 @97  RefTypeUse <Ivl:35>  BB03 regmask=[rbx] minReg=1 last>
<RefPosition #119 @98  RefTypeDef <Ivl:4 V09> STORE_LCL_VAR BB03 regmask=[rbx] minReg=1>
<RefPosition #120 @105 RefTypeUse <Ivl:0 V00> LCL_VAR BB03 regmask=[rsi] minReg=1 last>
<RefPosition #121 @106 RefTypeDef <Ivl:36> IND BB03 regmask=[rsi] minReg=1>
<RefPosition #122 @107 RefTypeUse <Ivl:36>  BB03 regmask=[rsi] minReg=1 last>
<RefPosition #123 @108 RefTypeDef <Ivl:3 V08> STORE_LCL_VAR BB03 regmask=[rsi] minReg=1>
<RefPosition #124 @112 RefTypeDef <Ivl:37> CNS_INT BB03 regmask=[rcx] minReg=1>
<RefPosition #125 @113 RefTypeUse <Ivl:37>  BB03 regmask=[rcx] minReg=1 last>
<RefPosition #126 @114 RefTypeDef <Ivl:38> IND BB03 regmask=[rdx] minReg=1>
<RefPosition #127 @115 RefTypeUse <Ivl:38>  BB03 regmask=[rdx] minReg=1 last>
<RefPosition #128 @116 RefTypeDef <Ivl:16 V27> STORE_LCL_VAR BB03 regmask=[rdx] minReg=1>
<RefPosition #129 @121 RefTypeUse <Ivl:16 V27> LCL_VAR BB03 regmask=[rdx] minReg=1 last>
<RefPosition #130 @122 RefTypeDef <Ivl:5 V14> STORE_LCL_VAR BB03 regmask=[rdx] minReg=1>
<RefPosition #131 @129 RefTypeUse <Ivl:3 V08> LCL_VAR BB03 regmask=[rsi] minReg=1 regOptional>
<RefPosition #132 @133 RefTypeBB  BB04 regmask=[] minReg=1>
<RefPosition #133 @139 RefTypeFixedReg <Reg:rcx>  BB04 regmask=[rcx] minReg=1>
<RefPosition #134 @139 RefTypeUse <Ivl:5 V14> LCL_VAR BB04 regmask=[rcx] minReg=1 copy fixed>
<RefPosition #135 @140 RefTypeFixedReg <Reg:rcx>  BB04 regmask=[rcx] minReg=1>
<RefPosition #136 @140 RefTypeDef <Ivl:39> PUTARG_REG BB04 regmask=[rcx] minReg=1 fixed>
<RefPosition #137 @143 RefTypeFixedReg <Reg:rdx>  BB04 regmask=[rdx] minReg=1>
<RefPosition #138 @143 RefTypeUse <Ivl:5 V14> LCL_VAR BB04 regmask=[rdx] minReg=1 last fixed>
<RefPosition #139 @144 RefTypeFixedReg <Reg:rdx>  BB04 regmask=[rdx] minReg=1>
<RefPosition #140 @144 RefTypeDef <Ivl:40> PUTARG_REG BB04 regmask=[rdx] minReg=1 fixed>
<RefPosition #141 @145 RefTypeFixedReg <Reg:rcx>  BB04 regmask=[rcx] minReg=1>
<RefPosition #142 @145 RefTypeUse <Ivl:39>  BB04 regmask=[rcx] minReg=1 last fixed>
<RefPosition #143 @145 RefTypeFixedReg <Reg:rdx>  BB04 regmask=[rdx] minReg=1>
<RefPosition #144 @145 RefTypeUse <Ivl:40>  BB04 regmask=[rdx] minReg=1 last fixed>
<RefPosition #145 @146 RefTypeKill <Reg:rax>  BB04 regmask=[rax] minReg=1 last>
<RefPosition #146 @146 RefTypeKill <Reg:rcx>  BB04 regmask=[rcx] minReg=1 last>
<RefPosition #147 @146 RefTypeKill <Reg:rdx>  BB04 regmask=[rdx] minReg=1 last>
<RefPosition #148 @146 RefTypeKill <Reg:r8 >  BB04 regmask=[r8] minReg=1 last>
<RefPosition #149 @146 RefTypeKill <Reg:r9 >  BB04 regmask=[r9] minReg=1 last>
<RefPosition #150 @146 RefTypeKill <Reg:r10>  BB04 regmask=[r10] minReg=1 last>
<RefPosition #151 @146 RefTypeKill <Reg:r11>  BB04 regmask=[r11] minReg=1 last>
<RefPosition #152 @147 RefTypeBB  BB05 regmask=[] minReg=1>
<RefPosition #153 @153 RefTypeUse <Ivl:4 V09> LCL_VAR BB05 regmask=[rbx] minReg=1 last>
<RefPosition #154 @154 RefTypeDef <Ivl:13 V23> STORE_LCL_VAR BB05 regmask=[rbx] minReg=1>
<RefPosition #155 @159 RefTypeUse <Ivl:13 V23> LCL_VAR BB05 regmask=[rbx] minReg=1 last>
<RefPosition #156 @160 RefTypeDef <Ivl:10 V19> STORE_LCL_VAR BB05 regmask=[rax] minReg=1>
<RefPosition #157 @165 RefTypeUse <Ivl:3 V08> LCL_VAR BB05 regmask=[rsi] minReg=1 last>
<RefPosition #158 @166 RefTypeDef <Ivl:11 V20> STORE_LCL_VAR BB05 regmask=[rbx] minReg=1>
<RefPosition #159 @171 RefTypeUse <Ivl:10 V19> LCL_VAR BB05 regmask=[rax] minReg=1 last>
<RefPosition #160 @172 RefTypeDef <Ivl:8 V17> STORE_LCL_VAR BB05 regmask=[rax] minReg=1>
<RefPosition #161 @175 RefTypeUse <Ivl:11 V20> LCL_VAR BB05 regmask=[rbx] minReg=1 last>
<RefPosition #162 @176 RefTypeDef <Ivl:9 V18> STORE_LCL_VAR BB05 regmask=[rbx] minReg=1>
<RefPosition #163 @177 RefTypeBB  BB06 regmask=[] minReg=1>
<RefPosition #164 @181 RefTypeUse <Ivl:8 V17> LCL_VAR BB06 regmask=[rax] minReg=1 last>
<RefPosition #165 @182 RefTypeDef <Ivl:6 V15> STORE_LCL_VAR BB06 regmask=[rax] minReg=1>
<RefPosition #166 @185 RefTypeUse <Ivl:9 V18> LCL_VAR BB06 regmask=[rbx] minReg=1 last>
<RefPosition #167 @186 RefTypeDef <Ivl:7 V16> STORE_LCL_VAR BB06 regmask=[rbx] minReg=1>
<RefPosition #168 @189 RefTypeUse <Ivl:1 V02> LCL_VAR BB06 regmask=[rdi] minReg=1 last>
<RefPosition #169 @190 RefTypeDef <Ivl:15 V26> STORE_LCL_VAR BB06 regmask=[rcx] minReg=1>
<RefPosition #170 @192 RefTypeDef <Ivl:41> LCL_VAR_ADDR BB06 regmask=[rdx] minReg=1>
<RefPosition #171 @193 RefTypeUse <Ivl:41>  BB06 regmask=[rdx] minReg=1 last>
<RefPosition #172 @194 RefTypeDef <Ivl:14 V25> STORE_LCL_VAR BB06 regmask=[rdx] minReg=1>
<RefPosition #173 @199 RefTypeUse <Ivl:14 V25> LCL_VAR BB06 regmask=[rdx] minReg=1>
<RefPosition #174 @199 RefTypeUse <Ivl:6 V15> LCL_VAR BB06 regmask=[rax] minReg=1 last>
<RefPosition #175 @207 RefTypeUse <Ivl:14 V25> LCL_VAR BB06 regmask=[rdx] minReg=1 last>
<RefPosition #176 @207 RefTypeUse <Ivl:7 V16> LCL_VAR BB06 regmask=[rbx] minReg=1 last>
<RefPosition #177 @211 RefTypeFixedReg <Reg:rcx>  BB06 regmask=[rcx] minReg=1>
<RefPosition #178 @211 RefTypeUse <Ivl:15 V26> LCL_VAR BB06 regmask=[rcx] minReg=1 last fixed>
<RefPosition #179 @212 RefTypeFixedReg <Reg:rcx>  BB06 regmask=[rcx] minReg=1>
<RefPosition #180 @212 RefTypeDef <Ivl:42> PUTARG_REG BB06 regmask=[rcx] minReg=1 fixed>
<RefPosition #181 @214 RefTypeDef <Ivl:43> LCL_VAR_ADDR BB06 regmask=[rdx] minReg=1>
<RefPosition #182 @215 RefTypeFixedReg <Reg:rdx>  BB06 regmask=[rdx] minReg=1>
<RefPosition #183 @215 RefTypeUse <Ivl:43>  BB06 regmask=[rdx] minReg=1 last fixed>
<RefPosition #184 @216 RefTypeFixedReg <Reg:rdx>  BB06 regmask=[rdx] minReg=1>
<RefPosition #185 @216 RefTypeDef <Ivl:44> PUTARG_REG BB06 regmask=[rdx] minReg=1 fixed>
<RefPosition #186 @217 RefTypeFixedReg <Reg:rcx>  BB06 regmask=[rcx] minReg=1>
<RefPosition #187 @217 RefTypeUse <Ivl:42>  BB06 regmask=[rcx] minReg=1 last fixed>
<RefPosition #188 @217 RefTypeFixedReg <Reg:rdx>  BB06 regmask=[rdx] minReg=1>
<RefPosition #189 @217 RefTypeUse <Ivl:44>  BB06 regmask=[rdx] minReg=1 last fixed>
<RefPosition #190 @218 RefTypeKill <Reg:rax>  BB06 regmask=[rax] minReg=1 last>
<RefPosition #191 @218 RefTypeKill <Reg:rcx>  BB06 regmask=[rcx] minReg=1 last>
<RefPosition #192 @218 RefTypeKill <Reg:rdx>  BB06 regmask=[rdx] minReg=1 last>
<RefPosition #193 @218 RefTypeKill <Reg:r8 >  BB06 regmask=[r8] minReg=1 last>
<RefPosition #194 @218 RefTypeKill <Reg:r9 >  BB06 regmask=[r9] minReg=1 last>
<RefPosition #195 @218 RefTypeKill <Reg:r10>  BB06 regmask=[r10] minReg=1 last>
<RefPosition #196 @218 RefTypeKill <Reg:r11>  BB06 regmask=[r11] minReg=1 last>

VAR REFPOSITIONS AFTER ALLOCATION
--- V00  (Interval 0)
<RefPosition #0   @0   RefTypeParamDef <Ivl:0 V00>  BB00 regmask=[rsi] minReg=1 fixed regOptional>
<RefPosition #105 @63  RefTypeUse <Ivl:0 V00> LCL_VAR BB01 regmask=[rsi] minReg=1 regOptional>
<RefPosition #116 @95  RefTypeUse <Ivl:0 V00> LCL_VAR BB03 regmask=[rsi] minReg=1>
<RefPosition #120 @105 RefTypeUse <Ivl:0 V00> LCL_VAR BB03 regmask=[rsi] minReg=1 last>
--- V01
--- V02  (Interval 1)
<RefPosition #19  @12  RefTypeDef <Ivl:1 V02> STORE_LCL_VAR BB01 regmask=[rdi] minReg=1>
<RefPosition #83  @43  RefTypeUse <Ivl:1 V02> LCL_VAR BB01 regmask=[rdi] minReg=1>
<RefPosition #103 @55  RefTypeUse <Ivl:1 V02> LCL_VAR BB01 regmask=[rdi] minReg=1>
<RefPosition #168 @189 RefTypeUse <Ivl:1 V02> LCL_VAR BB06 regmask=[rdi] minReg=1 last>
--- V03
--- V04  (Interval 2)
<RefPosition #37  @20  RefTypeDef <Ivl:2 V04> STORE_LCL_VAR BB01 regmask=[rbx] minReg=1>
<RefPosition #64  @37  RefTypeUse <Ivl:2 V04> LCL_VAR BB01 regmask=[rbx] minReg=1>
<RefPosition #88  @47  RefTypeUse <Ivl:2 V04> LCL_VAR BB01 regmask=[rdx] minReg=1 last copy fixed>
--- V05
--- V06
--- V07
--- V08  (Interval 3)
<RefPosition #123 @108 RefTypeDef <Ivl:3 V08> STORE_LCL_VAR BB03 regmask=[rsi] minReg=1>
<RefPosition #131 @129 RefTypeUse <Ivl:3 V08> LCL_VAR BB03 regmask=[rsi] minReg=1 regOptional>
<RefPosition #157 @165 RefTypeUse <Ivl:3 V08> LCL_VAR BB05 regmask=[rsi] minReg=1 last>
--- V09  (Interval 4)
<RefPosition #119 @98  RefTypeDef <Ivl:4 V09> STORE_LCL_VAR BB03 regmask=[rbx] minReg=1>
<RefPosition #153 @153 RefTypeUse <Ivl:4 V09> LCL_VAR BB05 regmask=[rbx] minReg=1 last>
--- V10
--- V11
--- V12
--- V13
--- V14  (Interval 5)
<RefPosition #130 @122 RefTypeDef <Ivl:5 V14> STORE_LCL_VAR BB03 regmask=[rdx] minReg=1>
<RefPosition #134 @139 RefTypeUse <Ivl:5 V14> LCL_VAR BB04 regmask=[rcx] minReg=1 copy fixed>
<RefPosition #138 @143 RefTypeUse <Ivl:5 V14> LCL_VAR BB04 regmask=[rdx] minReg=1 last fixed>
--- V15  (Interval 6)
<RefPosition #165 @182 RefTypeDef <Ivl:6 V15> STORE_LCL_VAR BB06 regmask=[rax] minReg=1>
<RefPosition #174 @199 RefTypeUse <Ivl:6 V15> LCL_VAR BB06 regmask=[rax] minReg=1 last>
--- V16  (Interval 7)
<RefPosition #167 @186 RefTypeDef <Ivl:7 V16> STORE_LCL_VAR BB06 regmask=[rbx] minReg=1>
<RefPosition #176 @207 RefTypeUse <Ivl:7 V16> LCL_VAR BB06 regmask=[rbx] minReg=1 last>
--- V17  (Interval 8)
<RefPosition #111 @80  RefTypeDef <Ivl:8 V17> STORE_LCL_VAR BB02 regmask=[rax] minReg=1>
<RefPosition #160 @172 RefTypeDef <Ivl:8 V17> STORE_LCL_VAR BB05 regmask=[rax] minReg=1>
<RefPosition #164 @181 RefTypeUse <Ivl:8 V17> LCL_VAR BB06 regmask=[rax] minReg=1 last>
--- V18  (Interval 9)
<RefPosition #114 @84  RefTypeDef <Ivl:9 V18> STORE_LCL_VAR BB02 regmask=[rbx] minReg=1>
<RefPosition #162 @176 RefTypeDef <Ivl:9 V18> STORE_LCL_VAR BB05 regmask=[rbx] minReg=1>
<RefPosition #166 @185 RefTypeUse <Ivl:9 V18> LCL_VAR BB06 regmask=[rbx] minReg=1 last>
--- V19  (Interval 10)
<RefPosition #156 @160 RefTypeDef <Ivl:10 V19> STORE_LCL_VAR BB05 regmask=[rax] minReg=1>
<RefPosition #159 @171 RefTypeUse <Ivl:10 V19> LCL_VAR BB05 regmask=[rax] minReg=1 last>
--- V20  (Interval 11)
<RefPosition #158 @166 RefTypeDef <Ivl:11 V20> STORE_LCL_VAR BB05 regmask=[rbx] minReg=1>
<RefPosition #161 @175 RefTypeUse <Ivl:11 V20> LCL_VAR BB05 regmask=[rbx] minReg=1 last>
--- V21  (Interval 12)
<RefPosition #109 @74  RefTypeDef <Ivl:12 V21> STORE_LCL_VAR BB02 regmask=[rax] minReg=1>
<RefPosition #110 @79  RefTypeUse <Ivl:12 V21> LCL_VAR BB02 regmask=[rax] minReg=1 last>
--- V22
--- V23  (Interval 13)
<RefPosition #154 @154 RefTypeDef <Ivl:13 V23> STORE_LCL_VAR BB05 regmask=[rbx] minReg=1>
<RefPosition #155 @159 RefTypeUse <Ivl:13 V23> LCL_VAR BB05 regmask=[rbx] minReg=1 last>
--- V24
--- V25  (Interval 14)
<RefPosition #172 @194 RefTypeDef <Ivl:14 V25> STORE_LCL_VAR BB06 regmask=[rdx] minReg=1>
<RefPosition #173 @199 RefTypeUse <Ivl:14 V25> LCL_VAR BB06 regmask=[rdx] minReg=1>
<RefPosition #175 @207 RefTypeUse <Ivl:14 V25> LCL_VAR BB06 regmask=[rdx] minReg=1 last>
--- V26  (Interval 15)
<RefPosition #169 @190 RefTypeDef <Ivl:15 V26> STORE_LCL_VAR BB06 regmask=[rcx] minReg=1>
<RefPosition #178 @211 RefTypeUse <Ivl:15 V26> LCL_VAR BB06 regmask=[rcx] minReg=1 last fixed>
--- V27  (Interval 16)
<RefPosition #128 @116 RefTypeDef <Ivl:16 V27> STORE_LCL_VAR BB03 regmask=[rdx] minReg=1>
<RefPosition #129 @121 RefTypeUse <Ivl:16 V27> LCL_VAR BB03 regmask=[rdx] minReg=1 last>

Active intervals at end of allocation:

-----------------------
RESOLVING BB BOUNDARIES
-----------------------
Resolution Candidates: {V00 V02 V08 V09 V14 V17 V18}
Has Critical Edges

Prior to Resolution

BB01
use def in out
{V00}
{V02 V04}
{V00}
{V00 V02}
Var=Reg beg of BB01: V00=rsi 
Var=Reg end of BB01: V02=rdi V00=rsi 

BB02
use def in out
{}
{V17 V18 V21 V22}
{V02}
{V02 V17 V18}
Var=Reg beg of BB02: V02=rdi 
Var=Reg end of BB02: V02=rdi V17=rax V18=rbx 

BB03
use def in out
{V00}
{V08 V09 V13 V14 V27}
{V00 V02}
{V02 V08 V09 V14}
Var=Reg beg of BB03: V02=rdi V00=rsi 
Var=Reg end of BB03: V02=rdi V08=rsi V14=rdx V09=rbx 

BB04
use def in out
{V14}
{}
{V02 V08 V09 V14}
{V02 V08 V09}
Var=Reg beg of BB04: V02=rdi V08=rsi V14=rdx V09=rbx 
Var=Reg end of BB04: V02=rdi V08=rsi V09=rbx 

BB05
use def in out
{V08 V09}
{V17 V18 V19 V20 V23}
{V02 V08 V09}
{V02 V17 V18}
Var=Reg beg of BB05: V02=rdi V08=rsi V09=rbx 
Var=Reg end of BB05: V02=rdi V17=rax V18=rbx 

BB06
use def in out
{V02 V17 V18}
{V15 V16 V25 V26}
{V02 V17 V18}
{}
Var=Reg beg of BB06: V02=rdi V17=rax V18=rbx 
Var=Reg end of BB06: none


RESOLVING EDGES
  Set V00 argument initial register to rsi
Trees after linear scan register allocator (LSRA)

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)-> BB03 ( cond )                     i label target hascall newobj LIR 
BB02 [0007]  1       BB01                  0.50     [006..007)-> BB06 (always)                     i LIR 
BB03 [0008]  1       BB01                  0.50     [006..007)-> BB05 ( cond )                     i label target idxlen nullcheck LIR 
BB04 [0014]  1       BB03                  0.25     [006..007)                                     i hascall gcsafe LIR 
BB05 [0015]  2       BB03,BB04             0.50     [006..007)                                     i label target idxlen nullcheck LIR 
BB06 [0009]  2       BB02,BB05             1        [???..???)        (return)                     internal label target hascall gcsafe newobj LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..012) -> BB03 (cond), preds={} succs={BB02,BB03}
N003 (???,???) [000234] ------------                 IL_OFFSET void   IL offset: 0x0 REG NA
N005 (  2, 10) [000001] H-----------         t1 =    CNS_INT(h) long   0xd1ffab1e token REG rcx $100
                                                  /--*  t1     long   
N007 (???,???) [000257] ------------       t257 = *  PUTARG_REG long   REG rcx
                                                  /--*  t257   long   arg0 in rcx
N009 ( 16, 16) [000002] --C---------         t2 = *  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST REG rax $180
                                                  /--*  t2     ref    
N011 ( 16, 16) [000004] DA----------              *  STORE_LCL_VAR ref    V02 tmp1         d:1 rdi REG rdi
N013 (  2, 10) [000018] H-----------        t18 =    CNS_INT(h) long   0xd1ffab1e token REG rcx $101
                                                  /--*  t18    long   
N015 (???,???) [000258] ------------       t258 = *  PUTARG_REG long   REG rcx
                                                  /--*  t258   long   arg0 in rcx
N017 ( 16, 16) [000019] --C---------        t19 = *  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST REG rax $181
                                                  /--*  t19    ref    
N019 ( 16, 16) [000021] DA----------              *  STORE_LCL_VAR ref    V04 tmp3         d:1 rbx REG rbx
N021 (  2, 10) [000044] ------------        t44 =    CNS_INT   long   0x7ffa40fb0028 REG rcx $200
                                                  /--*  t44    long   
N023 (???,???) [000259] ------------       t259 = *  PUTARG_REG long   REG rcx
N025 (  1,  1) [000045] ------------        t45 =    CNS_INT   int    6 REG rdx $42
                                                  /--*  t45    int    
N027 (???,???) [000260] ------------       t260 = *  PUTARG_REG int    REG rdx
                                                  /--*  t259   long   arg0 in rcx
                                                  +--*  t260   int    arg1 in rdx
N029 ( 17, 18) [000046] H-CXG-------        t46 = *  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS REG rax $281
N031 (  2, 10) [000143] I-----------       t143 =    CNS_INT(h) long   0xd1ffab1e static Fseq[Value] REG rdx $102
                                                  /--*  t143   long   
N033 (  4, 12) [000042] n---G-------        t42 = *  IND       ref    REG rdx <l:$2c0, c:$144>
N035 (  1,  1) [000035] ------------        t35 =    LCL_VAR   ref    V04 tmp3         u:1 rbx REG rbx $181
                                                  /--*  t35    ref    
N037 (  2,  2) [000140] ------------       t140 = *  LEA(b+8)  byref  REG rcx
                                                  /--*  t140   byref  
                                                  +--*  t42    ref    
N039 (???,???) [000235] -ACXGO------              *  STOREIND  ref    REG NA
N041 (  1,  1) [000005] ------------         t5 =    LCL_VAR   ref    V02 tmp1         u:1 rdi REG rdi $180
                                                  /--*  t5     ref    
N043 (  2,  2) [000145] ------------       t145 = *  LEA(b+16) byref  REG rcx
N045 (  1,  1) [000024] ------------        t24 =    LCL_VAR   ref    V04 tmp3         u:1 rbx (last use) REG rbx $181
                                                  /--*  t145   byref  
                                                  +--*  t24    ref    
N047 (???,???) [000236] -A--GO------              *  STOREIND  ref    REG NA
N049 (  1,  1) [000029] ------------        t29 =    LCL_VAR   ref    V02 tmp1         u:1 rdi REG rdi $180
                                                  /--*  t29    ref    
N051 (  2,  2) [000147] -c----------       t147 = *  LEA(b+8)  byref  REG NA
N053 (  1,  1) [000030] ------------        t30 =    CNS_INT   ref    null REG rcx $VN.Null
                                                  /--*  t147   byref  
                                                  +--*  t30    ref    
N055 (???,???) [000237] -A--GO------              *  STOREIND  ref    REG NA
N057 (???,???) [000238] ------------                 IL_OFFSET void   IL offset: 0x6 REG NA
N059 (  1,  1) [000008] ------------         t8 =    LCL_VAR   ref    V00 arg0         u:1 rsi REG rsi $80
N061 (  1,  1) [000050] -c----------        t50 =    CNS_INT   ref    null REG NA $VN.Null
                                                  /--*  t8     ref    
                                                  +--*  t50    ref    
N063 (  3,  3) [000051] J------N----              *  NE        void   REG NA $340
N065 (  5,  5) [000052] ------------              *  JTRUE     void   REG NA

------------ BB02 [006..007) -> BB06 (always), preds={BB01} succs={BB06}
N069 (???,???) [000239] ------------                 IL_OFFSET void   IL offset: 0x6 REG NA
N071 (  1,  1) [000149] ------------       t149 =    CNS_INT   byref  0 REG rax $VN.Null
                                                  /--*  t149   byref  
N073 (  5,  4) [000150] DA----------              *  STORE_LCL_VAR byref  V21 tmp20        d:1 rax REG rax
N075 (???,???) [000240] ------------                 IL_OFFSET void   IL offset: 0x6 REG NA
N077 (  3,  2) [000156] ------------       t156 =    LCL_VAR   byref  V21 tmp20        u:1 rax (last use) REG rax $VN.Null
                                                  /--*  t156   byref  
N079 (  7,  5) [000157] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:3 rax REG rax
N081 (  1,  1) [000233] ------------       t233 =    CNS_INT   int    0 REG rbx $40
                                                  /--*  t233   int    
N083 (  5,  4) [000160] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:3 rbx REG rbx

------------ BB03 [006..007) -> BB05 (cond), preds={BB01} succs={BB04,BB05}
N087 (???,???) [000241] ------------                 IL_OFFSET void   IL offset: 0x6 REG NA
N089 (???,???) [000242] ------------                 IL_OFFSET void   IL offset: 0x6 REG NA
N091 (  1,  1) [000171] ------------       t171 =    LCL_VAR   ref    V00 arg0         u:1 rsi REG rsi $80
N093 (  1,  1) [000172] -c----------       t172 =    CNS_INT   long   12 field offset Fseq[_firstChar] REG NA $203
                                                  /--*  t171   ref    
                                                  +--*  t172   long   
N095 (  3,  3) [000173] ------------       t173 = *  ADD       byref  REG rbx $303
                                                  /--*  t173   byref  
N097 (  7,  6) [000112] DA--G-------              *  STORE_LCL_VAR byref  V09 tmp8         d:1 rbx REG rbx
N099 (???,???) [000243] ------------                 IL_OFFSET void   IL offset: 0x6 REG NA
N101 (  1,  1) [000056] ------------        t56 =    LCL_VAR   ref    V00 arg0         u:1 rsi (last use) REG rsi $80
                                                  /--*  t56    ref    
N103 (???,???) [000256] -c----------       t256 = *  LEA(b+8)  ref    REG NA
                                                  /--*  t256   ref    
N105 (  3,  3) [000057] ---X--------        t57 = *  IND       int    REG rsi $341
                                                  /--*  t57    int    
N107 (  3,  3) [000114] DA-X--------              *  STORE_LCL_VAR int    V08 tmp7         d:1 rsi REG rsi
N109 (???,???) [000244] ------------                 IL_OFFSET void   IL offset: 0x6 REG NA
N111 (  2, 10) [000118] H-----------       t118 =    CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL] REG rcx $106
                                                  /--*  t118   long   
N113 (  4, 12) [000119] #---G-------       t119 = *  IND       ref    REG rdx $18c
                                                  /--*  t119   ref    
N115 (  8, 15) [000229] DA--G-------              *  STORE_LCL_VAR ref    V27 cse0         d:1 rdx REG rdx
N117 (???,???) [000245] ------------                 IL_OFFSET void   IL offset: 0x6 REG NA
N119 (  3,  2) [000232] ------------       t232 =    LCL_VAR   ref    V27 cse0         u:1 rdx (last use) REG rdx $18c
                                                  /--*  t232   ref    
N121 (  7,  5) [000135] DA--G-------              *  STORE_LCL_VAR ref    V14 tmp13        d:1 rdx REG rdx
N123 (???,???) [000246] ------------                 IL_OFFSET void   IL offset: 0x6 REG NA
N125 (  1,  1) [000088] ------------        t88 =    LCL_VAR   int    V08 tmp7         u:1 rsi REG rsi $400
N127 (  1,  1) [000089] -c----------        t89 =    CNS_INT   int    0 REG NA $40
                                                  /--*  t88    int    
                                                  +--*  t89    int    
N129 (  3,  3) [000090] J------N----              *  GE        void   REG NA $342
N131 (  5,  5) [000128] ------------              *  JTRUE     void   REG NA

------------ BB04 [006..007), preds={BB03} succs={BB05}
N135 (???,???) [000247] ------------                 IL_OFFSET void   IL offset: 0x6 REG NA
N137 (  3,  2) [000129] ------------       t129 =    LCL_VAR   ref    V14 tmp13        u:1 rdx REG rdx $18c
                                                  /--*  t129   ref    
N139 (???,???) [000261] ------------       t261 = *  PUTARG_REG ref    REG rcx
N141 (  3,  2) [000130] ------------       t130 =    LCL_VAR   ref    V14 tmp13        u:1 rdx (last use) REG rdx $18c
                                                  /--*  t130   ref    
N143 (???,???) [000262] ------------       t262 = *  PUTARG_REG ref    REG rdx
                                                  /--*  t261   ref    arg0 in rcx
                                                  +--*  t262   ref    arg1 in rdx
N145 ( 20, 11) [000131] --CXG-------              *  CALL      void   System.Diagnostics.Debug.Fail REG NA $VN.Void

------------ BB05 [006..007), preds={BB03,BB04} succs={BB06}
N149 (???,???) [000248] ------------                 IL_OFFSET void   IL offset: 0x6 REG NA
N151 (  3,  2) [000096] ------------        t96 =    LCL_VAR   byref  V09 tmp8         u:1 rbx (last use) REG rbx $303
                                                  /--*  t96    byref  
N153 (  7,  5) [000100] DA----------              *  STORE_LCL_VAR byref  V23 tmp22        d:1 rbx REG rbx
N155 (???,???) [000249] ------------                 IL_OFFSET void   IL offset: 0x6 REG NA
N157 (  3,  2) [000178] -------N----       t178 =    LCL_VAR   byref  V23 tmp22        u:1 rbx (last use) REG rbx $303
                                                  /--*  t178   byref  
N159 (  7,  5) [000179] DA----------              *  STORE_LCL_VAR byref  V19 tmp18        d:1 rax REG rax
N161 (???,???) [000250] ------------                 IL_OFFSET void   IL offset: 0x6 REG NA
N163 (  1,  1) [000108] ------------       t108 =    LCL_VAR   int    V08 tmp7         u:1 rsi (last use) REG rsi $400
                                                  /--*  t108   int    
N165 (  5,  4) [000110] DA----------              *  STORE_LCL_VAR int    V20 tmp19        d:1 rbx REG rbx
N167 (???,???) [000251] ------------                 IL_OFFSET void   IL offset: 0x6 REG NA
N169 (  3,  2) [000181] ------------       t181 =    LCL_VAR   byref  V19 tmp18        u:1 rax (last use) REG rax $303
                                                  /--*  t181   byref  
N171 (  7,  5) [000182] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:2 rax REG rax
N173 (  3,  2) [000184] ------------       t184 =    LCL_VAR   int    V20 tmp19        u:1 rbx (last use) REG rbx $400
                                                  /--*  t184   int    
N175 (  7,  5) [000185] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:2 rbx REG rbx

------------ BB06 [???..???) (return), preds={BB02,BB05} succs={}
N001 (  0,  0) [000226] ------------       t226 =    PHI_ARG   int    V18 tmp17        u:3 rbx $40
N002 (  0,  0) [000224] ------------       t224 =    PHI_ARG   int    V18 tmp17        u:2 rbx $400
                                                  /--*  t226   int    
                                                  +--*  t224   int    
N003 (  0,  0) [000222] ------------       t222 = *  PHI       int   
                                                  /--*  t222   int    
N005 (  0,  0) [000223] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:1 rbx
N001 (  0,  0) [000227] ------------       t227 =    PHI_ARG   byref  V17 tmp16        u:3 rax $VN.Null
N002 (  0,  0) [000225] ------------       t225 =    PHI_ARG   byref  V17 tmp16        u:2 rax $303
                                                  /--*  t227   byref  
                                                  +--*  t225   byref  
N003 (  0,  0) [000219] ------------       t219 = *  PHI       byref 
                                                  /--*  t219   byref  
N005 (  0,  0) [000220] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:1 rax
N179 (  3,  2) [000188] ------------       t188 =    LCL_VAR   byref  V17 tmp16        u:1 rax (last use) REG rax $480
                                                  /--*  t188   byref  
N181 (  7,  5) [000189] DA----------              *  STORE_LCL_VAR byref  V15 tmp14        d:1 rax REG rax
N183 (  3,  2) [000191] ------------       t191 =    LCL_VAR   int    V18 tmp17        u:1 rbx (last use) REG rbx $440
                                                  /--*  t191   int    
N185 (  7,  5) [000192] DA----------              *  STORE_LCL_VAR int    V16 tmp15        d:1 rbx REG rbx
N187 (  1,  1) [000007] ------------         t7 =    LCL_VAR   ref    V02 tmp1         u:1 rdi (last use) REG rdi $180
                                                  /--*  t7     ref    
N189 (  1,  3) [000214] DA--------L-              *  STORE_LCL_VAR ref    V26 tmp25        d:1 rcx REG rcx
N191 (  3,  2) [000198] -------N----       t198 =    LCL_VAR_ADDR byref  V24 tmp23         rdx REG rdx
                                                  /--*  t198   byref  
N193 (  3,  3) [000200] DA----------              *  STORE_LCL_VAR byref  V25 tmp24        d:1 rdx REG rdx
N195 (  1,  1) [000201] ------------       t201 =    LCL_VAR   byref  V25 tmp24        u:1 rdx Zero Fseq[_pointer] REG rdx $3c7
N197 (  3,  2) [000203] -------N----       t203 =    LCL_VAR   byref  V15 tmp14        u:1 rax (last use) REG rax $480
                                                  /--*  t201   byref  
                                                  +--*  t203   byref  
N199 (???,???) [000252] -A----------              *  STOREIND  byref  REG NA
N201 (  1,  1) [000206] ------------       t206 =    LCL_VAR   byref  V25 tmp24        u:1 rdx (last use) REG rdx $3c7
                                                  /--*  t206   byref  
N203 (  2,  2) [000208] -c----------       t208 = *  LEA(b+8)  byref  REG NA
N205 (  3,  2) [000210] -------N----       t210 =    LCL_VAR   int    V16 tmp15        u:1 rbx (last use) REG rbx $440
                                                  /--*  t208   byref  
                                                  +--*  t210   int    
N207 (???,???) [000253] -A--------L-              *  STOREIND  int    REG NA
N209 (  1,  1) [000215] ------------       t215 =    LCL_VAR   ref    V26 tmp25        u:1 rcx (last use) REG rcx $180
                                                  /--*  t215   ref    
N211 (???,???) [000263] ------------       t263 = *  PUTARG_REG ref    REG rcx
N213 (  3,  2) [000216] -------N----       t216 =    LCL_VAR_ADDR byref  V24 tmp23         rdx REG rdx
                                                  /--*  t216   byref  
N215 (???,???) [000264] ------------       t264 = *  PUTARG_REG byref  REG rdx
                                                  /--*  t263   ref    this in rcx
                                                  +--*  t264   byref  arg1 in rdx
N217 ( 40, 30) [000011] --CXG-------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer.TokenizeLine REG NA $VN.Void
N219 (???,???) [000254] ------------                 IL_OFFSET void   IL offset: 0x11 REG NA
N221 (  0,  0) [000017] ------------                 RETURN    void   REG NA $382

-------------------------------------------------------------------------------------------------------------------

Final allocation
--------------------------------+----+----+----+----+----+----+----+----+----+
Loc RP#  Name Type  Action Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
--------------------------------+----+----+----+----+----+----+----+----+----+
  0.#0   V0   Parm   Alloc rsi  |    |    |    |    |    |V0 a|    |    |    |
  1.#1   BB1 PredBB0            |    |    |    |    |    |V0 a|    |    |    |
  6.#2   C17  Def    Alloc rcx  |    |C17a|    |    |    |V0 a|    |    |    |
  7.#3   rcx  Fixd   Keep  rcx  |    |C17a|    |    |    |V0 a|    |    |    |
  7.#4   C17  Use *  Keep  rcx  |    |C17i|    |    |    |V0 a|    |    |    |
  8.#5   rcx  Fixd   Keep  rcx  |    |    |    |    |    |V0 a|    |    |    |
  8.#6   I18  Def    Alloc rcx  |    |I18a|    |    |    |V0 a|    |    |    |
  9.#7   rcx  Fixd   Keep  rcx  |    |I18a|    |    |    |V0 a|    |    |    |
  9.#8   I18  Use *  Keep  rcx  |    |I18i|    |    |    |V0 a|    |    |    |
 10.#9   rax  Kill   Keep  rax  |    |    |    |    |    |V0 a|    |    |    |
 10.#10  rcx  Kill   Keep  rcx  |    |    |    |    |    |V0 a|    |    |    |
 10.#11  rdx  Kill   Keep  rdx  |    |    |    |    |    |V0 a|    |    |    |
 10.#12  r8   Kill   Keep  r8   |    |    |    |    |    |V0 a|    |    |    |
 10.#13  r9   Kill   Keep  r9   |    |    |    |    |    |V0 a|    |    |    |
 10.#14  r10  Kill   Keep  r10  |    |    |    |    |    |V0 a|    |    |    |
 10.#15  r11  Kill   Keep  r11  |    |    |    |    |    |V0 a|    |    |    |
 10.#16  rax  Fixd   Keep  rax  |    |    |    |    |    |V0 a|    |    |    |
 10.#17  I19  Def    Alloc rax  |I19a|    |    |    |    |V0 a|    |    |    |
 11.#18  I19  Use *  Keep  rax  |I19i|    |    |    |    |V0 a|    |    |    |
 12.#19  V2   Def    Alloc rdi  |    |    |    |    |    |V0 a|V2 a|    |    |
 14.#20  C20  Def    Alloc rcx  |    |C20a|    |    |    |V0 a|V2 a|    |    |
 15.#21  rcx  Fixd   Keep  rcx  |    |C20a|    |    |    |V0 a|V2 a|    |    |
 15.#22  C20  Use *  Keep  rcx  |    |C20i|    |    |    |V0 a|V2 a|    |    |
 16.#23  rcx  Fixd   Keep  rcx  |    |    |    |    |    |V0 a|V2 a|    |    |
 16.#24  I21  Def    Alloc rcx  |    |I21a|    |    |    |V0 a|V2 a|    |    |
 17.#25  rcx  Fixd   Keep  rcx  |    |I21a|    |    |    |V0 a|V2 a|    |    |
 17.#26  I21  Use *  Keep  rcx  |    |I21i|    |    |    |V0 a|V2 a|    |    |
 18.#27  rax  Kill   Keep  rax  |    |    |    |    |    |V0 a|V2 a|    |    |
 18.#28  rcx  Kill   Keep  rcx  |    |    |    |    |    |V0 a|V2 a|    |    |
 18.#29  rdx  Kill   Keep  rdx  |    |    |    |    |    |V0 a|V2 a|    |    |
 18.#30  r8   Kill   Keep  r8   |    |    |    |    |    |V0 a|V2 a|    |    |
 18.#31  r9   Kill   Keep  r9   |    |    |    |    |    |V0 a|V2 a|    |    |
 18.#32  r10  Kill   Keep  r10  |    |    |    |    |    |V0 a|V2 a|    |    |
 18.#33  r11  Kill   Keep  r11  |    |    |    |    |    |V0 a|V2 a|    |    |
 18.#34  rax  Fixd   Keep  rax  |    |    |    |    |    |V0 a|V2 a|    |    |
 18.#35  I22  Def    Alloc rax  |I22a|    |    |    |    |V0 a|V2 a|    |    |
 19.#36  I22  Use *  Keep  rax  |I22i|    |    |    |    |V0 a|V2 a|    |    |
 20.#37  V4   Def    Alloc rbx  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 22.#38  C23  Def    Alloc rcx  |    |C23a|    |V4 a|    |V0 a|V2 a|    |    |
 23.#39  rcx  Fixd   Keep  rcx  |    |C23a|    |V4 a|    |V0 a|V2 a|    |    |
 23.#40  C23  Use *  Keep  rcx  |    |C23i|    |V4 a|    |V0 a|V2 a|    |    |
 24.#41  rcx  Fixd   Keep  rcx  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 24.#42  I24  Def    Alloc rcx  |    |I24a|    |V4 a|    |V0 a|V2 a|    |    |
 26.#43  C25  Def    Alloc rdx  |    |I24a|C25a|V4 a|    |V0 a|V2 a|    |    |
 27.#44  rdx  Fixd   Keep  rdx  |    |I24a|C25a|V4 a|    |V0 a|V2 a|    |    |
 27.#45  C25  Use *  Keep  rdx  |    |I24a|C25i|V4 a|    |V0 a|V2 a|    |    |
 28.#46  rdx  Fixd   Keep  rdx  |    |I24a|    |V4 a|    |V0 a|V2 a|    |    |
 28.#47  I26  Def    Alloc rdx  |    |I24a|I26a|V4 a|    |V0 a|V2 a|    |    |
 29.#48  rcx  Fixd   Keep  rcx  |    |I24a|I26a|V4 a|    |V0 a|V2 a|    |    |
 29.#49  I24  Use *  Keep  rcx  |    |I24i|I26a|V4 a|    |V0 a|V2 a|    |    |
 29.#50  rdx  Fixd   Keep  rdx  |    |    |I26a|V4 a|    |V0 a|V2 a|    |    |
 29.#51  I26  Use *  Keep  rdx  |    |    |I26i|V4 a|    |V0 a|V2 a|    |    |
 30.#52  rax  Kill   Keep  rax  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 30.#53  rcx  Kill   Keep  rcx  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 30.#54  rdx  Kill   Keep  rdx  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 30.#55  r8   Kill   Keep  r8   |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 30.#56  r9   Kill   Keep  r9   |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 30.#57  r10  Kill   Keep  r10  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 30.#58  r11  Kill   Keep  r11  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 30.#59  rax  Fixd   Keep  rax  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 30.#60  I27  Def *  Alloc rax  |I27i|    |    |V4 a|    |V0 a|V2 a|    |    |
 32.#61  C28  Def    Alloc rdx  |    |    |C28a|V4 a|    |V0 a|V2 a|    |    |
 33.#62  C28  Use *  Keep  rdx  |    |    |C28i|V4 a|    |V0 a|V2 a|    |    |
 34.#63  I29  Def    Alloc rdx  |    |    |I29a|V4 a|    |V0 a|V2 a|    |    |
 37.#64  V4   Use    Keep  rbx  |    |    |I29a|V4 a|    |V0 a|V2 a|    |    |
 38.#65  I30  Def    Alloc rcx  |    |I30a|I29a|V4 a|    |V0 a|V2 a|    |    |
 39.#66  rcx  Fixd   Keep  rcx  |    |I30a|I29a|V4 a|    |V0 a|V2 a|    |    |
 39.#67  I30  Use *  Keep  rcx  |    |I30i|I29a|V4 a|    |V0 a|V2 a|    |    |
 39.#68  rdx  Fixd   Keep  rdx  |    |    |I29a|V4 a|    |V0 a|V2 a|    |    |
 39.#69  I29  Use *  Keep  rdx  |    |    |I29i|V4 a|    |V0 a|V2 a|    |    |
 40.#70  rax  Kill   Keep  rax  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 40.#71  rcx  Kill   Keep  rcx  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 40.#72  rdx  Kill   Keep  rdx  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 40.#73  r8   Kill   Keep  r8   |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 40.#74  r9   Kill   Keep  r9   |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 40.#75  r10  Kill   Keep  r10  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 40.#76  r11  Kill   Keep  r11  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 40.#77  mm0  Kill   Keep  mm0  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 40.#78  mm1  Kill   Keep  mm1  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 40.#79  mm2  Kill   Keep  mm2  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 40.#80  mm3  Kill   Keep  mm3  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 40.#81  mm4  Kill   Keep  mm4  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 40.#82  mm5  Kill   Keep  mm5  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 43.#83  V2   Use    Keep  rdi  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
 44.#84  I31  Def    Alloc rcx  |    |I31a|    |V4 a|    |V0 a|V2 a|    |    |
 47.#85  rcx  Fixd   Keep  rcx  |    |I31a|    |V4 a|    |V0 a|V2 a|    |    |
 47.#86  I31  Use *  Keep  rcx  |    |I31i|    |V4 a|    |V0 a|V2 a|    |    |
 47.#87  rdx  Fixd   Keep  rdx  |    |    |    |V4 a|    |V0 a|V2 a|    |    |
--------------------------------+----+----+----+----+----+----+----+----+----+
Loc RP#  Name Type  Action Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
--------------------------------+----+----+----+----+----+----+----+----+----+
 47.#88  V4   Use *  Copy  rdx  |    |    |V4 i|V4 i|    |V0 a|V2 a|    |    |
 48.#89  rax  Kill   Keep  rax  |    |    |    |    |    |V0 a|V2 a|    |    |
 48.#90  rcx  Kill   Keep  rcx  |    |    |    |    |    |V0 a|V2 a|    |    |
 48.#91  rdx  Kill   Keep  rdx  |    |    |    |    |    |V0 a|V2 a|    |    |
 48.#92  r8   Kill   Keep  r8   |    |    |    |    |    |V0 a|V2 a|    |    |
 48.#93  r9   Kill   Keep  r9   |    |    |    |    |    |V0 a|V2 a|    |    |
 48.#94  r10  Kill   Keep  r10  |    |    |    |    |    |V0 a|V2 a|    |    |
 48.#95  r11  Kill   Keep  r11  |    |    |    |    |    |V0 a|V2 a|    |    |
 48.#96  mm0  Kill   Keep  mm0  |    |    |    |    |    |V0 a|V2 a|    |    |
 48.#97  mm1  Kill   Keep  mm1  |    |    |    |    |    |V0 a|V2 a|    |    |
 48.#98  mm2  Kill   Keep  mm2  |    |    |    |    |    |V0 a|V2 a|    |    |
 48.#99  mm3  Kill   Keep  mm3  |    |    |    |    |    |V0 a|V2 a|    |    |
 48.#100 mm4  Kill   Keep  mm4  |    |    |    |    |    |V0 a|V2 a|    |    |
 48.#101 mm5  Kill   Keep  mm5  |    |    |    |    |    |V0 a|V2 a|    |    |
 54.#102 C32  Def    Alloc rcx  |    |C32a|    |    |    |V0 a|V2 a|    |    |
 55.#103 V2   Use    Keep  rdi  |    |C32a|    |    |    |V0 a|V2 a|    |    |
 55.#104 C32  Use *  Keep  rcx  |    |C32i|    |    |    |V0 a|V2 a|    |    |
 63.#105 V0   Use    Keep  rsi  |    |    |    |    |    |V0 a|V2 a|    |    |
--------------------------------+----+----+----+----+----+----+----+----+----+
Loc RP#  Name Type  Action Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
--------------------------------+----+----+----+----+----+----+----+----+----+
 67.#106 BB2 PredBB1            |    |    |    |    |    |    |V2 a|    |    |
 72.#107 C33  Def    Alloc rax  |C33a|    |    |    |    |    |V2 a|    |    |
 73.#108 C33  Use *  Keep  rax  |C33i|    |    |    |    |    |V2 a|    |    |
 74.#109 V21  Def    Alloc rax  |V21a|    |    |    |    |    |V2 a|    |    |
 79.#110 V21  Use *  Keep  rax  |V21i|    |    |    |    |    |V2 a|    |    |
 80.#111 V17  Def    Alloc rax  |V17a|    |    |    |    |    |V2 a|    |    |
 82.#112 C34  Def    Alloc rbx  |V17a|    |    |C34a|    |    |V2 a|    |    |
 83.#113 C34  Use *  Keep  rbx  |V17a|    |    |C34i|    |    |V2 a|    |    |
 84.#114 V18  Def    Alloc rbx  |V17a|    |    |V18a|    |    |V2 a|    |    |
--------------------------------+----+----+----+----+----+----+----+----+----+
Loc RP#  Name Type  Action Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
--------------------------------+----+----+----+----+----+----+----+----+----+
 85.#115 BB3 PredBB1            |    |    |    |    |    |V0 a|V2 a|    |    |
 95.#116 V0   Use    Keep  rsi  |    |    |    |    |    |V0 a|V2 a|    |    |
 96.#117 I35  Def    Alloc rbx  |    |    |    |I35a|    |V0 a|V2 a|    |    |
 97.#118 I35  Use *  Keep  rbx  |    |    |    |I35i|    |V0 a|V2 a|    |    |
 98.#119 V9   Def    Alloc rbx  |    |    |    |V9 a|    |V0 a|V2 a|    |    |
105.#120 V0   Use *  Keep  rsi  |    |    |    |V9 a|    |V0 i|V2 a|    |    |
106.#121 I36  Def    Alloc rsi  |    |    |    |V9 a|    |I36a|V2 a|    |    |
107.#122 I36  Use *  Keep  rsi  |    |    |    |V9 a|    |I36i|V2 a|    |    |
108.#123 V8   Def    Alloc rsi  |    |    |    |V9 a|    |V8 a|V2 a|    |    |
112.#124 C37  Def    Alloc rcx  |    |C37a|    |V9 a|    |V8 a|V2 a|    |    |
113.#125 C37  Use *  Keep  rcx  |    |C37i|    |V9 a|    |V8 a|V2 a|    |    |
114.#126 I38  Def    Alloc rdx  |    |    |I38a|V9 a|    |V8 a|V2 a|    |    |
115.#127 I38  Use *  Keep  rdx  |    |    |I38i|V9 a|    |V8 a|V2 a|    |    |
116.#128 V27  Def    Alloc rdx  |    |    |V27a|V9 a|    |V8 a|V2 a|    |    |
121.#129 V27  Use *  Keep  rdx  |    |    |V27i|V9 a|    |V8 a|V2 a|    |    |
122.#130 V14  Def    Alloc rdx  |    |    |V14a|V9 a|    |V8 a|V2 a|    |    |
129.#131 V8   Use    Keep  rsi  |    |    |V14a|V9 a|    |V8 a|V2 a|    |    |
--------------------------------+----+----+----+----+----+----+----+----+----+
Loc RP#  Name Type  Action Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
--------------------------------+----+----+----+----+----+----+----+----+----+
133.#132 BB4 PredBB3            |    |    |V14a|V9 a|    |V8 a|V2 a|    |    |
139.#133 rcx  Fixd   Keep  rcx  |    |    |V14a|V9 a|    |V8 a|V2 a|    |    |
139.#134 V14  Use    Copy  rcx  |    |V14a|V14a|V9 a|    |V8 a|V2 a|    |    |
140.#135 rcx  Fixd   Keep  rcx  |    |    |V14a|V9 a|    |V8 a|V2 a|    |    |
140.#136 I39  Def    Alloc rcx  |    |I39a|V14a|V9 a|    |V8 a|V2 a|    |    |
143.#137 rdx  Fixd   Keep  rdx  |    |I39a|V14a|V9 a|    |V8 a|V2 a|    |    |
143.#138 V14  Use *  Keep  rdx  |    |I39a|V14i|V9 a|    |V8 a|V2 a|    |    |
144.#139 rdx  Fixd   Keep  rdx  |    |I39a|    |V9 a|    |V8 a|V2 a|    |    |
144.#140 I40  Def    Alloc rdx  |    |I39a|I40a|V9 a|    |V8 a|V2 a|    |    |
145.#141 rcx  Fixd   Keep  rcx  |    |I39a|I40a|V9 a|    |V8 a|V2 a|    |    |
145.#142 I39  Use *  Keep  rcx  |    |I39i|I40a|V9 a|    |V8 a|V2 a|    |    |
145.#143 rdx  Fixd   Keep  rdx  |    |    |I40a|V9 a|    |V8 a|V2 a|    |    |
145.#144 I40  Use *  Keep  rdx  |    |    |I40i|V9 a|    |V8 a|V2 a|    |    |
146.#145 rax  Kill   Keep  rax  |    |    |    |V9 a|    |V8 a|V2 a|    |    |
146.#146 rcx  Kill   Keep  rcx  |    |    |    |V9 a|    |V8 a|V2 a|    |    |
146.#147 rdx  Kill   Keep  rdx  |    |    |    |V9 a|    |V8 a|V2 a|    |    |
146.#148 r8   Kill   Keep  r8   |    |    |    |V9 a|    |V8 a|V2 a|    |    |
146.#149 r9   Kill   Keep  r9   |    |    |    |V9 a|    |V8 a|V2 a|    |    |
146.#150 r10  Kill   Keep  r10  |    |    |    |V9 a|    |V8 a|V2 a|    |    |
146.#151 r11  Kill   Keep  r11  |    |    |    |V9 a|    |V8 a|V2 a|    |    |
--------------------------------+----+----+----+----+----+----+----+----+----+
Loc RP#  Name Type  Action Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
--------------------------------+----+----+----+----+----+----+----+----+----+
147.#152 BB5 PredBB3            |    |    |    |V9 a|    |V8 a|V2 a|    |    |
153.#153 V9   Use *  Keep  rbx  |    |    |    |V9 i|    |V8 a|V2 a|    |    |
154.#154 V23  Def    Alloc rbx  |    |    |    |V23a|    |V8 a|V2 a|    |    |
159.#155 V23  Use *  Keep  rbx  |    |    |    |V23i|    |V8 a|V2 a|    |    |
160.#156 V19  Def    Alloc rax  |V19a|    |    |    |    |V8 a|V2 a|    |    |
165.#157 V8   Use *  Keep  rsi  |V19a|    |    |    |    |V8 i|V2 a|    |    |
166.#158 V20  Def    Alloc rbx  |V19a|    |    |V20a|    |    |V2 a|    |    |
171.#159 V19  Use *  Keep  rax  |V19i|    |    |V20a|    |    |V2 a|    |    |
172.#160 V17  Def    Alloc rax  |V17a|    |    |V20a|    |    |V2 a|    |    |
175.#161 V20  Use *  Keep  rbx  |V17a|    |    |V20i|    |    |V2 a|    |    |
176.#162 V18  Def    Alloc rbx  |V17a|    |    |V18a|    |    |V2 a|    |    |
--------------------------------+----+----+----+----+----+----+----+----+----+
Loc RP#  Name Type  Action Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
--------------------------------+----+----+----+----+----+----+----+----+----+
177.#163 BB6 PredBB2            |V17a|    |    |V18a|    |    |V2 a|    |    |
181.#164 V17  Use *  Keep  rax  |V17i|    |    |V18a|    |    |V2 a|    |    |
182.#165 V15  Def    Alloc rax  |V15a|    |    |V18a|    |    |V2 a|    |    |
185.#166 V18  Use *  Keep  rbx  |V15a|    |    |V18i|    |    |V2 a|    |    |
186.#167 V16  Def    Alloc rbx  |V15a|    |    |V16a|    |    |V2 a|    |    |
189.#168 V2   Use *  Keep  rdi  |V15a|    |    |V16a|    |    |V2 i|    |    |
190.#169 V26  Def    Alloc rcx  |V15a|V26a|    |V16a|    |    |    |    |    |
192.#170 I41  Def    Alloc rdx  |V15a|V26a|I41a|V16a|    |    |    |    |    |
193.#171 I41  Use *  Keep  rdx  |V15a|V26a|I41i|V16a|    |    |    |    |    |
194.#172 V25  Def    Alloc rdx  |V15a|V26a|V25a|V16a|    |    |    |    |    |
199.#173 V25  Use    Keep  rdx  |V15a|V26a|V25a|V16a|    |    |    |    |    |
199.#174 V15  Use *  Keep  rax  |V15i|V26a|V25a|V16a|    |    |    |    |    |
207.#175 V25  Use *  Keep  rdx  |    |V26a|V25i|V16a|    |    |    |    |    |
207.#176 V16  Use *  Keep  rbx  |    |V26a|    |V16i|    |    |    |    |    |
211.#177 rcx  Fixd   Keep  rcx  |    |V26a|    |    |    |    |    |    |    |
211.#178 V26  Use *  Keep  rcx  |    |V26i|    |    |    |    |    |    |    |
212.#179 rcx  Fixd   Keep  rcx  |    |    |    |    |    |    |    |    |    |
212.#180 I42  Def    Alloc rcx  |    |I42a|    |    |    |    |    |    |    |
214.#181 I43  Def    Alloc rdx  |    |I42a|I43a|    |    |    |    |    |    |
215.#182 rdx  Fixd   Keep  rdx  |    |I42a|I43a|    |    |    |    |    |    |
215.#183 I43  Use *  Keep  rdx  |    |I42a|I43i|    |    |    |    |    |    |
216.#184 rdx  Fixd   Keep  rdx  |    |I42a|    |    |    |    |    |    |    |
216.#185 I44  Def    Alloc rdx  |    |I42a|I44a|    |    |    |    |    |    |
217.#186 rcx  Fixd   Keep  rcx  |    |I42a|I44a|    |    |    |    |    |    |
217.#187 I42  Use *  Keep  rcx  |    |I42i|I44a|    |    |    |    |    |    |
217.#188 rdx  Fixd   Keep  rdx  |    |    |I44a|    |    |    |    |    |    |
217.#189 I44  Use *  Keep  rdx  |    |    |I44i|    |    |    |    |    |    |
218.#190 rax  Kill   Keep  rax  |    |    |    |    |    |    |    |    |    |
218.#191 rcx  Kill   Keep  rcx  |    |    |    |    |    |    |    |    |    |
218.#192 rdx  Kill   Keep  rdx  |    |    |    |    |    |    |    |    |    |
218.#193 r8   Kill   Keep  r8   |    |    |    |    |    |    |    |    |    |
218.#194 r9   Kill   Keep  r9   |    |    |    |    |    |    |    |    |    |
218.#195 r10  Kill   Keep  r10  |    |    |    |    |    |    |    |    |    |
218.#196 r11  Kill   Keep  r11  |    |    |    |    |    |    |    |    |    |

Recording the maximum number of concurrent spills:

----------
LSRA Stats
----------
Total Tracked Vars:  19
Total Reg Cand Vars: 17
Total number of Intervals: 44
Total number of RefPositions: 196
Total Spill Count: 0    Weighted: 0
Total CopyReg Count: 0   Weighted: 0
Total ResolutionMov Count: 0    Weighted: 0
Total number of split edges: 0
Total Number of spill temps created: 0

TUPLE STYLE DUMP WITH REGISTER ASSIGNMENTS
Incoming Parameters:  V00(rcx=>rsi)
BB01 [000..012) -> BB03 (cond), preds={} succs={BB02,BB03}
=====
  N003.                    IL_OFFSET IL offset: 0x0
  N005. rcx             =  CNS_INT(h) 0xd1ffab1e token
  N007. rcx             =  PUTARG_REG; rcx
  N009. rax             =  CALL help; rcx
* N011.                    V02(rdi); rax
  N013. rcx             =  CNS_INT(h) 0xd1ffab1e token
  N015. rcx             =  PUTARG_REG; rcx
  N017. rax             =  CALL help; rcx
* N019.                    V04(rbx); rax
  N021. rcx             =  CNS_INT   0x7ffa40fb0028
  N023. rcx             =  PUTARG_REG; rcx
  N025. rdx             =  CNS_INT   6
  N027. rdx             =  PUTARG_REG; rdx
* N029. rax             =  CALL help; rcx,rdx
  N031. rdx             =  CNS_INT(h) 0xd1ffab1e static Fseq[Value]
  N033. rdx             =  IND      ; rdx
  N035.                    V04(rbx)
  N037. rcx             =  LEA(b+8) ; rbx
  N039.                    STOREIND ; rcx,rdx
  N041.                    V02(rdi)
  N043. rcx             =  LEA(b+16); rdi
  N045.                    V04(rbx*)
  N047.                    STOREIND ; rcx,rbx*
  N049.                    V02(rdi)
  N051. STK             =  LEA(b+8) ; rdi
  N053. rcx             =  CNS_INT   null
  N055.                    STOREIND ; STK,rcx
  N057.                    IL_OFFSET IL offset: 0x6
  N059.                    V00(rsi)
  N061.                    CNS_INT   null
  N063.                    NE       ; rsi
  N065.                    JTRUE    
Var=Reg end of BB01: V02=rdi V00=rsi 

BB02 [006..007) -> BB06 (always), preds={BB01} succs={BB06}
=====
Predecessor for variable locations: BB01
Var=Reg beg of BB02: V02=rdi 
  N069.                    IL_OFFSET IL offset: 0x6
  N071. rax             =  CNS_INT   0
* N073.                    V21(rax); rax
  N075.                    IL_OFFSET IL offset: 0x6
  N077.                    V21(rax*)
* N079.                    V17(rax); rax*
  N081. rbx             =  CNS_INT   0
* N083.                    V18(rbx); rbx
Var=Reg end of BB02: V02=rdi V17=rax V18=rbx 

BB03 [006..007) -> BB05 (cond), preds={BB01} succs={BB04,BB05}
=====
Predecessor for variable locations: BB01
Var=Reg beg of BB03: V02=rdi V00=rsi 
  N087.                    IL_OFFSET IL offset: 0x6
  N089.                    IL_OFFSET IL offset: 0x6
  N091.                    V00(rsi)
  N093.                    CNS_INT   12 field offset Fseq[_firstChar]
  N095. rbx             =  ADD      ; rsi
* N097.                    V09(rbx); rbx
  N099.                    IL_OFFSET IL offset: 0x6
  N101.                    V00(rsi*)
  N103. STK             =  LEA(b+8) ; rsi*
  N105. rsi             =  IND      ; STK
* N107.                    V08(rsi); rsi
  N109.                    IL_OFFSET IL offset: 0x6
  N111. rcx             =  CNS_INT(h) 0xD1FFAB1E [ICON_STR_HDL]
  N113. rdx             =  IND      ; rcx
* N115.                    V27(rdx); rdx
  N117.                    IL_OFFSET IL offset: 0x6
  N119.                    V27(rdx*)
* N121.                    V14(rdx); rdx*
  N123.                    IL_OFFSET IL offset: 0x6
  N125.                    V08(rsi)
  N127.                    CNS_INT   0
  N129.                    GE       ; rsi
  N131.                    JTRUE    
Var=Reg end of BB03: V02=rdi V08=rsi V14=rdx V09=rbx 

BB04 [006..007), preds={BB03} succs={BB05}
=====
Predecessor for variable locations: BB03
Var=Reg beg of BB04: V02=rdi V08=rsi V14=rdx V09=rbx 
  N135.                    IL_OFFSET IL offset: 0x6
  N137.                    V14(rdx)
  N139. rcx             =  PUTARG_REG; rdx
  N141.                    V14(rdx*)
  N143. rdx             =  PUTARG_REG; rdx*
  N145.                    CALL     ; rcx,rdx
Var=Reg end of BB04: V02=rdi V08=rsi V09=rbx 

BB05 [006..007), preds={BB03,BB04} succs={BB06}
=====
Predecessor for variable locations: BB03
Var=Reg beg of BB05: V02=rdi V08=rsi V09=rbx 
  N149.                    IL_OFFSET IL offset: 0x6
  N151.                    V09(rbx*)
* N153.                    V23(rbx); rbx*
  N155.                    IL_OFFSET IL offset: 0x6
  N157.                    V23(rbx*)
* N159.                    V19(rax); rbx*
  N161.                    IL_OFFSET IL offset: 0x6
  N163.                    V08(rsi*)
* N165.                    V20(rbx); rsi*
  N167.                    IL_OFFSET IL offset: 0x6
  N169.                    V19(rax*)
* N171.                    V17(rax); rax*
  N173.                    V20(rbx*)
* N175.                    V18(rbx); rbx*
Var=Reg end of BB05: V02=rdi V17=rax V18=rbx 

BB06 [???..???) (return), preds={BB02,BB05} succs={}
=====
Predecessor for variable locations: BB02
Var=Reg beg of BB06: V02=rdi V17=rax V18=rbx 
  N179.                    V17(rax*)
* N181.                    V15(rax); rax*
  N183.                    V18(rbx*)
* N185.                    V16(rbx); rbx*
  N187.                    V02(rdi*)
* N189.                    V26(rcx); rdi*
  N191. rdx             =  LCL_VAR_ADDR V24 tmp23         rdx
* N193.                    V25(rdx); rdx
  N195.                    V25(rdx)
  N197.                    V15(rax*)
  N199.                    STOREIND ; rdx,rax*
  N201.                    V25(rdx*)
  N203. STK             =  LEA(b+8) ; rdx*
  N205.                    V16(rbx*)
  N207.                    STOREIND ; STK,rbx*
  N209.                    V26(rcx*)
  N211. rcx             =  PUTARG_REG; rcx*
  N213. rdx             =  LCL_VAR_ADDR V24 tmp23         rdx
  N215. rdx             =  PUTARG_REG; rdx
  N217.                    CALL     ; rcx,rdx
  N219.                    IL_OFFSET IL offset: 0x11
  N221.                    RETURN   
Var=Reg end of BB06: none




*************** Finishing PHASE Linear scan register alloc
*************** In genGenerateCode()

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1        [000..012)-> BB03 ( cond )                     i label target hascall newobj LIR 
BB02 [0007]  1       BB01                  0.50     [006..007)-> BB06 (always)                     i LIR 
BB03 [0008]  1       BB01                  0.50     [006..007)-> BB05 ( cond )                     i label target idxlen nullcheck LIR 
BB04 [0014]  1       BB03                  0.25     [006..007)                                     i hascall gcsafe LIR 
BB05 [0015]  2       BB03,BB04             0.50     [006..007)                                     i label target idxlen nullcheck LIR 
BB06 [0009]  2       BB02,BB05             1        [???..???)        (return)                     internal label target hascall gcsafe newobj LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Generate code
*************** In fgDebugCheckBBlist
Finalizing stack frame
Recording Var Locations at start of BB01
  V00(rsi)
Modified regs: [rax rcx rdx rbx rsi rdi r8-r11 mm0-mm5]
Callee-saved registers pushed: 3 [rbx rsi rdi]
*************** In lvaAssignFrameOffsets(FINAL_FRAME_LAYOUT)
Assign V24 tmp23, size=16, stkOffs=-0x30
Assign V01 OutArgs, size=32, stkOffs=-0x50
--- delta bump 8 for RA
--- delta bump 72 for RSP frame
--- virtual stack offset to actual stack offset delta is 80
-- V00 was 0, now 80
-- V01 was -80, now 0
-- V24 was -48, now 32
; Final local variable assignments
;
;  V00 arg0         [V00,T01] (  5,  4   )     ref  ->  rsi         class-hnd
;  V01 OutArgs      [V01    ] (  1,  1   )  lclBlk (32) [rsp+0x00]   "OutgoingArgSpace"
;  V02 tmp1         [V02,T00] (  4,  8   )     ref  ->  rdi         class-hnd exact "NewObj constructor temp"
;* V03 tmp2         [V03    ] (  0,  0   )  struct (16) zero-ref    "struct address for call/obj"
;  V04 tmp3         [V04,T02] (  3,  6   )     ref  ->  rbx         class-hnd exact "NewObj constructor temp"
;* V05 tmp4         [V05    ] (  0,  0   )  struct (16) zero-ref    "Inline return value spill temp"
;* V06 tmp5         [V06    ] (  0,  0   )  struct (16) zero-ref    "NewObj constructor temp"
;* V07 tmp6         [V07    ] (  0,  0   )  struct (16) zero-ref    ld-addr-op "Inline ldloca(s) first use temp"
;  V08 tmp7         [V08,T05] (  3,  3   )     int  ->  rsi         "Inlining Arg"
;  V09 tmp8         [V09,T09] (  2,  2   )   byref  ->  rbx         "Inlining Arg"
;* V10 tmp9         [V10    ] (  0,  0   )  struct ( 8) zero-ref    "NewObj constructor temp"
;* V11 tmp10        [V11    ] (  0,  0   )    bool  ->  zero-ref    "Inlining Arg"
;* V12 tmp11        [V12    ] (  0,  0   )    bool  ->  zero-ref    "Inlining Arg"
;* V13 tmp12        [V13,T17] (  0,  0   )     ref  ->  zero-ref    class-hnd "Inlining Arg"
;  V14 tmp13        [V14,T06] (  3,  2   )     ref  ->  rdx         class-hnd "Inlining Arg"
;  V15 tmp14        [V15,T10] (  2,  2   )   byref  ->  rax         V03._pointer(offs=0x00) P-INDEP "field V03._pointer (fldOffset=0x0)"
;  V16 tmp15        [V16,T11] (  2,  2   )     int  ->  rbx         V03._length(offs=0x08) P-INDEP "field V03._length (fldOffset=0x8)"
;  V17 tmp16        [V17,T07] (  3,  2   )   byref  ->  rax         V05._pointer(offs=0x00) P-INDEP "field V05._pointer (fldOffset=0x0)"
;  V18 tmp17        [V18,T08] (  3,  2   )     int  ->  rbx         V05._length(offs=0x08) P-INDEP "field V05._length (fldOffset=0x8)"
;  V19 tmp18        [V19,T13] (  2,  1   )   byref  ->  rax         V06._pointer(offs=0x00) P-INDEP "field V06._pointer (fldOffset=0x0)"
;  V20 tmp19        [V20,T16] (  2,  1   )     int  ->  rbx         V06._length(offs=0x08) P-INDEP "field V06._length (fldOffset=0x8)"
;  V21 tmp20        [V21,T14] (  2,  1   )   byref  ->  rax         V07._pointer(offs=0x00) P-INDEP "field V07._pointer (fldOffset=0x0)"
;* V22 tmp21        [V22,T18] (  0,  0   )     int  ->  zero-ref    V07._length(offs=0x08) P-INDEP "field V07._length (fldOffset=0x8)"
;  V23 tmp22        [V23,T15] (  2,  1   )   byref  ->  rbx         V10._value(offs=0x00) P-INDEP "field V10._value (fldOffset=0x0)"
;  V24 tmp23        [V24    ] (  2,  4   )  struct (16) [rsp+0x20]   do-not-enreg[XSB] must-init addr-exposed "by-value struct argument"
;  V25 tmp24        [V25,T03] (  3,  6   )   byref  ->  rdx         stack-byref "BlockOp address local"
;  V26 tmp25        [V26,T04] (  2,  4   )     ref  ->  rcx         "argument with side effect"
;  V27 cse0         [V27,T12] (  2,  1   )     ref  ->  rdx         "CSE - moderate"
;
; Lcl frame size = 48
Setting stack level from -572662307 to 0

=============== Generating BB01 [000..012) -> BB03 (cond), preds={} succs={BB02,BB03} flags=0x00000004.40830020: i label target hascall newobj LIR 
BB01 IN (1)={    V00} + ByrefExposed + GcHeap
     OUT(2)={V02 V00} + ByrefExposed + GcHeap

Recording Var Locations at start of BB01
  V00(rsi)
Change life 0000000000000000 {} -> 0000000000000002 {V00}
							V00 in reg rsi is becoming live  [------]
							Live regs: 00000000 {} => 00000040 {rsi}
							Live regs: (unchanged) 00000040 {rsi}
							GC regs: (unchanged) 00000040 {rsi}
							Byref regs: (unchanged) 00000000 {}

      L_M50607_BB01:
Label: IG02, GCvars=0000000000000000 {}, gcrefRegs=00000040 {rsi}, byrefRegs=00000000 {}

Scope info: begin block BB01, IL range [000..012)
Scope info: open scopes =
   0 (V00 arg0) [000..012)
Added IP mapping: 0x0000 STACK_EMPTY (G_M50607_IG02,ins#0,ofs#0) label
Generating: N003 (???,???) [000234] ------------                 IL_OFFSET void   IL offset: 0x0 REG NA
Generating: N005 (  2, 10) [000001] H-----------         t1 =    CNS_INT(h) long   0xd1ffab1e token REG rcx $100
IN0001:        mov      rcx, 0xD1FFAB1E
                                                              /--*  t1     long   
Generating: N007 (???,???) [000257] ------------       t257 = *  PUTARG_REG long   REG rcx
                                                              /--*  t257   long   arg0 in rcx
Generating: N009 ( 16, 16) [000002] --C---------         t2 = *  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST REG rax $180
							Call: GCvars=0000000000000000 {}, gcrefRegs=00000040 {rsi}, byrefRegs=00000000 {}
IN0002:        call     CORINFO_HELP_NEWSFAST
							GC regs: 00000040 {rsi} => 00000041 {rax rsi}
                                                              /--*  t2     ref    
Generating: N011 ( 16, 16) [000004] DA----------              *  STORE_LCL_VAR ref    V02 tmp1         d:1 rdi REG rdi
							GC regs: 00000041 {rax rsi} => 00000040 {rsi}
IN0003:        mov      rdi, rax
							V02 in reg rdi is becoming live  [000004]
							Live regs: 00000040 {rsi} => 000000C0 {rsi rdi}
							Live vars: {V00} => {V00 V02}
							GC regs: 00000040 {rsi} => 000000C0 {rsi rdi}
Generating: N013 (  2, 10) [000018] H-----------        t18 =    CNS_INT(h) long   0xd1ffab1e token REG rcx $101
IN0004:        mov      rcx, 0xD1FFAB1E
                                                              /--*  t18    long   
Generating: N015 (???,???) [000258] ------------       t258 = *  PUTARG_REG long   REG rcx
                                                              /--*  t258   long   arg0 in rcx
Generating: N017 ( 16, 16) [000019] --C---------        t19 = *  CALL help ref    HELPER.CORINFO_HELP_NEWSFAST REG rax $181
							Call: GCvars=0000000000000000 {}, gcrefRegs=000000C0 {rsi rdi}, byrefRegs=00000000 {}
IN0005:        call     CORINFO_HELP_NEWSFAST
							GC regs: 000000C0 {rsi rdi} => 000000C1 {rax rsi rdi}
                                                              /--*  t19    ref    
Generating: N019 ( 16, 16) [000021] DA----------              *  STORE_LCL_VAR ref    V04 tmp3         d:1 rbx REG rbx
							GC regs: 000000C1 {rax rsi rdi} => 000000C0 {rsi rdi}
IN0006:        mov      rbx, rax
							V04 in reg rbx is becoming live  [000021]
							Live regs: 000000C0 {rsi rdi} => 000000C8 {rbx rsi rdi}
							Live vars: {V00 V02} => {V00 V02 V04}
							GC regs: 000000C0 {rsi rdi} => 000000C8 {rbx rsi rdi}
Generating: N021 (  2, 10) [000044] ------------        t44 =    CNS_INT   long   0x7ffa40fb0028 REG rcx $200
IN0007:        mov      rcx, 0xD1FFAB1E
                                                              /--*  t44    long   
Generating: N023 (???,???) [000259] ------------       t259 = *  PUTARG_REG long   REG rcx
Generating: N025 (  1,  1) [000045] ------------        t45 =    CNS_INT   int    6 REG rdx $42
IN0008:        mov      edx, 6
                                                              /--*  t45    int    
Generating: N027 (???,???) [000260] ------------       t260 = *  PUTARG_REG int    REG rdx
                                                              /--*  t259   long   arg0 in rcx
                                                              +--*  t260   int    arg1 in rdx
Generating: N029 ( 17, 18) [000046] H-CXG-------        t46 = *  CALL help long   HELPER.CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS REG rax $281
							Call: GCvars=0000000000000000 {}, gcrefRegs=000000C8 {rbx rsi rdi}, byrefRegs=00000000 {}
IN0009:        call     CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS
Generating: N031 (  2, 10) [000143] I-----------       t143 =    CNS_INT(h) long   0xd1ffab1e static Fseq[Value] REG rdx $102
IN000a:        mov      rdx, 0xD1FFAB1E
                                                              /--*  t143   long   
Generating: N033 (  4, 12) [000042] n---G-------        t42 = *  IND       ref    REG rdx <l:$2c0, c:$144>
IN000b:        mov      rdx, gword ptr [rdx]
							GC regs: 000000C8 {rbx rsi rdi} => 000000CC {rdx rbx rsi rdi}
Generating: N035 (  1,  1) [000035] ------------        t35 =    LCL_VAR   ref    V04 tmp3         u:1 rbx REG rbx $181
                                                              /--*  t35    ref    
Generating: N037 (  2,  2) [000140] ------------       t140 = *  LEA(b+8)  byref  REG rcx
IN000c:        lea      rcx, bword ptr [rbx+8]
							Byref regs: 00000000 {} => 00000002 {rcx}
                                                              /--*  t140   byref  
                                                              +--*  t42    ref    
Generating: N039 (???,???) [000235] -ACXGO------              *  STOREIND  ref    REG NA
							Byref regs: 00000002 {rcx} => 00000000 {}
							GC regs: 000000CC {rdx rbx rsi rdi} => 000000C8 {rbx rsi rdi}
NoGC Call: savedSet=0000F0E8 {rbx rbp rsi rdi r12 r13 r14 r15}
							Call: GCvars=0000000000000000 {}, gcrefRegs=000000C8 {rbx rsi rdi}, byrefRegs=00000000 {}
IN000d:        call     CORINFO_HELP_ASSIGN_REF
Generating: N041 (  1,  1) [000005] ------------         t5 =    LCL_VAR   ref    V02 tmp1         u:1 rdi REG rdi $180
                                                              /--*  t5     ref    
Generating: N043 (  2,  2) [000145] ------------       t145 = *  LEA(b+16) byref  REG rcx
IN000e:        lea      rcx, bword ptr [rdi+16]
							Byref regs: 00000000 {} => 00000002 {rcx}
Generating: N045 (  1,  1) [000024] ------------        t24 =    LCL_VAR   ref    V04 tmp3         u:1 rbx (last use) REG rbx $181
                                                              /--*  t145   byref  
                                                              +--*  t24    ref    
Generating: N047 (???,???) [000236] -A--GO------              *  STOREIND  ref    REG NA
							Byref regs: 00000002 {rcx} => 00000000 {}
							V04 in reg rbx is becoming dead  [000024]
							Live regs: 000000C8 {rbx rsi rdi} => 000000C0 {rsi rdi}
							Live vars: {V00 V02 V04} => {V00 V02}
							GC regs: 000000C8 {rbx rsi rdi} => 000000C0 {rsi rdi}
IN000f:        mov      rdx, rbx
NoGC Call: savedSet=0000F0E8 {rbx rbp rsi rdi r12 r13 r14 r15}
							Call: GCvars=0000000000000000 {}, gcrefRegs=000000C0 {rsi rdi}, byrefRegs=00000000 {}
IN0010:        call     CORINFO_HELP_ASSIGN_REF
Generating: N049 (  1,  1) [000029] ------------        t29 =    LCL_VAR   ref    V02 tmp1         u:1 rdi REG rdi $180
                                                              /--*  t29    ref    
Generating: N051 (  2,  2) [000147] -c----------       t147 = *  LEA(b+8)  byref  REG NA
Generating: N053 (  1,  1) [000030] ------------        t30 =    CNS_INT   ref    null REG rcx $VN.Null
IN0011:        xor      rcx, rcx
							GC regs: 000000C0 {rsi rdi} => 000000C2 {rcx rsi rdi}
                                                              /--*  t147   byref  
                                                              +--*  t30    ref    
Generating: N055 (???,???) [000237] -A--GO------              *  STOREIND  ref    REG NA
							GC regs: 000000C2 {rcx rsi rdi} => 000000C0 {rsi rdi}
IN0012:        mov      gword ptr [rdi+8], rcx
Added IP mapping: 0x0006 (G_M50607_IG02,ins#18,ofs#96)
Generating: N057 (???,???) [000238] ------------                 IL_OFFSET void   IL offset: 0x6 REG NA
Generating: N059 (  1,  1) [000008] ------------         t8 =    LCL_VAR   ref    V00 arg0         u:1 rsi REG rsi $80
Generating: N061 (  1,  1) [000050] -c----------        t50 =    CNS_INT   ref    null REG NA $VN.Null
                                                              /--*  t8     ref    
                                                              +--*  t50    ref    
Generating: N063 (  3,  3) [000051] J------N----              *  NE        void   REG NA $340
IN0013:        test     rsi, rsi
Generating: N065 (  5,  5) [000052] ------------              *  JTRUE     void   REG NA
IN0014:        jne      L_M50607_BB03

Scope info: end block BB01, IL range [000..012)
Scope info: ending scope, LVnum=0 [000..012)
Scope info: open scopes =
   <none>

=============== Generating BB02 [006..007) -> BB06 (always), preds={BB01} succs={BB06} flags=0x00000000.40000020: i LIR 
BB02 IN (1)={V02        } + ByrefExposed + GcHeap
     OUT(3)={V02 V17 V18} + ByrefExposed + GcHeap

Recording Var Locations at start of BB02
  V02(rdi)
Change life 0000000000000003 {V00 V02} -> 0000000000000001 {V02}
							V00 in reg rsi is becoming dead  [------]
							Live regs: (unchanged) 00000000 {}
							Live regs: 00000000 {} => 00000080 {rdi}
							GC regs: 00000000 {} => 00000080 {rdi}
							Byref regs: (unchanged) 00000000 {}

      L_M50607_BB02:

      G_M50607_IG02:        ; offs=000000H, funclet=00, bbWeight=1   
Label: IG03, GCvars=0000000000000000 {}, gcrefRegs=00000080 {rdi}, byrefRegs=00000000 {}

Scope info: begin block BB02, IL range [006..007)
Scope info: open scopes =
   <none>
genIPmappingAdd: ignoring duplicate IL offset 0x80000006
Generating: N069 (???,???) [000239] ------------                 IL_OFFSET void   IL offset: 0x6 REG NA
Generating: N071 (  1,  1) [000149] ------------       t149 =    CNS_INT   byref  0 REG rax $VN.Null
IN0015:        xor      rax, rax
							Byref regs: 00000000 {} => 00000001 {rax}
                                                              /--*  t149   byref  
Generating: N073 (  5,  4) [000150] DA----------              *  STORE_LCL_VAR byref  V21 tmp20        d:1 rax REG rax
							Byref regs: 00000001 {rax} => 00000000 {}
							V21 in reg rax is becoming live  [000150]
							Live regs: 00000080 {rdi} => 00000081 {rax rdi}
							Live vars: {V02} => {V02 V21}
							Byref regs: 00000000 {} => 00000001 {rax}
genIPmappingAdd: ignoring duplicate IL offset 0x80000006
Generating: N075 (???,???) [000240] ------------                 IL_OFFSET void   IL offset: 0x6 REG NA
Generating: N077 (  3,  2) [000156] ------------       t156 =    LCL_VAR   byref  V21 tmp20        u:1 rax (last use) REG rax $VN.Null
                                                              /--*  t156   byref  
Generating: N079 (  7,  5) [000157] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:3 rax REG rax
							V21 in reg rax is becoming dead  [000156]
							Live regs: 00000081 {rax rdi} => 00000080 {rdi}
							Live vars: {V02 V21} => {V02}
							Byref regs: 00000001 {rax} => 00000000 {}
							V17 in reg rax is becoming live  [000157]
							Live regs: 00000080 {rdi} => 00000081 {rax rdi}
							Live vars: {V02} => {V02 V17}
							Byref regs: 00000000 {} => 00000001 {rax}
Generating: N081 (  1,  1) [000233] ------------       t233 =    CNS_INT   int    0 REG rbx $40
IN0016:        xor      ebx, ebx
                                                              /--*  t233   int    
Generating: N083 (  5,  4) [000160] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:3 rbx REG rbx
							V18 in reg rbx is becoming live  [000160]
							Live regs: 00000081 {rax rdi} => 00000089 {rax rbx rdi}
							Live vars: {V02 V17} => {V02 V17 V18}

Scope info: end block BB02, IL range [006..007)
Scope info: open scopes =
   <none>
IN0017:        jmp      L_M50607_BB06

=============== Generating BB03 [006..007) -> BB05 (cond), preds={BB01} succs={BB04,BB05} flags=0x00000000.40230420: i label target idxlen nullcheck LIR 
BB03 IN (2)={V02 V00            } + ByrefExposed + GcHeap
     OUT(4)={V02     V08 V14 V09} + ByrefExposed + GcHeap

Recording Var Locations at start of BB03
  V02(rdi)  V00(rsi)
Change life 0000000000000181 {V02 V17 V18} -> 0000000000000003 {V00 V02}
							V17 in reg rax is becoming dead  [------]
							Live regs: (unchanged) 00000000 {}
							V18 in reg rbx is becoming dead  [------]
							Live regs: (unchanged) 00000000 {}
							V00 in reg rsi is becoming live  [------]
							Live regs: 00000000 {} => 00000040 {rsi}
							Live regs: 00000040 {rsi} => 000000C0 {rsi rdi}
							GC regs: 00000040 {rsi} => 000000C0 {rsi rdi}
							Byref regs: (unchanged) 00000000 {}

      L_M50607_BB03:

      G_M50607_IG03:        ; offs=000069H, funclet=00, bbWeight=0.50
Label: IG04, GCvars=0000000000000000 {}, gcrefRegs=000000C0 {rsi rdi}, byrefRegs=00000000 {}

Scope info: begin block BB03, IL range [006..007)
Scope info: open scopes =
   0 (V00 arg0) [000..012)
genIPmappingAdd: ignoring duplicate IL offset 0x80000006
Generating: N087 (???,???) [000241] ------------                 IL_OFFSET void   IL offset: 0x6 REG NA
genIPmappingAdd: ignoring duplicate IL offset 0x80000006
Generating: N089 (???,???) [000242] ------------                 IL_OFFSET void   IL offset: 0x6 REG NA
Generating: N091 (  1,  1) [000171] ------------       t171 =    LCL_VAR   ref    V00 arg0         u:1 rsi REG rsi $80
Generating: N093 (  1,  1) [000172] -c----------       t172 =    CNS_INT   long   12 field offset Fseq[_firstChar] REG NA $203
                                                              /--*  t171   ref    
                                                              +--*  t172   long   
Generating: N095 (  3,  3) [000173] ------------       t173 = *  ADD       byref  REG rbx $303
IN0018:        lea      rbx, bword ptr [rsi+12]
							Byref regs: 00000000 {} => 00000008 {rbx}
                                                              /--*  t173   byref  
Generating: N097 (  7,  6) [000112] DA--G-------              *  STORE_LCL_VAR byref  V09 tmp8         d:1 rbx REG rbx
							Byref regs: 00000008 {rbx} => 00000000 {}
							V09 in reg rbx is becoming live  [000112]
							Live regs: 000000C0 {rsi rdi} => 000000C8 {rbx rsi rdi}
							Live vars: {V00 V02} => {V00 V02 V09}
							Byref regs: 00000000 {} => 00000008 {rbx}
genIPmappingAdd: ignoring duplicate IL offset 0x80000006
Generating: N099 (???,???) [000243] ------------                 IL_OFFSET void   IL offset: 0x6 REG NA
Generating: N101 (  1,  1) [000056] ------------        t56 =    LCL_VAR   ref    V00 arg0         u:1 rsi (last use) REG rsi $80
                                                              /--*  t56    ref    
Generating: N103 (???,???) [000256] -c----------       t256 = *  LEA(b+8)  ref    REG NA
                                                              /--*  t256   ref    
Generating: N105 (  3,  3) [000057] ---X--------        t57 = *  IND       int    REG rsi $341
							V00 in reg rsi is becoming dead  [000056]
							Live regs: 000000C8 {rbx rsi rdi} => 00000088 {rbx rdi}
							Live vars: {V00 V02 V09} => {V02 V09}
							GC regs: 000000C0 {rsi rdi} => 00000080 {rdi}
IN0019:        mov      esi, dword ptr [rsi+8]
                                                              /--*  t57    int    
Generating: N107 (  3,  3) [000114] DA-X--------              *  STORE_LCL_VAR int    V08 tmp7         d:1 rsi REG rsi
							V08 in reg rsi is becoming live  [000114]
							Live regs: 00000088 {rbx rdi} => 000000C8 {rbx rsi rdi}
							Live vars: {V02 V09} => {V02 V08 V09}
genIPmappingAdd: ignoring duplicate IL offset 0x80000006
Generating: N109 (???,???) [000244] ------------                 IL_OFFSET void   IL offset: 0x6 REG NA
Generating: N111 (  2, 10) [000118] H-----------       t118 =    CNS_INT(h) long   0xD1FFAB1E [ICON_STR_HDL] REG rcx $106
IN001a:        mov      rcx, 0xD1FFAB1E
                                                              /--*  t118   long   
Generating: N113 (  4, 12) [000119] #---G-------       t119 = *  IND       ref    REG rdx $18c
IN001b:        mov      rdx, gword ptr [rcx]
							GC regs: 00000080 {rdi} => 00000084 {rdx rdi}
                                                              /--*  t119   ref    
Generating: N115 (  8, 15) [000229] DA--G-------              *  STORE_LCL_VAR ref    V27 cse0         d:1 rdx REG rdx
							GC regs: 00000084 {rdx rdi} => 00000080 {rdi}
							V27 in reg rdx is becoming live  [000229]
							Live regs: 000000C8 {rbx rsi rdi} => 000000CC {rdx rbx rsi rdi}
							Live vars: {V02 V08 V09} => {V02 V08 V09 V27}
							GC regs: 00000080 {rdi} => 00000084 {rdx rdi}
genIPmappingAdd: ignoring duplicate IL offset 0x80000006
Generating: N117 (???,???) [000245] ------------                 IL_OFFSET void   IL offset: 0x6 REG NA
Generating: N119 (  3,  2) [000232] ------------       t232 =    LCL_VAR   ref    V27 cse0         u:1 rdx (last use) REG rdx $18c
                                                              /--*  t232   ref    
Generating: N121 (  7,  5) [000135] DA--G-------              *  STORE_LCL_VAR ref    V14 tmp13        d:1 rdx REG rdx
							V27 in reg rdx is becoming dead  [000232]
							Live regs: 000000CC {rdx rbx rsi rdi} => 000000C8 {rbx rsi rdi}
							Live vars: {V02 V08 V09 V27} => {V02 V08 V09}
							GC regs: 00000084 {rdx rdi} => 00000080 {rdi}
							V14 in reg rdx is becoming live  [000135]
							Live regs: 000000C8 {rbx rsi rdi} => 000000CC {rdx rbx rsi rdi}
							Live vars: {V02 V08 V09} => {V02 V08 V09 V14}
							GC regs: 00000080 {rdi} => 00000084 {rdx rdi}
genIPmappingAdd: ignoring duplicate IL offset 0x80000006
Generating: N123 (???,???) [000246] ------------                 IL_OFFSET void   IL offset: 0x6 REG NA
Generating: N125 (  1,  1) [000088] ------------        t88 =    LCL_VAR   int    V08 tmp7         u:1 rsi REG rsi $400
Generating: N127 (  1,  1) [000089] -c----------        t89 =    CNS_INT   int    0 REG NA $40
                                                              /--*  t88    int    
                                                              +--*  t89    int    
Generating: N129 (  3,  3) [000090] J------N----              *  GE        void   REG NA $342
IN001c:        test     esi, esi
Generating: N131 (  5,  5) [000128] ------------              *  JTRUE     void   REG NA
IN001d:        jge      L_M50607_BB05

Scope info: end block BB03, IL range [006..007)
Scope info: open scopes =
   <none>

=============== Generating BB04 [006..007), preds={BB03} succs={BB05} flags=0x00000004.40080020: i hascall gcsafe LIR 
BB04 IN (4)={V02 V08 V14 V09} + ByrefExposed + GcHeap
     OUT(3)={V02 V08     V09} + ByrefExposed + GcHeap

Recording Var Locations at start of BB04
  V02(rdi)  V08(rsi)  V14(rdx)  V09(rbx)
Liveness not changing: 0000000000000261 {V02 V08 V09 V14}
							Live regs: 00000000 {} => 000000CC {rdx rbx rsi rdi}
							GC regs: 00000000 {} => 00000084 {rdx rdi}
							Byref regs: 00000000 {} => 00000008 {rbx}

      L_M50607_BB04:

      G_M50607_IG04:        ; offs=000072H, funclet=00, bbWeight=0.50
Label: IG05, GCvars=0000000000000000 {}, gcrefRegs=00000084 {rdx rdi}, byrefRegs=00000008 {rbx}

Scope info: begin block BB04, IL range [006..007)
Scope info: open scopes =
   <none>
genIPmappingAdd: ignoring duplicate IL offset 0x80000006
Generating: N135 (???,???) [000247] ------------                 IL_OFFSET void   IL offset: 0x6 REG NA
Generating: N137 (  3,  2) [000129] ------------       t129 =    LCL_VAR   ref    V14 tmp13        u:1 rdx REG rdx $18c
                                                              /--*  t129   ref    
Generating: N139 (???,???) [000261] ------------       t261 = *  PUTARG_REG ref    REG rcx
IN001e:        mov      rcx, rdx
							GC regs: 00000084 {rdx rdi} => 00000086 {rcx rdx rdi}
Generating: N141 (  3,  2) [000130] ------------       t130 =    LCL_VAR   ref    V14 tmp13        u:1 rdx (last use) REG rdx $18c
                                                              /--*  t130   ref    
Generating: N143 (???,???) [000262] ------------       t262 = *  PUTARG_REG ref    REG rdx
							V14 in reg rdx is becoming dead  [000130]
							Live regs: 000000CC {rdx rbx rsi rdi} => 000000C8 {rbx rsi rdi}
							Live vars: {V02 V08 V09 V14} => {V02 V08 V09}
							GC regs: 00000086 {rcx rdx rdi} => 00000082 {rcx rdi}
							GC regs: 00000082 {rcx rdi} => 00000086 {rcx rdx rdi}
                                                              /--*  t261   ref    arg0 in rcx
                                                              +--*  t262   ref    arg1 in rdx
Generating: N145 ( 20, 11) [000131] --CXG-------              *  CALL      void   System.Diagnostics.Debug.Fail REG NA $VN.Void
							GC regs: 00000086 {rcx rdx rdi} => 00000084 {rdx rdi}
							GC regs: 00000084 {rdx rdi} => 00000080 {rdi}
							Call: GCvars=0000000000000000 {}, gcrefRegs=00000080 {rdi}, byrefRegs=00000008 {rbx}
IN001f:        call     System.Diagnostics.Debug:Fail(System.String,System.String)

Scope info: end block BB04, IL range [006..007)
Scope info: open scopes =
   <none>

=============== Generating BB05 [006..007), preds={BB03,BB04} succs={BB06} flags=0x00000000.40230420: i label target idxlen nullcheck LIR 
BB05 IN (3)={V02 V08         V09} + ByrefExposed + GcHeap
     OUT(3)={V02     V17 V18    } + ByrefExposed + GcHeap

Recording Var Locations at start of BB05
  V02(rdi)  V08(rsi)  V09(rbx)
Liveness not changing: 0000000000000221 {V02 V08 V09}
							Live regs: 00000000 {} => 000000C8 {rbx rsi rdi}
							GC regs: 00000000 {} => 00000080 {rdi}
							Byref regs: 00000000 {} => 00000008 {rbx}

      L_M50607_BB05:

      G_M50607_IG05:        ; offs=00008EH, funclet=00, bbWeight=0.25
Label: IG06, GCvars=0000000000000000 {}, gcrefRegs=00000080 {rdi}, byrefRegs=00000008 {rbx}

Scope info: begin block BB05, IL range [006..007)
Scope info: open scopes =
   <none>
genIPmappingAdd: ignoring duplicate IL offset 0x80000006
Generating: N149 (???,???) [000248] ------------                 IL_OFFSET void   IL offset: 0x6 REG NA
Generating: N151 (  3,  2) [000096] ------------        t96 =    LCL_VAR   byref  V09 tmp8         u:1 rbx (last use) REG rbx $303
                                                              /--*  t96    byref  
Generating: N153 (  7,  5) [000100] DA----------              *  STORE_LCL_VAR byref  V23 tmp22        d:1 rbx REG rbx
							V09 in reg rbx is becoming dead  [000096]
							Live regs: 000000C8 {rbx rsi rdi} => 000000C0 {rsi rdi}
							Live vars: {V02 V08 V09} => {V02 V08}
							Byref regs: 00000008 {rbx} => 00000000 {}
							V23 in reg rbx is becoming live  [000100]
							Live regs: 000000C0 {rsi rdi} => 000000C8 {rbx rsi rdi}
							Live vars: {V02 V08} => {V02 V08 V23}
							Byref regs: 00000000 {} => 00000008 {rbx}
genIPmappingAdd: ignoring duplicate IL offset 0x80000006
Generating: N155 (???,???) [000249] ------------                 IL_OFFSET void   IL offset: 0x6 REG NA
Generating: N157 (  3,  2) [000178] -------N----       t178 =    LCL_VAR   byref  V23 tmp22        u:1 rbx (last use) REG rbx $303
                                                              /--*  t178   byref  
Generating: N159 (  7,  5) [000179] DA----------              *  STORE_LCL_VAR byref  V19 tmp18        d:1 rax REG rax
							V23 in reg rbx is becoming dead  [000178]
							Live regs: 000000C8 {rbx rsi rdi} => 000000C0 {rsi rdi}
							Live vars: {V02 V08 V23} => {V02 V08}
							Byref regs: 00000008 {rbx} => 00000000 {}
IN0020:        mov      rax, rbx
							V19 in reg rax is becoming live  [000179]
							Live regs: 000000C0 {rsi rdi} => 000000C1 {rax rsi rdi}
							Live vars: {V02 V08} => {V02 V08 V19}
							Byref regs: 00000000 {} => 00000001 {rax}
genIPmappingAdd: ignoring duplicate IL offset 0x80000006
Generating: N161 (???,???) [000250] ------------                 IL_OFFSET void   IL offset: 0x6 REG NA
Generating: N163 (  1,  1) [000108] ------------       t108 =    LCL_VAR   int    V08 tmp7         u:1 rsi (last use) REG rsi $400
                                                              /--*  t108   int    
Generating: N165 (  5,  4) [000110] DA----------              *  STORE_LCL_VAR int    V20 tmp19        d:1 rbx REG rbx
							V08 in reg rsi is becoming dead  [000108]
							Live regs: 000000C1 {rax rsi rdi} => 00000081 {rax rdi}
							Live vars: {V02 V08 V19} => {V02 V19}
IN0021:        mov      ebx, esi
							V20 in reg rbx is becoming live  [000110]
							Live regs: 00000081 {rax rdi} => 00000089 {rax rbx rdi}
							Live vars: {V02 V19} => {V02 V19 V20}
genIPmappingAdd: ignoring duplicate IL offset 0x80000006
Generating: N167 (???,???) [000251] ------------                 IL_OFFSET void   IL offset: 0x6 REG NA
Generating: N169 (  3,  2) [000181] ------------       t181 =    LCL_VAR   byref  V19 tmp18        u:1 rax (last use) REG rax $303
                                                              /--*  t181   byref  
Generating: N171 (  7,  5) [000182] DA----------              *  STORE_LCL_VAR byref  V17 tmp16        d:2 rax REG rax
							V19 in reg rax is becoming dead  [000181]
							Live regs: 00000089 {rax rbx rdi} => 00000088 {rbx rdi}
							Live vars: {V02 V19 V20} => {V02 V20}
							Byref regs: 00000001 {rax} => 00000000 {}
							V17 in reg rax is becoming live  [000182]
							Live regs: 00000088 {rbx rdi} => 00000089 {rax rbx rdi}
							Live vars: {V02 V20} => {V02 V17 V20}
							Byref regs: 00000000 {} => 00000001 {rax}
Generating: N173 (  3,  2) [000184] ------------       t184 =    LCL_VAR   int    V20 tmp19        u:1 rbx (last use) REG rbx $400
                                                              /--*  t184   int    
Generating: N175 (  7,  5) [000185] DA----------              *  STORE_LCL_VAR int    V18 tmp17        d:2 rbx REG rbx
							V20 in reg rbx is becoming dead  [000184]
							Live regs: 00000089 {rax rbx rdi} => 00000081 {rax rdi}
							Live vars: {V02 V17 V20} => {V02 V17}
							V18 in reg rbx is becoming live  [000185]
							Live regs: 00000081 {rax rdi} => 00000089 {rax rbx rdi}
							Live vars: {V02 V17} => {V02 V17 V18}

Scope info: end block BB05, IL range [006..007)
Scope info: open scopes =
   <none>

=============== Generating BB06 [???..???) (return), preds={BB02,BB05} succs={} flags=0x00000004.408b0040: internal label target hascall gcsafe newobj LIR 
BB06 IN (3)={V02 V17 V18} + ByrefExposed + GcHeap
     OUT(0)={           }

Recording Var Locations at start of BB06
  V02(rdi)  V17(rax)  V18(rbx)
Liveness not changing: 0000000000000181 {V02 V17 V18}
							Live regs: 00000000 {} => 00000089 {rax rbx rdi}
							GC regs: 00000000 {} => 00000080 {rdi}
							Byref regs: 00000000 {} => 00000001 {rax}

      L_M50607_BB06:

      G_M50607_IG06:        ; offs=000096H, funclet=00, bbWeight=0.50
Label: IG07, GCvars=0000000000000000 {}, gcrefRegs=00000080 {rdi}, byrefRegs=00000001 {rax}

Scope info: begin block BB06, IL range [???..???)
Scope info: ignoring block beginning
Added IP mapping: NO_MAP STACK_EMPTY (G_M50607_IG07,ins#0,ofs#0) label
Generating: N179 (  3,  2) [000188] ------------       t188 =    LCL_VAR   byref  V17 tmp16        u:1 rax (last use) REG rax $480
                                                              /--*  t188   byref  
Generating: N181 (  7,  5) [000189] DA----------              *  STORE_LCL_VAR byref  V15 tmp14        d:1 rax REG rax
							V17 in reg rax is becoming dead  [000188]
							Live regs: 00000089 {rax rbx rdi} => 00000088 {rbx rdi}
							Live vars: {V02 V17 V18} => {V02 V18}
							Byref regs: 00000001 {rax} => 00000000 {}
							V15 in reg rax is becoming live  [000189]
							Live regs: 00000088 {rbx rdi} => 00000089 {rax rbx rdi}
							Live vars: {V02 V18} => {V02 V15 V18}
							Byref regs: 00000000 {} => 00000001 {rax}
Generating: N183 (  3,  2) [000191] ------------       t191 =    LCL_VAR   int    V18 tmp17        u:1 rbx (last use) REG rbx $440
                                                              /--*  t191   int    
Generating: N185 (  7,  5) [000192] DA----------              *  STORE_LCL_VAR int    V16 tmp15        d:1 rbx REG rbx
							V18 in reg rbx is becoming dead  [000191]
							Live regs: 00000089 {rax rbx rdi} => 00000081 {rax rdi}
							Live vars: {V02 V15 V18} => {V02 V15}
							V16 in reg rbx is becoming live  [000192]
							Live regs: 00000081 {rax rdi} => 00000089 {rax rbx rdi}
							Live vars: {V02 V15} => {V02 V15 V16}
Generating: N187 (  1,  1) [000007] ------------         t7 =    LCL_VAR   ref    V02 tmp1         u:1 rdi (last use) REG rdi $180
                                                              /--*  t7     ref    
Generating: N189 (  1,  3) [000214] DA--------L-              *  STORE_LCL_VAR ref    V26 tmp25        d:1 rcx REG rcx
							V02 in reg rdi is becoming dead  [000007]
							Live regs: 00000089 {rax rbx rdi} => 00000009 {rax rbx}
							Live vars: {V02 V15 V16} => {V15 V16}
							GC regs: 00000080 {rdi} => 00000000 {}
IN0022:        mov      rcx, rdi
							V26 in reg rcx is becoming live  [000214]
							Live regs: 00000009 {rax rbx} => 0000000B {rax rcx rbx}
							Live vars: {V15 V16} => {V15 V16 V26}
							GC regs: 00000000 {} => 00000002 {rcx}
Generating: N191 (  3,  2) [000198] -------N----       t198 =    LCL_VAR_ADDR byref  V24 tmp23         rdx REG rdx
IN0023:        lea      rdx, bword ptr [V24 rsp+20H]
							Byref regs: 00000001 {rax} => 00000005 {rax rdx}
                                                              /--*  t198   byref  
Generating: N193 (  3,  3) [000200] DA----------              *  STORE_LCL_VAR byref  V25 tmp24        d:1 rdx REG rdx
							Byref regs: 00000005 {rax rdx} => 00000001 {rax}
							V25 in reg rdx is becoming live  [000200]
							Live regs: 0000000B {rax rcx rbx} => 0000000F {rax rcx rdx rbx}
							Live vars: {V15 V16 V26} => {V15 V16 V25 V26}
							Byref regs: 00000001 {rax} => 00000005 {rax rdx}
Generating: N195 (  1,  1) [000201] ------------       t201 =    LCL_VAR   byref  V25 tmp24        u:1 rdx Zero Fseq[_pointer] REG rdx $3c7
Generating: N197 (  3,  2) [000203] -------N----       t203 =    LCL_VAR   byref  V15 tmp14        u:1 rax (last use) REG rax $480
                                                              /--*  t201   byref  
                                                              +--*  t203   byref  
Generating: N199 (???,???) [000252] -A----------              *  STOREIND  byref  REG NA
							V15 in reg rax is becoming dead  [000203]
							Live regs: 0000000F {rax rcx rdx rbx} => 0000000E {rcx rdx rbx}
							Live vars: {V15 V16 V25 V26} => {V16 V25 V26}
							Byref regs: 00000005 {rax rdx} => 00000004 {rdx}
IN0024:        mov      bword ptr [rdx], rax
Generating: N201 (  1,  1) [000206] ------------       t206 =    LCL_VAR   byref  V25 tmp24        u:1 rdx (last use) REG rdx $3c7
                                                              /--*  t206   byref  
Generating: N203 (  2,  2) [000208] -c----------       t208 = *  LEA(b+8)  byref  REG NA
Generating: N205 (  3,  2) [000210] -------N----       t210 =    LCL_VAR   int    V16 tmp15        u:1 rbx (last use) REG rbx $440
                                                              /--*  t208   byref  
                                                              +--*  t210   int    
Generating: N207 (???,???) [000253] -A--------L-              *  STOREIND  int    REG NA
							V25 in reg rdx is becoming dead  [000206]
							Live regs: 0000000E {rcx rdx rbx} => 0000000A {rcx rbx}
							Live vars: {V16 V25 V26} => {V16 V26}
							Byref regs: 00000004 {rdx} => 00000000 {}
							V16 in reg rbx is becoming dead  [000210]
							Live regs: 0000000A {rcx rbx} => 00000002 {rcx}
							Live vars: {V16 V26} => {V26}
IN0025:        mov      dword ptr [rdx+8], ebx
Generating: N209 (  1,  1) [000215] ------------       t215 =    LCL_VAR   ref    V26 tmp25        u:1 rcx (last use) REG rcx $180
                                                              /--*  t215   ref    
Generating: N211 (???,???) [000263] ------------       t263 = *  PUTARG_REG ref    REG rcx
							V26 in reg rcx is becoming dead  [000215]
							Live regs: 00000002 {rcx} => 00000000 {}
							Live vars: {V26} => {}
							GC regs: 00000002 {rcx} => 00000000 {}
							GC regs: 00000000 {} => 00000002 {rcx}
Generating: N213 (  3,  2) [000216] -------N----       t216 =    LCL_VAR_ADDR byref  V24 tmp23         rdx REG rdx
IN0026:        lea      rdx, bword ptr [V24 rsp+20H]
							Byref regs: 00000000 {} => 00000004 {rdx}
                                                              /--*  t216   byref  
Generating: N215 (???,???) [000264] ------------       t264 = *  PUTARG_REG byref  REG rdx
							Byref regs: 00000004 {rdx} => 00000000 {}
							Byref regs: 00000000 {} => 00000004 {rdx}
                                                              /--*  t263   ref    this in rcx
                                                              +--*  t264   byref  arg1 in rdx
Generating: N217 ( 40, 30) [000011] --CXG-------              *  CALL      void   Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer.TokenizeLine REG NA $VN.Void
							GC regs: 00000002 {rcx} => 00000000 {}
							Byref regs: 00000004 {rdx} => 00000000 {}
							Call: GCvars=0000000000000000 {}, gcrefRegs=00000000 {}, byrefRegs=00000000 {}
IN0027:        call     Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer:TokenizeLine(System.ReadOnlySpan`1[Char]):this
Added IP mapping: 0x0011 STACK_EMPTY (G_M50607_IG07,ins#6,ofs#24) label
Generating: N219 (???,???) [000254] ------------                 IL_OFFSET void   IL offset: 0x11 REG NA
Generating: N221 (  0,  0) [000017] ------------                 RETURN    void   REG NA $382

Scope info: end block BB06, IL range [???..???)
Scope info: ignoring block end
Added IP mapping: EPILOG STACK_EMPTY (G_M50607_IG07,ins#6,ofs#24) label
Reserving epilog IG for block BB06
IN0028:        nop      

      G_M50607_IG07:        ; offs=00009BH, funclet=00, bbWeight=1   
*************** After placeholder IG creation
G_M50607_IG01:        ; func=00, offs=000000H, size=0000H, gcrefRegs=00000000 {} <-- Prolog IG
G_M50607_IG02:        ; offs=000000H, size=0069H, gcrefRegs=00000040 {rsi}, byrefRegs=00000000 {}, byref
G_M50607_IG03:        ; offs=000069H, size=0009H, gcrefRegs=00000080 {rdi}, byrefRegs=00000000 {}, byref
G_M50607_IG04:        ; offs=000072H, size=001CH, gcrefRegs=000000C0 {rsi rdi}, byrefRegs=00000000 {}, byref
G_M50607_IG05:        ; offs=00008EH, size=0008H, gcrefRegs=00000084 {rdx rdi}, byrefRegs=00000008 {rbx}, byref
G_M50607_IG06:        ; offs=000096H, size=0005H, gcrefRegs=00000080 {rdi}, byrefRegs=00000008 {rbx}, byref
G_M50607_IG07:        ; offs=00009BH, size=0019H, gcrefRegs=00000080 {rdi}, byrefRegs=00000001 {rax}, byref
G_M50607_IG08:        ; epilog placeholder, next placeholder=<END>, BB06 [0009], epilog, extend <-- First placeholder <-- Last placeholder
                      ;   PrevGCVars=0000000000000000 {}, PrevGCrefRegs=00000080 {rdi}, PrevByrefRegs=00000008 {rbx}
                      ;   InitGCVars=0000000000000000 {}, InitGCrefRegs=00000080 {rdi}, InitByrefRegs=00000001 {rax}
Liveness not changing: 0000000000000000 {}

# compCycleEstimate =    241, compSizeEstimate =   215 Accretion.JitDumpVisualizer.CLI.Program:Tokenize(System.String)
; Final local variable assignments
;
;  V00 arg0         [V00,T01] (  5,  4   )     ref  ->  rsi         class-hnd
;  V01 OutArgs      [V01    ] (  1,  1   )  lclBlk (32) [rsp+0x00]   "OutgoingArgSpace"
;  V02 tmp1         [V02,T00] (  4,  8   )     ref  ->  rdi         class-hnd exact "NewObj constructor temp"
;* V03 tmp2         [V03    ] (  0,  0   )  struct (16) zero-ref    "struct address for call/obj"
;  V04 tmp3         [V04,T02] (  3,  6   )     ref  ->  rbx         class-hnd exact "NewObj constructor temp"
;* V05 tmp4         [V05    ] (  0,  0   )  struct (16) zero-ref    "Inline return value spill temp"
;* V06 tmp5         [V06    ] (  0,  0   )  struct (16) zero-ref    "NewObj constructor temp"
;* V07 tmp6         [V07    ] (  0,  0   )  struct (16) zero-ref    ld-addr-op "Inline ldloca(s) first use temp"
;  V08 tmp7         [V08,T05] (  3,  3   )     int  ->  rsi         "Inlining Arg"
;  V09 tmp8         [V09,T09] (  2,  2   )   byref  ->  rbx         "Inlining Arg"
;* V10 tmp9         [V10    ] (  0,  0   )  struct ( 8) zero-ref    "NewObj constructor temp"
;* V11 tmp10        [V11    ] (  0,  0   )    bool  ->  zero-ref    "Inlining Arg"
;* V12 tmp11        [V12    ] (  0,  0   )    bool  ->  zero-ref    "Inlining Arg"
;* V13 tmp12        [V13,T17] (  0,  0   )     ref  ->  zero-ref    class-hnd "Inlining Arg"
;  V14 tmp13        [V14,T06] (  3,  2   )     ref  ->  rdx         class-hnd "Inlining Arg"
;  V15 tmp14        [V15,T10] (  2,  2   )   byref  ->  rax         V03._pointer(offs=0x00) P-INDEP "field V03._pointer (fldOffset=0x0)"
;  V16 tmp15        [V16,T11] (  2,  2   )     int  ->  rbx         V03._length(offs=0x08) P-INDEP "field V03._length (fldOffset=0x8)"
;  V17 tmp16        [V17,T07] (  3,  2   )   byref  ->  rax         V05._pointer(offs=0x00) P-INDEP "field V05._pointer (fldOffset=0x0)"
;  V18 tmp17        [V18,T08] (  3,  2   )     int  ->  rbx         V05._length(offs=0x08) P-INDEP "field V05._length (fldOffset=0x8)"
;  V19 tmp18        [V19,T13] (  2,  1   )   byref  ->  rax         V06._pointer(offs=0x00) P-INDEP "field V06._pointer (fldOffset=0x0)"
;  V20 tmp19        [V20,T16] (  2,  1   )     int  ->  rbx         V06._length(offs=0x08) P-INDEP "field V06._length (fldOffset=0x8)"
;  V21 tmp20        [V21,T14] (  2,  1   )   byref  ->  rax         V07._pointer(offs=0x00) P-INDEP "field V07._pointer (fldOffset=0x0)"
;* V22 tmp21        [V22,T18] (  0,  0   )     int  ->  zero-ref    V07._length(offs=0x08) P-INDEP "field V07._length (fldOffset=0x8)"
;  V23 tmp22        [V23,T15] (  2,  1   )   byref  ->  rbx         V10._value(offs=0x00) P-INDEP "field V10._value (fldOffset=0x0)"
;  V24 tmp23        [V24    ] (  2,  4   )  struct (16) [rsp+0x20]   do-not-enreg[XSB] must-init addr-exposed "by-value struct argument"
;  V25 tmp24        [V25,T03] (  3,  6   )   byref  ->  rdx         stack-byref "BlockOp address local"
;  V26 tmp25        [V26,T04] (  2,  4   )     ref  ->  rcx         "argument with side effect"
;  V27 cse0         [V27,T12] (  2,  1   )     ref  ->  rdx         "CSE - moderate"
;
; Lcl frame size = 48
*************** Before prolog / epilog generation
G_M50607_IG01:        ; func=00, offs=000000H, size=0000H, gcrefRegs=00000000 {} <-- Prolog IG
G_M50607_IG02:        ; offs=000000H, size=0069H, gcrefRegs=00000040 {rsi}, byrefRegs=00000000 {}, byref
G_M50607_IG03:        ; offs=000069H, size=0009H, gcrefRegs=00000080 {rdi}, byrefRegs=00000000 {}, byref
G_M50607_IG04:        ; offs=000072H, size=001CH, gcrefRegs=000000C0 {rsi rdi}, byrefRegs=00000000 {}, byref
G_M50607_IG05:        ; offs=00008EH, size=0008H, gcrefRegs=00000084 {rdx rdi}, byrefRegs=00000008 {rbx}, byref
G_M50607_IG06:        ; offs=000096H, size=0005H, gcrefRegs=00000080 {rdi}, byrefRegs=00000008 {rbx}, byref
G_M50607_IG07:        ; offs=00009BH, size=0019H, gcrefRegs=00000080 {rdi}, byrefRegs=00000001 {rax}, byref
G_M50607_IG08:        ; epilog placeholder, next placeholder=<END>, BB06 [0009], epilog, extend <-- First placeholder <-- Last placeholder
                      ;   PrevGCVars=0000000000000000 {}, PrevGCrefRegs=00000080 {rdi}, PrevByrefRegs=00000008 {rbx}
                      ;   InitGCVars=0000000000000000 {}, InitGCrefRegs=00000080 {rdi}, InitByrefRegs=00000001 {rax}
Recording Var Locations at start of BB01
  V00(rsi)
*************** In genFnProlog()
Added IP mapping to front: PROLOG STACK_EMPTY (G_M50607_IG01,ins#0,ofs#0) label

__prolog:
Found 4 lvMustInit int-sized stack slots, frame offsets -32 through -48
IN0029:        push     rdi
IN002a:        push     rsi
IN002b:        push     rbx
IN002c:        sub      rsp, 48
IN002d:        xor      rax, rax
IN002e:        mov      qword ptr [V24 rsp+20H], rax
*************** In genFnPrologCalleeRegArgs() for int regs
IN002f:        mov      rsi, rcx
*************** In genEnregisterIncomingStackArgs()


      G_M50607_IG01:        ; offs=000000H, funclet=00, bbWeight=1   
*************** In genFnEpilog()

__epilog:
gcVarPtrSetCur=0000000000000000 {}, gcRegGCrefSetCur=00000080 {rdi}, gcRegByrefSetCur=00000001 {rax}
IN0030:        add      rsp, 48
IN0031:        pop      rbx
IN0032:        pop      rsi
IN0033:        pop      rdi
IN0034:        ret      

      G_M50607_IG08:        ; offs=0000B4H, funclet=00, bbWeight=1   
0 prologs, 1 epilogs, 0 funclet prologs, 0 funclet epilogs
*************** After prolog / epilog generation
G_M50607_IG01:        ; func=00, offs=000000H, size=0011H, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, byref, nogc <-- Prolog IG
G_M50607_IG02:        ; offs=000011H, size=0069H, gcrefRegs=00000040 {rsi}, byrefRegs=00000000 {}, byref
G_M50607_IG03:        ; offs=00007AH, size=0009H, gcrefRegs=00000080 {rdi}, byrefRegs=00000000 {}, byref
G_M50607_IG04:        ; offs=000083H, size=001CH, gcrefRegs=000000C0 {rsi rdi}, byrefRegs=00000000 {}, byref
G_M50607_IG05:        ; offs=00009FH, size=0008H, gcrefRegs=00000084 {rdx rdi}, byrefRegs=00000008 {rbx}, byref
G_M50607_IG06:        ; offs=0000A7H, size=0005H, gcrefRegs=00000080 {rdi}, byrefRegs=00000008 {rbx}, byref
G_M50607_IG07:        ; offs=0000ACH, size=0019H, gcrefRegs=00000080 {rdi}, byrefRegs=00000001 {rax}, byref
G_M50607_IG08:        ; offs=0000C5H, size=0008H, epilog, nogc, extend
*************** In emitJumpDistBind()
Binding: IN0014: 000000 jne      L_M50607_BB03
Binding L_M50607_BB03 to G_M50607_IG04
Estimate of fwd jump [D1FFAB1E/020]: 0074 -> 0083 = 000D
Shrinking jump [D1FFAB1E/020]
Adjusted offset of BB03 from 007A to 0076
Binding: IN0017: 000000 jmp      L_M50607_BB06
Binding L_M50607_BB06 to G_M50607_IG07
Estimate of fwd jump [D1FFAB1E/023]: 007A -> 00A8 = 002C
Shrinking jump [D1FFAB1E/023]
Adjusted offset of BB04 from 0083 to 007C
Binding: IN001d: 000000 jge      L_M50607_BB05
Binding L_M50607_BB05 to G_M50607_IG06
Estimate of fwd jump [D1FFAB1E/029]: 0092 -> 00A0 = 000C
Shrinking jump [D1FFAB1E/029]
Adjusted offset of BB05 from 009F to 0094
Adjusted offset of BB06 from 00A7 to 009C
Adjusted offset of BB07 from 00AC to 00A1
Adjusted offset of BB08 from 00C5 to 00BA
Total shrinkage =  11, min extra jump size = 4294967295

*************** Finishing PHASE Generate code

*************** Starting PHASE Emit code

Hot  code size = 0xC2 bytes
Cold code size = 0x0 bytes
reserveUnwindInfo(isFunclet=FALSE, isColdCode=FALSE, unwindSize=0xc)
*************** In emitEndCodeGen()
Converting emitMaxStackDepth from bytes (0) to elements (0)

***************************************************************************
Instructions as they come out of the scheduler


G_M50607_IG01:        ; func=00, offs=000000H, size=0011H, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, byref, nogc <-- Prolog IG
IN0029: 000000 push     rdi
IN002a: 000001 push     rsi
IN002b: 000002 push     rbx
IN002c: 000003 sub      rsp, 48
IN002d: 000007 xor      rax, rax
IN002e: 000009 mov      qword ptr [rsp+20H], rax
IN002f: 00000E mov      rsi, rcx
       ; gcrRegs +[rsi]
						;; bbWeight=1    PerfScore 4.75
G_M50607_IG02:        ; func=00, offs=000011H, size=0065H, gcrefRegs=00000040 {rsi}, byrefRegs=00000000 {}, byref, isz
IN0001: 000011 mov      rcx, 0xD1FFAB1E
IN0002: 00001B call     CORINFO_HELP_NEWSFAST
       ; gcrRegs +[rax]
       ; gcr arg pop 0
IN0003: 000020 mov      rdi, rax
       ; gcrRegs +[rdi]
IN0004: 000023 mov      rcx, 0xD1FFAB1E
IN0005: 00002D call     CORINFO_HELP_NEWSFAST
       ; gcr arg pop 0
IN0006: 000032 mov      rbx, rax
       ; gcrRegs +[rbx]
IN0007: 000035 mov      rcx, 0xD1FFAB1E
IN0008: 00003F mov      edx, 6
IN0009: 000044 call     CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS
       ; gcrRegs -[rax]
       ; gcr arg pop 0
IN000a: 000049 mov      rdx, 0xD1FFAB1E
IN000b: 000053 mov      rdx, gword ptr [rdx]
       ; gcrRegs +[rdx]
IN000c: 000056 lea      rcx, bword ptr [rbx+8]
       ; byrRegs +[rcx]
IN000d: 00005A call     CORINFO_HELP_ASSIGN_REF
       ; gcrRegs -[rdx]
       ; byrRegs -[rcx]
IN000e: 00005F lea      rcx, bword ptr [rdi+16]
       ; byrRegs +[rcx]
IN000f: 000063 mov      rdx, rbx
       ; gcrRegs +[rdx]
IN0010: 000066 call     CORINFO_HELP_ASSIGN_REF
       ; gcrRegs -[rdx rbx]
       ; byrRegs -[rcx]
IN0011: 00006B xor      rcx, rcx
       ; gcrRegs +[rcx]
IN0012: 00006D mov      gword ptr [rdi+8], rcx
IN0013: 000071 test     rsi, rsi
IN0014: 000074 jne      SHORT G_M50607_IG04
						;; bbWeight=1    PerfScore 12.50
G_M50607_IG03:        ; func=00, offs=000076H, size=0006H, gcrefRegs=00000080 {rdi}, byrefRegs=00000000 {}, byref, isz
       ; gcrRegs -[rcx rsi]
IN0015: 000076 xor      rax, rax
       ; byrRegs +[rax]
IN0016: 000078 xor      ebx, ebx
IN0017: 00007A jmp      SHORT G_M50607_IG07
						;; bbWeight=0.50 PerfScore 1.25
G_M50607_IG04:        ; func=00, offs=00007CH, size=0018H, gcrefRegs=000000C0 {rsi rdi}, byrefRegs=00000000 {}, byref, isz
       ; gcrRegs +[rsi]
       ; byrRegs -[rax]
IN0018: 00007C lea      rbx, bword ptr [rsi+12]
       ; byrRegs +[rbx]
IN0019: 000080 mov      esi, dword ptr [rsi+8]
       ; gcrRegs -[rsi]
IN001a: 000083 mov      rcx, 0xD1FFAB1E
IN001b: 00008D mov      rdx, gword ptr [rcx]
       ; gcrRegs +[rdx]
IN001c: 000090 test     esi, esi
IN001d: 000092 jge      SHORT G_M50607_IG06
						;; bbWeight=0.50 PerfScore 3.00
G_M50607_IG05:        ; func=00, offs=000094H, size=0008H, gcrefRegs=00000084 {rdx rdi}, byrefRegs=00000008 {rbx}, byref
IN001e: 000094 mov      rcx, rdx
       ; gcrRegs +[rcx]
IN001f: 000097 call     System.Diagnostics.Debug:Fail(System.String,System.String)
       ; gcrRegs -[rcx rdx]
       ; gcr arg pop 0
						;; bbWeight=0.25 PerfScore 0.31
G_M50607_IG06:        ; func=00, offs=00009CH, size=0005H, gcrefRegs=00000080 {rdi}, byrefRegs=00000008 {rbx}, byref
IN0020: 00009C mov      rax, rbx
       ; byrRegs +[rax]
IN0021: 00009F mov      ebx, esi
       ; byrRegs -[rbx]
						;; bbWeight=0.50 PerfScore 0.25
G_M50607_IG07:        ; func=00, offs=0000A1H, size=0019H, gcrefRegs=00000080 {rdi}, byrefRegs=00000001 {rax}, byref
IN0022: 0000A1 mov      rcx, rdi
       ; gcrRegs +[rcx]
IN0023: 0000A4 lea      rdx, bword ptr [rsp+20H]
       ; byrRegs +[rdx]
IN0024: 0000A9 mov      bword ptr [rdx], rax
IN0025: 0000AC mov      dword ptr [rdx+8], ebx
IN0026: 0000AF lea      rdx, bword ptr [rsp+20H]
IN0027: 0000B4 call     Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer:TokenizeLine(System.ReadOnlySpan`1[Char]):this
       ; gcrRegs -[rcx rdi]
       ; byrRegs -[rax rdx]
       ; gcr arg pop 0
IN0028: 0000B9 nop      
						;; bbWeight=1    PerfScore 4.50
G_M50607_IG08:        ; func=00, offs=0000BAH, size=0008H, epilog, nogc, extend
IN0030: 0000BA add      rsp, 48
IN0031: 0000BE pop      rbx
IN0032: 0000BF pop      rsi
IN0033: 0000C0 pop      rdi
IN0034: 0000C1 ret      
						;; bbWeight=1    PerfScore 2.75Allocated method code size =  194 , actual size =  194

; Total bytes of code 194, prolog size 14, PerfScore 48.71, instruction count 52 (MethodHash=a4553a50) for method Accretion.JitDumpVisualizer.CLI.Program:Tokenize(System.String)
; ============================================================

*************** After end code gen, before unwindEmit()
G_M50607_IG01:        ; func=00, offs=000000H, size=0011H, bbWeight=1    PerfScore 4.75, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, byref, nogc <-- Prolog IG

IN0029: 000000 push     rdi
IN002a: 000001 push     rsi
IN002b: 000002 push     rbx
IN002c: 000003 sub      rsp, 48
IN002d: 000007 xor      rax, rax
IN002e: 000009 mov      qword ptr [V24 rsp+20H], rax
IN002f: 00000E mov      rsi, rcx

G_M50607_IG02:        ; offs=000011H, size=0065H, bbWeight=1    PerfScore 12.50, gcrefRegs=00000040 {rsi}, byrefRegs=00000000 {}, byref, isz

IN0001: 000011 mov      rcx, 0xD1FFAB1E
IN0002: 00001B call     CORINFO_HELP_NEWSFAST
IN0003: 000020 mov      rdi, rax
IN0004: 000023 mov      rcx, 0xD1FFAB1E
IN0005: 00002D call     CORINFO_HELP_NEWSFAST
IN0006: 000032 mov      rbx, rax
IN0007: 000035 mov      rcx, 0xD1FFAB1E
IN0008: 00003F mov      edx, 6
IN0009: 000044 call     CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS
IN000a: 000049 mov      rdx, 0xD1FFAB1E
IN000b: 000053 mov      rdx, gword ptr [rdx]
IN000c: 000056 lea      rcx, bword ptr [rbx+8]
IN000d: 00005A call     CORINFO_HELP_ASSIGN_REF
IN000e: 00005F lea      rcx, bword ptr [rdi+16]
IN000f: 000063 mov      rdx, rbx
IN0010: 000066 call     CORINFO_HELP_ASSIGN_REF
IN0011: 00006B xor      rcx, rcx
IN0012: 00006D mov      gword ptr [rdi+8], rcx
IN0013: 000071 test     rsi, rsi
IN0014: 000074 jne      SHORT G_M50607_IG04

G_M50607_IG03:        ; offs=000076H, size=0006H, bbWeight=0.50 PerfScore 1.25, gcrefRegs=00000080 {rdi}, byrefRegs=00000000 {}, byref, isz

IN0015: 000076 xor      rax, rax
IN0016: 000078 xor      ebx, ebx
IN0017: 00007A jmp      SHORT G_M50607_IG07

G_M50607_IG04:        ; offs=00007CH, size=0018H, bbWeight=0.50 PerfScore 3.00, gcrefRegs=000000C0 {rsi rdi}, byrefRegs=00000000 {}, byref, isz

IN0018: 00007C lea      rbx, bword ptr [rsi+12]
IN0019: 000080 mov      esi, dword ptr [rsi+8]
IN001a: 000083 mov      rcx, 0xD1FFAB1E
IN001b: 00008D mov      rdx, gword ptr [rcx]
IN001c: 000090 test     esi, esi
IN001d: 000092 jge      SHORT G_M50607_IG06

G_M50607_IG05:        ; offs=000094H, size=0008H, bbWeight=0.25 PerfScore 0.31, gcrefRegs=00000084 {rdx rdi}, byrefRegs=00000008 {rbx}, byref

IN001e: 000094 mov      rcx, rdx
IN001f: 000097 call     System.Diagnostics.Debug:Fail(System.String,System.String)

G_M50607_IG06:        ; offs=00009CH, size=0005H, bbWeight=0.50 PerfScore 0.25, gcrefRegs=00000080 {rdi}, byrefRegs=00000008 {rbx}, byref

IN0020: 00009C mov      rax, rbx
IN0021: 00009F mov      ebx, esi

G_M50607_IG07:        ; offs=0000A1H, size=0019H, bbWeight=1    PerfScore 4.50, gcrefRegs=00000080 {rdi}, byrefRegs=00000001 {rax}, byref

IN0022: 0000A1 mov      rcx, rdi
IN0023: 0000A4 lea      rdx, bword ptr [V24 rsp+20H]
IN0024: 0000A9 mov      bword ptr [rdx], rax
IN0025: 0000AC mov      dword ptr [rdx+8], ebx
IN0026: 0000AF lea      rdx, bword ptr [V24 rsp+20H]
IN0027: 0000B4 call     Accretion.JitDumpVisualizer.Parsing.Tokens.Tokenizer:TokenizeLine(System.ReadOnlySpan`1[Char]):this
IN0028: 0000B9 nop      

G_M50607_IG08:        ; offs=0000BAH, size=0008H, bbWeight=1    PerfScore 2.75, epilog, nogc, extend

IN0030: 0000BA add      rsp, 48
IN0031: 0000BE pop      rbx
IN0032: 0000BF pop      rsi
IN0033: 0000C0 pop      rdi
IN0034: 0000C1 ret      


*************** Finishing PHASE Emit code

*************** Starting PHASE Emit GC+EH tables
Unwind Info:
  >> Start offset   : 0x000000 (not in unwind data)
  >>   End offset   : 0xd1ffab1e (not in unwind data)
  Version           : 1
  Flags             : 0x00
  SizeOfProlog      : 0x07
  CountOfUnwindCodes: 4
  FrameRegister     : none (0)
  FrameOffset       : N/A (no FrameRegister) (Value=0)
  UnwindCodes       :
    CodeOffset: 0x07 UnwindOp: UWOP_ALLOC_SMALL (2)     OpInfo: 5 * 8 + 8 = 48 = 0x30
    CodeOffset: 0x03 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rbx (3)
    CodeOffset: 0x02 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rsi (6)
    CodeOffset: 0x01 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rdi (7)
allocUnwindInfo(pHotCode=0x00000000D1FFAB1E, pColdCode=0x0000000000000000, startOffset=0x0, endOffset=0xc2, unwindSize=0xc, pUnwindBlock=0x00000000D1FFAB1E, funKind=0 (main function))
*************** In genIPmappingGen()
IP mapping count : 6
IL offs PROLOG : 0x00000000 ( STACK_EMPTY )
IL offs 0x0000 : 0x00000011 ( STACK_EMPTY )
IL offs 0x0006 : 0x00000071
IL offs NO_MAP : 0x000000A1 ( STACK_EMPTY )
IL offs 0x0011 : 0x000000B9 ( STACK_EMPTY )
IL offs EPILOG : 0x000000B9 ( STACK_EMPTY )

*************** In genSetScopeInfo()
VarLocInfo count is 3
; Variable debug info: 3 live range(s), 1 var(s) for method Accretion.JitDumpVisualizer.CLI.Program:Tokenize(System.String)
  0(   UNKNOWN) : From 00000000h to 00000011h, in rcx
  0(   UNKNOWN) : From 00000011h to 00000076h, in rsi
  0(   UNKNOWN) : From 0000007Ch to 00000080h, in rsi
*************** In gcInfoBlockHdrSave()
Set code length to 194.
Set ReturnKind to Scalar.
Set Outgoing stack arg area size to 32.
Stack slot id for offset 32 (0x20) (sp) (byref, untracked) = 0.
Register slot id for reg rsi = 1.
Register slot id for reg rdi = 2.
Register slot id for reg rbx = 3.
Register slot id for reg rbx (byref) = 4.
Set state of slot 1 at instr offset 0x1b to Live.
Set state of slot 1 at instr offset 0x20 to Dead.
Set state of slot 1 at instr offset 0x2d to Live.
Set state of slot 2 at instr offset 0x2d to Live.
Set state of slot 1 at instr offset 0x32 to Dead.
Set state of slot 2 at instr offset 0x32 to Dead.
Set state of slot 3 at instr offset 0x44 to Live.
Set state of slot 1 at instr offset 0x44 to Live.
Set state of slot 2 at instr offset 0x44 to Live.
Set state of slot 3 at instr offset 0x49 to Dead.
Set state of slot 1 at instr offset 0x49 to Dead.
Set state of slot 2 at instr offset 0x49 to Dead.
Set state of slot 4 at instr offset 0x97 to Live.
Set state of slot 2 at instr offset 0x97 to Live.
Set state of slot 4 at instr offset 0x9c to Dead.
Set state of slot 2 at instr offset 0x9c to Dead.
Defining 5 call sites:
    Offset 0x1b, size 5.
    Offset 0x2d, size 5.
    Offset 0x44, size 5.
    Offset 0x97, size 5.
    Offset 0xb4, size 5.

*************** Finishing PHASE Emit GC+EH tables
Method code size: 194

Allocations for Accretion.JitDumpVisualizer.CLI.Program:Tokenize(System.String) (MethodHash=a4553a50)
count:       2676, size:     195978, max =       4560
allocateMemory:     262144, nraUsed:     202624

Alloc'd bytes by kind:
                  kind |       size |     pct
  ---------------------+------------+--------
         AssertionProp |       6460 |   3.30%
               ASTNode |      34600 |  17.66%
              InstDesc |       5812 |   2.97%
              ImpStack |        384 |   0.20%
            BasicBlock |       5312 |   2.71%
             fgArgInfo |        512 |   0.26%
       fgArgInfoPtrArr |         64 |   0.03%
              FlowList |        320 |   0.16%
     TreeStatementList |         64 |   0.03%
               SiScope |        352 |   0.18%
       DominatorMemory |        336 |   0.17%
                  LSRA |       3568 |   1.82%
         LSRA_Interval |       3600 |   1.84%
      LSRA_RefPosition |      12608 |   6.43%
          Reachability |         16 |   0.01%
                   SSA |       2200 |   1.12%
           ValueNumber |      16599 |   8.47%
              LvaTable |       9700 |   4.95%
            UnwindInfo |          0 |   0.00%
                hashBv |        376 |   0.19%
                bitset |        600 |   0.31%
          FixedBitVect |        108 |   0.06%
               Generic |       5098 |   2.60%
   LocalAddressVisitor |          0 |   0.00%
         FieldSeqStore |        648 |   0.33%
    ZeroOffsetFieldMap |        456 |   0.23%
          ArrayInfoMap |         40 |   0.02%
          MemoryPhiArg |         64 |   0.03%
                   CSE |       1712 |   0.87%
                    GC |       3889 |   1.98%
       CorTailCallInfo |          0 |   0.00%
              Inlining |       7520 |   3.84%
            ArrayStack |          0 |   0.00%
             DebugInfo |        232 |   0.12%
             DebugOnly |      67391 |  34.39%
               Codegen |       1176 |   0.60%
               LoopOpt |          0 |   0.00%
             LoopHoist |          0 |   0.00%
               Unknown |       1009 |   0.51%
            RangeCheck |          0 |   0.00%
              CopyProp |       2720 |   1.39%
           SideEffects |          0 |   0.00%
       ObjectAllocator |          0 |   0.00%
    VariableLiveRanges |          0 |   0.00%
           ClassLayout |        112 |   0.06%
       TailMergeThrows |          0 |   0.00%
             EarlyProp |         96 |   0.05%
              ZeroInit |        224 |   0.11%

****** DONE compiling Accretion.JitDumpVisualizer.CLI.Program:Tokenize(System.String)